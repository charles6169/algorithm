# 图

## 概述

​		多对多的数据结构，由顶点的**非空**集合和顶点之间的边的集合组成；

### 图的概念

 数据元素

  在线性表中称为元素；在树中称为结点、在图中称为顶点

 数据元素集合

  在线性表中可以没有元素称为空表；在树中可以没有结点称为空树；在图中不能没有顶点，即顶点集合不能为空

 数据元素之间的关系

  在线性表中称为线性关系；在树中称为层次关系；在图中称为边的关系，边的集合可以为空；

 ![img](https://img2018.cnblogs.com/blog/1526920/201811/1526920-20181130100112303-944253917.png) 

 ![img](https://img2018.cnblogs.com/blog/1526920/201811/1526920-20181130100201937-1792584262.png) 

 ![img](https://img2018.cnblogs.com/blog/1526920/201811/1526920-20181130100245303-215593740.png) 



 ![img](https://img2018.cnblogs.com/blog/1526920/201811/1526920-20181130100335772-1223415966.png) 

 ![img](https://img2018.cnblogs.com/blog/1526920/201811/1526920-20181130100406689-1545664034.png) 

 ![img](https://img2018.cnblogs.com/blog/1526920/201811/1526920-20181130100440812-45852317.png) 

 ![img](https://img2018.cnblogs.com/blog/1526920/201811/1526920-20181130100530998-32340301.png) 

 ![img](https://img2018.cnblogs.com/blog/1526920/201811/1526920-20181130100550144-1414113345.png) 

 ![img](https://img2018.cnblogs.com/blog/1526920/201811/1526920-20181130100609906-108078284.png) 

 ![img](https://img2018.cnblogs.com/blog/1526920/201811/1526920-20181130100623138-1024873210.png) 



### 图的种类

#### 二分图

​		二部图又叫二分图，是图论中的一种特殊模型。设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交子集 ，使得每一条边都分别连接两个集合中的顶点。如果存在这样的划分，则此图为一个二分图，如下图所示的六个图全都是二分图：

![img](https://img-blog.csdnimg.cn/20190609121130545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2ODIyMDI5,size_16,color_FFFFFF,t_70)













## 图的实现

### 图的存储结构

#### 邻接矩阵

 由两个数组表示图；一个是存储顶点的数组，一维数组；一个是存储边或弧的数组，二维数组；

 ![img](https://img2018.cnblogs.com/blog/1526920/201811/1526920-20181130102117796-299298100.png) 

 ![img](https://img2018.cnblogs.com/blog/1526920/201811/1526920-20181130102500767-1278404929.png) 

#### 邻接表

  		重点掌握邻接表存储图，图的邻接矩阵存储法，它的空间和时间复杂度都是N2，现在我来介绍另外一种存储图的方法：邻接表，这样空间和时间复杂度就都是M。 对于稀疏图来说，M要远远小于N2。

输入数据

```
4 5
1 4 9
4 3 8
1 2 5
2 4 6
1 3 7
```

建图

![这里写图片描述](https://img-blog.csdn.net/20171009195503661?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTE9JX1E=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



​		第一行两个整数n m。n表示顶点个数（顶点编号为1~n），m表示边的条数。接下来m行表示，每行有3个数x y z，表示顶点x到顶点y的边的权值为z。

链表邻接表

![这里写图片描述](https://img-blog.csdn.net/20171009195436230?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTE9JX1E=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)





##### 数组邻接表

​		这种方法为每个顶点i（i从1~n）也都保存了一个类似“链表”的东西，里面保存的是从顶点i出发的所有的边，首先我们按照读入的顺序为每一条边进行编号（1~m）。比如第一条边“1 4 9”的编号就是1，“1 3 7”这条边的编号是5。

​		这里用u、v和w三个数组用来记录每条边的具体信息，即u[i]、v[i]和w[i]表示第i条边是从第u[i]号顶点到v[i]号顶点，且权值为w[i]。

![这里写图片描述](https://img-blog.csdn.net/20171009194908779?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTE9JX1E=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



```
first 数组来存储每个顶点其中一条边的编号，以便待会我们来枚举每个顶点所有的边。

next[i] 存储的是“编号为i的边”的“前一条边”的编号。
```



存储过程举例

初始状态

一共有三个序列：分别表示 边号，顶点号，边号

![这里写图片描述](https://img-blog.csdn.net/20171009194934214?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTE9JX1E=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



```
u,v,w:读入第1条边（1 4 9），将这条边的信息存储到u[1]、v[1]和w[1]中。同时为这条边赋予一个编号，因为这条边是最先读入的，存储在u、v和w数组下标为1的单元格中，因此编号就是1。

first:这条边的起始点是1号顶点，因此将first[1]的值设为1。

next:另外这条“编号为1的边”是以1号顶点（即u[1]）为起始点的第一条边，所以要将next[1]的值设为-1。
```

![这里写图片描述](https://img-blog.csdn.net/20171009195008800?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTE9JX1E=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



```
u,v,w:读入第2条边（4 3 8），将这条边的信息存储到u[2]、v[2]和w[2]中

first:这条边的编号为2。这条边的起始顶点是4号顶点，因此将first[4]的值设为2

next:另外这条“编号为2的边”是我们发现以4号顶点为起始点的第一条边，所以将next[2]的值设为-1。
```

![这里写图片描述](https://img-blog.csdn.net/20171009195028429?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTE9JX1E=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

```
u,v,w:读入第3条边（1 2 5），将这条边的信息存储到u[3]、v[3]和w[3]中

first:这条边的编号为3，起始顶点是1号顶点。我们发现1号顶点已经有一条“编号为1 的边”了，如果此时将first[1]的值设为3，那“编号为1的边”岂不是就丢失了？

next:解决办法，此时只需将next[3]的值设为1即可，即保存了之前的first[1]到next[3]中
```

![这里写图片描述](https://img-blog.csdn.net/20171009195107523?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTE9JX1E=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



```
u,v,w:读入第4条边（2 4 6），将这条边的信息存储到u[4]、v[4]和w[4]中

first:这条边的编号为4，起始顶点是2号顶点，因此将first[2]的值设为4

next:另外这条“编号为4的边”是我们发现以2号顶点为起始点的第一条边，所以将next[4]的值设为-1。
```

![这里写图片描述](https://img-blog.csdn.net/20171009195127128?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTE9JX1E=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



```
u,v,w:读入第5条边（1 3 7），将这条边的信息存储到u[5]、v[5]和w[5]中

first:这条边的编号为5，起始顶点又是1号顶点，此时需要将first[1]的值设为5

next:next[5]的值改为3
```

![这里写图片描述](https://img-blog.csdn.net/20171009195149809?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTE9JX1E=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



​		利用first和next数组遍历某一顶点的边，1号顶点的其中一条边的编号存储在first[1]中。其余的边则可以通过next数组寻找到。此时遍历边某个顶点边的时候的遍历顺序正好与读入时候的顺序相反。因为在为每个顶点插入边的时候都直接插入“链表”的首部而不是尾部。

![这里写图片描述](https://img-blog.csdn.net/20171009195224603?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTE9JX1E=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)













### 图的遍历

 从图中某一顶点出发，使图中其余顶点都被访问到，且仅被访问一次的方法

 具体方法是通过定义一个数组visited[n],其中：

  n：表示图中顶点的个数

  visited[i]的值，(n>i>=0)

  值为0表示该顶点未被访问过；

  值为1表示该顶点已被访问过；







####   深度优先搜索







####   广度优先搜索







## 拓扑排序

### AOV网

AOV网（Activity On Vertex NetWork）用顶点表示活动，边表示活动（顶点）发生的先后关系。AOV网的边不设权值，若存在边<a,b>则表示活动a必须发生在活动b之前。

若网中所有活动均可以排出先后顺序（任两个活动之间均确定先后顺序），则称网是拓扑有序的，这个顺序称为网上一个全序。(详情参见离散数学/图论相关内容)。

在AOV网上建立全序的过程称为拓扑排序的过程，这个算法并不复杂：

- 在网中选择一个入度为0的顶点输出
- 在图中删除该顶点及所有以该顶点为尾的边
- 重复上述过程，直至所有边均被输出。

若图中无入度为0的点未输出，则图中必有环。

AOV网举例

![image-20200610232539717](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200610232539717.png)



### 拓扑排序

定义		

拓扑序列：拓扑序列是顶点活动网中将活动按发生的先后次序进行的一种排列。拓扑序列能使得AOV网中所有应存在的前驱和后继关系得到满足。

拓扑排序：对一个有向图构造拓扑序列的过程成为拓扑排序。





拓扑排序可以判断是否存在环











## 实战案例

LeetCode总结 -- 图篇

https://blog.csdn.net/qq_44939824/article/details/89743104



### 图的遍历问题

#### 岛屿数量

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

```
输入:
11110
11010
11000
00000
输出: 1

输入:
11000
11000
00100
00011
输出: 3
解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。
```



解题思路

![image-20200610213509484](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200610213509484.png)

解题实现

1）空值，零值判定

2）获取二维数组的长宽，初始化res为0

3）遍历二维数组

​		4）如果为1时，res自增，调用深度搜索函数

```
for(int i=0;i<nr;i++){
	for(int j=0;j<nc;j++){
		res++;
		dfs(grid,i,j);
	}
}
```

5）返回res



深度搜索函数

1)获取二维数组长宽

2）边界判定，注意上边界取不到

```
if(r<0||r>=nr||c<0||c>=nc||grid[r][c]=='0'){
	return;
}
```

3）设置当前位为 "0"

4）对四个方向进行搜索

```
dfs(grid,r+1,c);
dfs(grid,r-1,c);
dfs(grid,r,c+1);
dfs(grid,r,c-1);
```



复杂度分析

![image-20200610214221757](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200610214221757.png)



#### 图中环的判定

深度优先搜索只要在其中记录下搜索的节点数n，当n大于图中节点数时退出，并可以得出有回路

若有回路，则拓扑排序访问不到图中所有的节点，所以也可以得出回路

判断是否有环的方法包括：

1.DFS

2.拓扑排序

3.求最短路径

​		深度搜索，如果向下搜索的时候搜索到前面的节点在，则说明有环，如图，搜索到6，继续搜索会搜到4，而此时4已经被访问过了，说明有环。

![img](http://uploadfiles.nowcoder.com/images/20150814/188677_1439519105925_8A5F006FFD4CE801C8E888EC3BC68361)









### 欧拉路









### Tarjan算法





### 匈牙利算法





### 最大流





### 最小费用最大流







### 最短路径