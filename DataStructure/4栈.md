# 栈

## 概述

### 栈的介绍

- 是一端受限，一端允许进行操作的线性表。即：先放的后取，后放的先取。就是通常说的“先进后出”（FILO）。存储结构最常见的有两种：一种是顺序存储，一种是链式存储。其中顺序存储就是之前讲的数组，链式存储就是之前讲的链表。

  

  ![进栈](https://img-blog.csdnimg.cn/20190523091856164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNDA3NDU5,size_16,color_FFFFFF,t_70)

  ![出栈](https://img-blog.csdnimg.cn/20190523091933894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNDA3NDU5,size_16,color_FFFFFF,t_70)

  


### 使用场景

- 比如，浏览网页中已经访问页面的历史纪录(后退)
- 文档编辑器中的撤销序列
- Android中activity的栈管理，fragment的栈管理


### 常见操作

- 主要操作
  - new（新建），push（入栈），pop（出栈）
- 辅助操作
  - isEmpty，top，size，isStackFull
- 注意要点
  - top，只需要读取栈顶元素的值，而不移除它，这个数据没有出栈，而且只能查看栈顶元素。
- 操作解释
  - 初始化：通常是一个构造器，用于创建一个空栈
  - 返回栈的长度：该方法用于返回栈中数据元素的个数
  - 入栈：向栈的栈顶插入一个数据元素，栈的长度+1
  - 出栈：从栈的栈顶删除一个数据元素，栈的长度-1，该方法通常饭后被删除的元素
  - 访问栈顶元素：返回栈顶的数据元素，但不删除栈顶元素
  - 判断栈是否为空：改方法判断栈是否为空，如果栈为空则返回true,否则返回false.
  - 清空栈：将栈清空



![image-20200319220149127](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200319220149127.png)

异常

- 入栈：如果栈满了，还想继续插入数据，就会报错，理论上，ADT定义的栈是不会满的，但数组实现的栈会满。
- 出栈：栈空时，还想弹出一个数据项，就会报错。

栈的效率

- 数据项入栈和出栈的时间复杂度都为常数O(1),即栈操作所耗费的时间不依赖于栈中数据项的 个数，因此操作时间很短。栈不需要比较和移动操作。





## 实现




### 简单数组实现

简单数组代码实现

首先看一下实现的代码

- 用数组实现栈，最主要的是要在类的内部定义一个数组，并且这个数组要具有一定的大小，要在定义栈的时候定义好。

```java
public class ArrayStack{
    private static final String TAG = "ArrayStack";
    private Object[] contents;
    private int top = -1;
    private int bottom = -1;
    private int SIZE = 10;//有一个初始值大小

    public ArrayStack(){
        contents = new Object[SIZE];
        top = -1;
    }

    public int push(Object obj) throws Exception {
        if (top > SIZE) throw new Exception("小杨逗比，栈已经满了！");
        top++;
        contents[top] = obj;
        return top;
    }

    public Object pop() throws Exception{
        if (top == bottom) throw new Exception("小杨逗比，栈已经空了！");
        Object obj = contents[top];
        contents[top] = null;
        top--;
        return obj;
    }

    public boolean isEmpty(){
        return top == bottom;
    }

    public int getSize(){
        return top + 1;
    }

    public void display() throws Exception{
        if (getSize() == 0) throw new Exception("空栈!");
        for (int i=getSize()-1;i>=0;i--){
            System.out.print(contents[i].toString() + "->");
        }
        System.out.println("");
    }
} 


public void test{
    ArrayStack as = new ArrayStack();
    //as.display();
    as.push("小杨逗比");
    as.push("潇湘剑雨");
    as.push("yc");
    as.push("逗比");
    as.push("aaa");
    as.push("ertte");
    as.push("hello");
    as.display();
    as.pop();
    System.out.println(as.getSize());
    as.pop();
    as.display();
}
```

1.2 可能出现问题

- 可能会出现的问题
  - 当数组栈存满了元素的时候，如果执行插入数据，将会抛出栈满异常。
  - 当数组栈没有元素的时候，如果执行出栈数据，将会抛出栈空异常。

1.3 性能和局限性

- 性能和局限性分析
  - 栈的最大空间必须提前声明，而且关键是大小还不能改变，这就蛋疼了。所以会出现执行入栈或者出栈操作时会出现异常。那么解决异常就是每次入栈判断栈是否存储满，每次出栈判断栈是否为空。
  - 假设栈中有m个元素，基于简单数组实现的栈。栈的出栈，入栈，判空，获取大小等时间复杂度都是O(1)。



### 动态数组实现

基于简单数组存在问题

- 基于简单数组的栈实现方法中，采用一个下标变量top，它始终指向栈中最新插入元素的位置。
- 当插入元素时，会增加top值，并且会在数组该下标的位置存储新的元素。
- 当删除元素时，先获取下标变量top位置的元素，然后减小变量top的值。
- 当top下标变量为-1时，表示栈是空的。但是存在问题是：在固定大小的数组中，如何处理所有空间都已经保存栈元素这种情况？？？



2.2 第一种解决办法

- 可能首先会想到，每次将数组大小增加1或者减小1，将会怎么样？
  - 插入元素，栈的空间大小增加1
  - 删除元素，栈的空间大小减去1
- 这样做存在极大问题
  - 频繁增加数组大小的方法开销很大。为什么这样说呢？
  - 当n=3时，执行push插入元素操作，当插入第四条元素时，会新建一个大小为4的数组，然后复制原数组中所有的元素到新的数组中，然后在新的数组中的末尾添加插入元素。以此类推，每次插入数据，都会重新创建一个新的数组对象，然后拷贝旧的数组数据到新的数组中来，然后在末尾添加新元素，这样做实在不好。



2.3 第二种解决办法

- 在第一种解决办法中改造。比如我们经常听到ArrayList集合动态扩容，先指定数组的长度，如果数组空间已满，则新建一个比原数据大一倍[或者n倍]的新数组，再然后复制元素。
- 采用这种方式，插入元素操作，开销相对来说要小很多。



2.4 动态数组实现栈代码

基于动态数据实现栈的代码如下所示

```java
class DynArrayStack{
    private int top;
    private int capacity;
    private int[] array;
 
    private void doubleStack(){
        int[] newArray=new int[capacity*2];
        System.arraycopy(array,0,newArray,0,capacity);
        capacity=capacity*2;
        array=newArray;
    }
 
    public DynArrayStack(){
        top=-1;
        capacity=1;
        array=new int[capacity];
    }
 
    public boolean isEmpty(){
        return (top==-1);
    }
 
    public boolean isStackFull(){
        return (top==capacity-1);
    }
 
    public void push(int date){
        if(isStackFull()){
            doubleStack();
        }
        array[++top]=date;
    }
 
    public int pop(){
        if(isEmpty()){
            System.out.println("Stack Empty");
            return 0;
        }else {
            return array[top--];
        }
    }
 
    public void deleteStack(){
        top=-1;
    }
}
 
public class Main {
 
    public static void main(String[] args) {
        // write your code here
        DynArrayStack dynArrayStack=new DynArrayStack();
        dynArrayStack.push(1);
        dynArrayStack.push(2);
        dynArrayStack.push(3);
        System.out.println(dynArrayStack.pop());
        System.out.println(dynArrayStack.pop());
        System.out.println(dynArrayStack.pop());
    }
}
```

2.5 性能和局限性

- 性能
  - 假设有n个元素的栈，基于动态数组的栈实现中，关于栈插入数据，取出数据的时间复杂度都是O(1)。
  - 可能导致的性能问题：倍增太多可能导致内存溢出。
- 存在局限性
  - 是用数组实现栈，在定义数组类型的时候，也就规定了存储在栈中的数据类型，那么同一个栈能不能存储不同类型的数据呢？（声明为Object）？
  - 栈需要初始化容量，而且数组实现的栈元素都是连续存储的，那么能不能不初始化容量呢？（改为由链表实现）？



### 链表实现

使用链表的优势

- 栈规模的增加和减小都很简洁，而且每个操作都是常数时间开销，每个操作都要使用额外的空间和时间开销来处理指针。

 链表实现栈代码

入栈的顺序是：1 2 3 4 5，那么保证出栈的顺序是5 4 3 2 1，以此类推让head节点指向栈顶节点保证让其倒序输出。

```java
public class MyStack<T> {
    private T data;
    private MyStack<T> next;
 
    public MyStack(T data, MyStack<T> next) {
        this.data = data;
        this.next = next;
    }
 
    public T getData() {
        return data;
    }
 
    public void setData(T data) {
        this.data = data;
    }
 
    public MyStack<T> getNext() {
        return next;
    }
 
    public void setNext(MyStack<T> next) {
        this.next = next;
    }
}

public class LinkStack<N> {
 
    private MyStack<N> head;
    private MyStack<N> tail;
    private Integer size=0;
 
    public MyStack<N> getHead() {
        return head;
    }
 
    public void setHead(MyStack<N> head) {
        this.head = head;
    }
 
    public MyStack<N> getTail() {
        return tail;
    }
 
    public void setTail(MyStack<N> tail) {
        this.tail = tail;
    }
 
    public Integer getSize() {
        return size;
    }
 
    public void setSize(Integer size) {
        this.size = size;
    }
 
    public void addStack(N data){
        MyStack<N> node = new MyStack<>(data,null);
        if(headIsNull()){
            head = node;
            tail = node;
            size++;
        }else{
            //新加入的node是:(data,null) 让这个新的node的next指向初始的head节点 head变为(data,head))
            node.setNext(head);
            head = node;
            size++;
        }
    }
 
    public N outStack(){
        if(size>0){
            N outData = head.getData();
            head = head.getNext();
            return outData;
        }else{
            throw new RuntimeException("栈里无元素!");
        }
    }
 
    public boolean headIsNull(){
        if(head == null){
            return true;
        }
        return false;
    }
}
```

测试一下

```
public void test() {
    LinkStack<Integer> linkStack = new LinkStack<>();
    linkStack.addStack(1);
    linkStack.addStack(2);
    linkStack.addStack(3);
    linkStack.addStack(4);
    linkStack.addStack(5);

    for(int i=0;i<linkStack.getSize();i++){
        System.out.println(linkStack.outStack());
    }
}
```



3.3 性能和局限性

- 假设栈中有n个元素，基于链表的栈实现中，关于栈插入元素和取出元素的时间复杂度是O(1)
- 数据入栈和出栈的时间复杂度都为O(1)，也就是说栈操作所耗的时间不依赖栈中数据项的个数，因此操作时间很短。而且需要注意的是栈不需要比较和移动操作。















## 解题技巧

### 辅助栈

“以空间换时间”，使用**辅助栈**

辅助栈又分为同步和不同步两种。











### 单调栈（难点）

​		单调栈，顾名思义，是栈内元素保持一定单调性（单调递增或单调递减）的栈。这里的单调递增或递减是指的从 **栈底到栈顶** 单调递增或递减。既然是栈，就满足后进先出的特点。与之相对应的是单调队列。

https://blog.csdn.net/qq_17550379/article/details/86519771

单调栈主要回答这样的几种问题

- 比当前元素更大的下一个元素
- 比当前元素更大的前一个元素
- 比当前元素更小的下一个元素
- 比当前元素更小的前一个元素



解决问题

```
1.最基础的应用就是给定一组数，针对每个数，寻找它和它右边第一个比它大的数之间有多少个数。

2.给定一序列，寻找某一子序列，使得子序列中的最小值乘以子序列的长度最大。

3.给定一序列，寻找某一子序列，使得子序列中的最小值乘以子序列所有元素和最大。
```



栈的存储内容

```
操作数组的下标索引

操作数组的值
```



举例

入栈操作： 1，3，2，4，5，8，6，3

![img](https://img-blog.csdnimg.cn/20190331154043644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlZF9yZWRfcmVk,size_16,color_FFFFFF,t_70)





#### 递减栈 模板 

```java
for(int i=0;i<nums.length;i++){
    ...
	while(!stack.empty()&&nums[i]>stack.peek()){
		...
         stack.pop();
	}
	stack.push(nums[i])
}
```

递减栈指从栈底到栈顶递减，操作逻辑为入栈元素大于栈顶元素，入栈逻辑为入栈元素小于栈顶元素，一般用于判断下一个更大元素问题





## 算法案例

【LeetCode】栈 stack（共40题）（待学习）

https://www.cnblogs.com/zhangwanying/p/9886577.html

#### 括号匹配









#### 括号的分数

给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：

() 得 1 分。
AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。
(A) 得 2 * A 分，其中 A 是平衡括号字符串。

```
输入： "()"
输出： 1
输入： "(())"
输出： 2
输入： "()()"
输出： 2
输入： "(()(()))"
输出： 6
```

解题思路

![image-20200605055710281](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200605055710281.png)

解题实现

1）新建栈，初始压入0

2）遍历字符数组

​		3）如果是左括号，直接压入0

​		4）否则，弹出获取栈的上两位，计算新的最后一位

​			计算规则：w + Math.max(2 * v, 1)，如果v是0，直接压入1+w

```
for(char c:s.toCharArray()){
	if(c=='('){
		stack.push(0);
	}else{
		int v=stack.pop();
		int w=stack.pop();
		stack.push(w+Math.max(v*2,1));
	}
}
```

5）返回 栈的最上位元素



#### 压缩算法

腾讯2020校园招聘

小Q想要给他的朋友发送一个神秘字符串，但是他发现字符串的过于长了，于是小Q发明了一种压缩算法对字符串中重复的部分进行了压缩，对于字符串中连续的m个相同字符串S将会压缩为[m|S](m为一个整数且1<=m<=100)，例如字符串ABCABCABC将会被压缩为[3|ABC]，现在小Q的同学收到了小Q发送过来的字符串，你能帮助他进行解压缩么？

```
HG[3|B[2|CA]]F

HGBCACABCACABCACAF

说明：HG[3|B[2|CA]]F−>HG[3|BCACA]F−>HGBCACABCACABCACAF
```



解题思路

通过两个栈实现，循环次数栈和字符串栈

当获取到 '[' 时，确定字符串栈和循环次数栈压入值，当获取到 ']' 时，从栈中获取元素，循环，并累计到sb中



解题实现

```java
public static String solve(String words) {
        Stack<Integer> num_stack = new Stack<>();  //循环次数栈
        Stack<StringBuilder> str_stack = new Stack<>();  //字符串栈
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < words.length(); ++i) {
            if (words.charAt(i) == '[') {
                int pos = words.indexOf("|", i);
                int count = Integer.valueOf(words.substring(i + 1, pos));
                num_stack.push(count);
                str_stack.push(sb);
                i = pos;
                sb = new StringBuilder();  //重新初始化sb
            } else if (words.charAt(i) == ']') {
                int count = num_stack.pop();
                StringBuilder tmp = str_stack.pop();
                for (int j = 0; j < count; ++j) {
                    tmp.append(sb);
                }
                sb = tmp;  //将tmp先临时给sb
            } else {
                sb.append(words.charAt(i));
            }
        }
        return sb.toString();
    }
```





#### 删除最外层的括号

有效括号字符串为空 ("")、"(" + A + ")" 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，""，"()"，"(())()" 和 "(()(()))" 都是有效的括号字符串。

如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。

给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。

对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200520152233522.png" alt="image-20200520152233522" style="zoom:80%;" />

解题思路

思路：遍历字符串，遇到左括号就入栈，遇到右括号就出栈，每次栈空的时候，都说明找到了一个原语，记录下每个原语的起始位置和结束位置，取原字符串在原语的起始位置+1到原语的结束位置的子串便得到原语删除了最外层括号的字符串，拼接，即可解出答案。

解题实现

1）新建StringBuffer类型返回值和字符栈

2）初始化原语的起始和结束位置为0，原语标志为false

3）遍历字符串

​		4）对字符判断，如果是左括号入栈，原语标志为假，表示遇到的第一个左括号，是原语的开始位置，记录下原语开始位置

```
if(ch=='('){
	stack.push(ch);
	if(!flag){
		start=i;
		flag=true;
	}
}
```

​		5）遇到右括号，出栈

​		6）当栈空的时候，找到了一个完整的原语，记录下结束位置，去掉原语的最外层括号，并追加到答案中，置标志为false，往后接着找下一个原语，往后找，再次初始化原语开始位置

```
if(ch==')'){
	stack.pop();
	if(stack.isEmpty()){
		end=i;
		res.append(S.substring(start+1,end));
		flag=false;
		start=end;
	}
}
```

7）返回







#### 字符串逆序





#### 剑指 Offer -两个栈实现队列

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ）

代码如下所示

```java
class CQueue {
    //注意使用Deque表示栈
    Deque<Integer> stack1;
    Deque<Integer> stack2;
    public CQueue() {
        //注意 new LinkedList
        stack1=new LinkedList<Integer>();
        stack2=new LinkedList<Integer>();
    }
    
    public void appendTail(int value) {
        stack1.push(value);
    }
    
    public int deleteHead() {
        //如果第二个栈为空，装入第二个栈
        if(stack2.isEmpty()){
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
        }
        if(stack2.isEmpty()){
            return -1;
        }else{
            int res=stack2.pop();
            return res;
        }
    }
}
```





#### 美团点评2020校招后台-表达式求值

给出一个布尔表达式的字符串，比如：true or false and false，表达式只包含true，false，and和or，现在要对这个表达式进行布尔求值，计算结果为真时输出true、为假时输出false，不合法的表达时输出error（比如：true true）。表达式求值是注意and 的优先级比 or 要高，比如：true or false and false，等价于 true or (false and false)，计算结果是 true。

```
输入第一行包含布尔表达式字符串s，s只包含true、false、and、or几个单词（不会出现其它的任何单词），且单词之间用空格分隔。 (1 ≤ |s| ≤ 103).
输出true、false或error，true表示布尔表达式计算为真，false表示布尔表达式计算为假，error表示一个不合法的表达式。

in
true or false and false
out
true
```



解题思路

![image-20200706222310174](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200706222310174.png)



解题实现

```java
public class TrueAndFalse {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String[] s = sc.nextLine().split(" ");
        if (s.length == 1) {
            if ("and".equals(s[0]) || "or".equals(s[0])) {
                System.out.println("error");

            } else {
                System.out.println(s[0]);
            }
            return;
        }
        //难点：对格式进行校验
        for (int i = 0; i < s.length; i++) {
            if (i % 2 == 0) {
                if ("and".equals(s[i]) || "or".equals(s[i])) {
                    System.out.println("error");
                    return;
                }
            } else {
                if ("true".equals(s[i]) || "false".equals(s[i])) {
                    System.out.println("error");
                    return;
                }
            }
        }


        String res = solve(s);
        System.out.println(res);

    }

    public static String solve(String[] s) {
        Stack<String> stack = new Stack();
        //难点：正确的使用栈
        for (int i = 0; i < s.length; i++) {
            if ("and".equals(s[i])) {
                String peek = stack.pop();
                String ju1 = judge(s[i], peek, s[i + 1]);
                stack.push(ju1);
                i++;
            } else {
                stack.push(s[i]);
            }
        }
        String res = stack.pop();
        while (!stack.isEmpty()) {
            String temp = stack.pop();
            if ("or".equals(temp)) {
                String val = stack.pop();
                res = judge(temp, val, res);
            } else {
                res = "error";
                break;
            }
        }
        return res;
    }

    public static String judge(String check, String s1, String s2) {
        if ("and".equals(check)) {
            if ("true".equals(s1) && "true".equals(s2)) {
                return "true";
            } else {
                return "false";
            }
        } else if ("or".equals(check)) {
            if ("true".equals(s1) || "true".equals(s2)) {
                return "true";
            } else {
                return "false";
            }
        }
        return "error";
    }

}

```





#### 压入、弹出序列





#### 



#### 使用栈判断字符串是否回文



### 树栈





### 单调栈

#### 每日温度

请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

```
例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
```

解题思路

![image-20200624193515295](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200624193515295.png)

复杂度分析

暴力解法的复杂度为*O*(n*m)

![image-20200624193612479](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200624193612479.png)

解题实现

1）新建结果数组和单调栈

2）套用递减栈模板

3）对栈中剩余元素处理

4）返回

```java
class Solution {
    public  int[] dailyTemperatures(int[] T) {
        int[] res = new int[T.length];
        Stack<Integer> stack = new Stack();

        for (int i = 0; i < T.length; i++) {
            while (!stack.isEmpty() && T[i] > T[stack.peek()]) {
                int temp = stack.pop();
                res[temp] = i - temp;
            }
            stack.push(i);
        }
        while (!stack.isEmpty()) {
            res[stack.pop()] = 0;
        }
        return res;
    }
}
```







#### 下一个更大元素 I

给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。

nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。

```
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。
    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。
    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。
    
    

输入: nums1 = [2,4], nums2 = [1,2,3,4].
输出: [3,-1]
解释:
    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。
    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。
```



解题思路

![image-20200623224409722](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200623224409722.png)

即维持单调栈里为一个单调的序列



解题实现

1）新建栈和映射，返回值数组

2）套用单调递增栈模板

```
for(int i=0;i<nums.length;i++){
	while(!stack.empty()&&nums[i]>stack.peek()){
		map.put(stack.pop(),nums[i]);
	}
	stack.push(nums[i]);
}
```

3）对栈中剩余元素处理

4）构造返回值数组

5）返回



```
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Stack<Integer> stack=new Stack<>();
        Map<Integer,Integer> map=new HashMap<>();
        int[] res=new int[nums1.length];
        for(int i=0;i<nums2.length;i++){
            while(!stack.empty()&&nums2[i]>=stack.peek()){
                map.put(stack.pop(),nums2[i]);
            }
            stack.push(nums2[i]);
        }
        while(!stack.empty()){
            map.put(stack.pop(),-1);
        }
        
        for(int i=0;i<nums1.length;i++){
            res[i]=map.get(nums1[i]);
        }
        return res;

    }
}
```





#### 下一个更大元素 II

给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

```
输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```





解题思路

![image-20200624201654171](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200624201654171.png)

本题的思路要点：一是使用单调栈，二是使用两遍数组必然能找到所有数的右边最大的数。基于这个思路，一般想法都是从0开始向右遍历，但是因为栈的先进后出的原理，会导致积压在栈底部的数得不到正确的对应较大的数。然而从右往左遍历，就能够通过覆盖的方法，获得正确的值。

解题实现

1）新建结果数组，单调栈

2）遍历数组，注意循环数组，两次遍历

3）套用单调减栈模板，注意两次遍历的表示为 i % nums.length

```java
for(int i=2*nums.length-1;i>=0;i--){
	while(!stack.isEmpty()&&nums[i%nums.length]>=nums[stack.peek()]){
		stack.pop();
	}
    //存放当前较之更大的元素
	res[i%nums.length]=stack.isEmpty()?-1：nums[stack.peek()];
	stack.push(i%nums.length());
}
```

4）返回







#### 逛街

腾讯2020

小Q在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很多高楼，共有n座高楼排成一行。  小Q从第一栋一直走到了最后一栋，小Q从来都没有见到这么多的楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？（当前面的楼的高度大于等于后面的楼时，后面的楼将被挡住） 

```
6
5 3 8 3 2 5

3 3 5 4 4 4

当小Q处于位置3时，他可以向前看到位置2,1处的楼，向后看到位置4,6处的楼，加上第3栋楼，共可看到5栋楼。当小Q处于位置4时，他可以向前看到位置3处的楼，向后看到位置5,6处的楼，加上第4栋楼，共可看到4栋楼。
```



解题思路

维护一个 rightLook 保留往右看 可以看得到的楼数量数组

维护一个单调栈 stack中要保存的是 能看见的楼的 index

核心是栈的维护

```
while((!stack.isEmpty())&&(arr[i]>=arr[stack.peek()])){
	stack.pop();
}
```



解题实现

```java
	public static int[] solve(int[] arr) {
        int len = arr.length;
        int[] res = new int[len];
        int[] rightLook = new int[len];  //rightLook 保留往右看 可以看得到的楼数量数组
        Stack<Integer> stack = new Stack<>();  // stack中要保存的是 能看见的楼的 index
        for (int i = len - 1; i >= 0; i--) {
            rightLook[i] = stack.size();
            while ((!stack.isEmpty()) && (arr[i] >= arr[stack.peek()])) {  //while循环是为下一位执行的
                stack.pop();  //如果大于则说明栈中的楼已经看不到了
            }
            stack.push(i); //将当前楼的索引加入栈
        }
        stack.clear();
        for (int i = 0; i < len; i++) {
            int total = rightLook[i] + 1 + stack.size();
            while ((!stack.isEmpty()) && (arr[i] >= arr[stack.peek()])) {
                stack.pop();
            }
            res[i] = total;
            stack.push(i);
        }
        return res;
    }
```







### 计算器

#### 解析计算器数学公式

#### 前缀、中缀、后缀表达式

5.1.1. 定义

前缀表达式，中缀表达式，后缀表达式都是四则运算的表达方式，用以四则运算表达式求值，即数学表达式的求值。

比如一个简单的数学表达式 (1+2)-(3+4) 这是我们常见的数学表达式类型 即中缀表达式

l 把这个表达式转化位前缀表达式（也称波兰式） -+12+34

l 把这个表达式转化位后缀表达式（也称逆波兰式） 12+34+-

为什么要将简单的中缀表达式转化为复杂的波兰式或逆波兰式

原因在于，简单的中缀表达式在用人的思维逻辑来看，确实简单，但在计算机看来中序表达式是非常复杂的结构，而相对而言，（逆）波兰式在计算机看来是非常简单的结构，因为计算机普遍采用的内存结构是栈式结构，而（逆）波兰表达式在其存储和计算上也采用的是栈的特性。

*使用时，对于波兰式和逆波兰式，使用时可随便选择一种，这两者在本质上没有区别，只是表达形式不同而已，下面就逆波兰式来讲解如何计算表达式值及其与中缀表达式的转换的程序实现。*

5.1.3. 中缀表达式转换为后缀表达式算法

A.  建立一个栈，一个队列

B.   从左至右顺序遍历中缀表达式。

C.  遇到操作数时，直接压入队列

D.  遇到运算符时：

a)    当遇到左括号或是栈为空，直接压栈

b)    当遇到右括号时，依次弹栈，直至栈顶是左括号，弹栈结束！期间所有的操作符按顺序入队

c)    当遇到操作符时，若栈顶是左括号，则直接入栈

 若栈顶是操作符，则比较两操作符优先级，若当前字符优先级较高，则压栈，若当前字符优先级小于等于栈顶运算符，则将栈顶运算符弹出并入队，继续与当前栈顶元素比较！直到当前运算符优先级高于栈顶运算符则入栈，或是遇到左括号或是栈为空，亦入栈！

E.   遍历完所有字符后，弹出栈中仍剩有的操作符，并入队

F.   依次出队即可达到相应的后缀表达式！

 

后缀表达式值的计算算法

A.  建立一个栈

B.   从左到右顺序遍历后缀表达式

C.  遇到操作数则直接进栈

D.  遇到操作符，则依次弹出栈顶上的两个元素，对其进行运算，然后将运算结果进栈

E.   重复 B，C，直至遍历完整个表达式，那么栈中将只剩下一个元素，它就是整个表达式的运算结果

前缀表达式在操作上与后缀表达式的几个不同点

l 前缀表达式的所有遍历从右到左的！自然遇到括号的处理方式与后缀表达式是相反的

l 在与中缀表达式的转化时，遇到操作符的处理方式是，与栈顶元素比较，若优先级**大于等于**栈顶运算符，就直接入栈，注意在后缀表达式中是**大于**。



### 综合题

#### 接雨水











