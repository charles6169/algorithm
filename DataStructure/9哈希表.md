# 哈希表

## 概述

### 定义

注意：hashMap的key是随机排序的，不是按照put进去的顺序来的。





注意区分三个概念：哈希算法，哈希表，哈希函数

![image-20200225222048987](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200225222048987.png)





### 分类









#### HashMap

HashMap是Map的实现类

新建哈希表：

```java
Map<String, Integer> Ages = new HashMap<String, Integer>(); 
// 这是用接口的形式实现哈希表
// Key是String类型，Value是Integer类型
```

注：不建议用以下方法新建

```java
HashMap<String, Integer> Ages = new HashMap<String, Integer>();
```

![image-20200227153038201](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200227153038201.png)



#### 有序哈希表LinkedHashMap











#### 自定义哈希表

通过两个链表实现自定义的哈希映射

```java
public class MyHashMap {
    /**
     * Initialize your data structure here.
     * 分别用keys和values存放键和值的信息
     * 其中又各为链表
     */
    List<List<Integer>> keys;
    List<List<Integer>> values;
    int length = 500;//桶的个数 base 基数

    public MyHashMap() {
        keys = new ArrayList<List<Integer>>();
        values = new ArrayList<List<Integer>>();
        for (int i = 0; i < length; i++) {
            keys.add(i, new ArrayList<Integer>());
            values.add(i, new ArrayList<Integer>());
        }
    }

    /**
     * value will always be non-negative.
     * 先判断keys中是否有对应的key：
     * 如果没有，则存入键和值的信息于（key % length）位置
     * 如果有，则先删除原有信息再存入
     */
    public void put(int key, int value) {
        if (!contains(key)) {
//            key % length即为哈希函数计算过程
            keys.get(key % length).add(key);
            values.get(key % length).add(value);
        } else {
            remove(key);
            keys.get(key % length).add(key);
            values.get(key % length).add(value);
        }
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or -1 if this map contains no mapping for the key
     * 先判断keys中是否有对应的key：
     * 如果有，则先从keys的指定位置获取index，即（key % length）位置
     * 再从values中获取值，values.get(key % length).get(index);
     * 如果没有，返回 -1
     */
    public int get(int key) {
        if (contains(key)) {
            int index = keys.get(key % length).indexOf((Integer) key);
            return values.get(key % length).get(index);
        }
        return -1;
    }

    /**
     * Removes the mapping of the specified value key if this map contains a mapping for the key
     * 先判断keys中是否有对应的key：
     * 如果有，则先从keys的指定位置获取index，即（key % length）位置，再删除
     */
    public void remove(int key) {
        if (contains(key)) {
            int index = keys.get(key % length).indexOf((Integer) key);
            keys.get(key % length).remove(index);
            values.get(key % length).remove(index);
        }
    }

//    判断keys中是否有key
    public boolean contains(int key) {
        return keys.get(key % length).contains(key);
    }
}
```















## 算法案例





#### 剑指 Offer 50. 第一个只出现一次的字符

在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

```
s = "abaccdeff"
返回 "b"

s = "" 
返回 " "
```

解题思路

 本题有“哈希表” 和 “有序哈希表” 两种解法。

![image-20200714211513585](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200714211513585.png)

解题实现

1）新建LinkedHashMap

2）遍历字符数组，填充map，遍历map，判断并返回

```java
class Solution {
    public char firstUniqChar(String s) {
        Map<Character, Boolean> map = new LinkedHashMap<>();
        char[] sc = s.toCharArray();
        for(char c : sc)
            dic.put(c, !map.containsKey(c));
        //注意这种遍历方法 第一个Entry大写
        for(Map.Entry<Character, Boolean> d : map.entrySet()){
           if(d.getValue()) return d.getKey(); //都不带s 
        }
        return ' ';
    }
}
```







#### 指 Offer -只出现一次的数字 III

给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。

解题思路

位运算太复杂，推荐使用哈希表法解决



解题实现

```java
public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
        Map<Integer,Boolean> map=new HashMap<>();
        for(int a:array){
            map.put(a,!map.containsKey(a));
        }
        List<Integer> list=new ArrayList<>();
        for(Map.Entry<Integer,Boolean> d:map.entrySet()){
            if(d.getValue()){
                list.add(d.getKey());
            }
        }
        num1[0]=list.get(0);
        num2[0]=list.get(1);
    }
```







#### 猫咪特征问题

字节跳动2019春招

为了提取运动信息，他需要从视频的每一帧提取“猫咪特征”。一个猫咪特征是一个两维的vector<x, y>。如果x_1=x_2 and y_1=y_2，那么这俩是同一个特征。

​    因此，如果喵咪特征连续一致，可以认为喵咪在运动。也就是说，如果特征<a, b>在持续帧里出现，那么它将构成特征运动。比如，特征<a, b>在第2/3/4/7/8帧出现，那么该特征将形成两个特征运动2-3-4 和7-8。

现在，给定每一帧的特征，特征的数量可能不一样。小明期望能找到最长的特征运动。

```
1
8
2 1 1 2 2
2 1 1 1 4
2 1 1 2 2
2 2 2 1 4
0
0
1 1 1
1 1 1
```

```
3
```



解题思路

使用map记录动作上一次出现的帧数和当前连续帧数，同时记录下当前连续的最长帧数res。


  第一组数：（1，1）-> (0，1)  ,  (2，2) -> (0，1)   res = 1; 

  即代表(1,1)上次出现在0时刻，当前连续动作为1；(2,2)上次出现在0时刻，当前连续动作为1


  第二组数：（1，1）-> (1，2)  ,  (1，4) -> (1，1)   res = 2;  

   即代表(1,1)上次出现在1时刻，当前连续动作为2；(1,4)上次出现在1时刻，当前连续动作为1   

  第三组数：（1，1）-> (2，3)  ,  (2，2) -> (2，1)   res = 3;  

   即代表(1,1)上次出现在2时刻，当前连续动作为3；(2,2)上次出现在2时刻，当前连续动作为1  

​      第四组数：（2，2）-> (3，2)  ,  (1，4) -> (3，1)   res = 3;

两个map轻松解决，一个用来保存当前帧的特征，一个用来保存上一帧的特征。



```java

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int size = scanner.nextInt();
        int num = scanner.nextInt();
        HashMap<String, Integer> last = new HashMap<>();
        HashMap<String, Integer> current = new HashMap<>();
        int max=0;
        for (int i = 0; i < num; i++) {
            int pairNum = scanner.nextInt();
            for (int j = 0; j < pairNum; j++) {
                String key= scanner.nextInt()+"_"+scanner.nextInt();
                if (last.get(key)==null){
                    current.put(key,1);
                }else {
                    current.put(key,last.get(key)+1);
                }
            }
            for (Integer value : current.values()) {
                max=Math.max(value,max);
            }
            last=current;
            current=new HashMap<>();
        }
        System.out.println(max);
    }
}
```







### 符号表

**概述**

符号表是一种存储键值对key-value的数据结构，支持两种操作：插入（put），即将一组新的键值对存入表中；查找（get），即根据给定的键得到相应的值。

符号表分为有序和无序两种，有序符号表主要指支持 min()、max() 等根据键的大小关系来实现的操作。有序符号表的键需要实现 Comparable 接口。



**实现**

链表实现无序符号表





二分查找实现有序符号表









#### 用户喜好

为了不断优化推荐效果，今日头条每天要存储和处理海量数据。假设有这样一种场景：我们对用户按照它们的注册时间先后来标号，对于一类文章，每个用户都有不同的喜好值，我们会想知道某一段时间内注册的用户（标号相连的一批用户）中，有多少用户对这类文章喜好值为k。因为一些特殊的原因，不会出现一个查询的用户区间完全覆盖另一个查询的用户区间(不存在L1<=L2<=R2<=R1)。

输入： 第1行为n代表用户的个数 第2行为n个整数，第i个代表用户标号为i的用户对某类文章的喜好度 第3行为一个正整数q代表查询的组数  第4行到第（3+q）行，每行包含3个整数l,r,k代表一组查询，即标号为l<=i<=r的用户中对这类文章喜好值为k的用户的个数。 数据范围n <= 300000,q<=300000 k是整型

```
5
1 2 3 3 5
3
1 2 1
2 4 5
3 5 3

out
1
0
2

样例解释:
有5个用户，喜好值为分别为1、2、3、3、5，
第一组询问对于标号[1,2]的用户喜好值为1的用户的个数是1
第二组询问对于标号[2,4]的用户喜好值为5的用户的个数是0
第三组询问对于标号[3,5]的用户喜好值为3的用户的个数是2
```



解题思路

符号表应用，把喜好值作为key，对应该喜好值的人的集合作为value
比如查询5的时候，直接找到所有喜好值为5的人的集合，遍历集合中哪些人在范围内。

由于符号表的核心也就是键值对，因此用map便可以模拟符号表

```java
链接：https://www.nowcoder.com/questionTerminal/66b68750cf63406ca1db25d4ad6febbf?f=discussion
来源：牛客网

public class Main {
    public static void main(String[] args) {
        Scanner scan=new Scanner(System.in);
        int n=scan.nextInt();
        int[] fav=new int[n];
        for(int i=0;i<n;i++){
            fav[i]=scan.nextInt();
        }
        //定义符号表
        Map<Integer,List<Integer>> map=new HashMap<>();
        for(int i=0;i<n;i++){
            int key=fav[i];
            int value=i+1;
            if(!map.containsKey(key)){
                List<Integer> list=new LinkedList<>();
                list.add(value);
                map.put(key,list);
            }else{
                List<Integer> list=map.get(key);
                list.add(value);
            }
        }
        int m=scan.nextInt();
        Queue<Integer> queue=new LinkedList<>();
        for(int i=0;i<m;i++){
            int lo=scan.nextInt();
            int hi=scan.nextInt();
            int des=scan.nextInt();
            List<Integer> list=map.get(des);
            int count=0;
            if(list!=null){
                for(Integer integer:list){
                    if(integer>=lo&&integer<=hi){
                        count++;
                    }
                }
            }
 
            queue.add(count);
 
        }
        for(Integer integer:queue){
            System.out.println(integer);
        }
 
    }
```

