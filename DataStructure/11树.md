# 树

## 概述

树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。

二叉树有以下几个性质：TODO(上标和下标)
 性质1：二叉树第i层上的结点数目最多为 2{i-1} (i≥1)。
 性质2：深度为k的二叉树至多有2{k}-1个结点(k≥1)。
 性质3：包含n个结点的二叉树的高度至少为log2 (n+1)。
 性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1。

### 二叉树遍历算法













#### 莫里斯遍历

https://www.jianshu.com/p/81fcd475a37b







###  二叉树与数组和链表

二叉树可以使用两种存储结构：顺序存储和二叉链表。

二叉链表：

​		 通过观察上面的二叉链表，存在着若干个没有指向的空指针域。对于一个有n个节点的二叉链表，每个节点有指向左右节点的2个指针域，整个二叉链表存在2n个指针域。而n个节点的二叉链表有n-1条分支线，那么空指针域的个数=2n-(n-1) = n+1个空指针域，从存储空间的角度来看，这n+1个空指针域浪费了内存资源。 
​    	从另外一个角度来分析，如果我们想知道按中序方式遍历二叉链表时B节点的前驱节点或者后继节点时，必须要按中序方式遍历二叉链表才能够知道结果，每次需要结果时都需要进行一次遍历，是否可以考虑提前存储这种前驱和后继的关系来提高时间效率呢？ 
   	综合以上两方面的分析，可以通过充分利用二叉链表中的空指针域，存放节点在某种遍历方式下的前驱和后继节点的指针。**我们把这种指向前驱和后继的指针成为线索，加上线索的二叉链表成为线索链表，对应的二叉树就成为****“****线索二叉树****(Threaded Binary Tree)”** 。

### 二叉树的拓展

二叉搜索树(BST)

​	又称二叉查找树、二叉排序树、二叉检索树

定义

![image-20200304002246635](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200304002246635.png)

示例

![image-20200304002323248](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200304002323248.png)

极端情况：

1）完全二叉树

2）每一层只有一个节点的二叉树

![image-20200304002423415](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200304002423415.png)

![image-20200310224053762](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200310224053762.png)







线索二叉树

在使用二叉链表的存储结构的过程中，会存在大量的空指针域，为了充分利用这些空指针域，引申出了“线索二叉树”。



赫夫曼树

赫夫曼树，别名“哈夫曼树”、“最优树”以及“最优[二叉树](http://c.biancheng.net/view/3384.html)”。 当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。





字典二叉树



线段二叉树





## 算法案例



### 树的遍历

![image-20200310223758383](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200310223758383.png)



分别掌握四种遍历方式的递归和非递归写法

下图中按照不同的方法遍历对应子树，得到的遍历顺序都是 1-2-3-4-5。根据不同子树结构比较不同遍历方法的特点。

![image-20200310224011178](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200310224011178.png)



测试样例：

![这里写图片描述](https://img-blog.csdn.net/2018030323375236?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDI5MTQ5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​		前序：A -> B -> C -> D -> E -> F -> G -> H -> K

​		中序：B -> D -> C -> A -> E -> H -> G -> K -> F

​		后序：D -> C -> B -> H -> K -> G -> F -> E -> A





**递归遍历的通用模板**

核心：取决于根与左右的遍历关系，技巧：

​		前序，中序，后序三者都是可以分为递归方法和非递归（栈）方法实现。

**基于递归方法**

​		其中递归方法主要是通过改变根，左，右三个节点的遍历顺序实现的。先序： 根左右；中序：左根右；后序：左右根

访问根节点

```java
res.add(root.val);
```

遍历左子树

```java
if (root.left != null) {
	helperPre(root.left, res);
}
```

遍历右子树

```java
if (root.right != null) {
	helperPre(root.right, res);
}
```



#### 递归前序遍历

```java
public List<Integer> preOrder(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    recur(root, res);
    return res;
}

public void recur(TreeNode root, List<Integer> res) {
    if (root != null) {
        res.add(root.val);
        if (root.left != null) {
            recur(root.left, res);
        }
        if (root.right != null) {
            recur(root.right, res);
        }
    }
}
```





#### 递归中序遍历

```java
public List<Integer> preOrder(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    recur(root, res);
    return res;
}

public void recur(TreeNode root, List<Integer> res) {
    if (root != null) {
        if (root.left != null) {
            recur(root.left, res);
        }
        res.add(root.val);
        if (root.right != null) {
            recur(root.right, res);
        }
    }
}
```





#### 递归后序遍历

```java
public List<Integer> preOrder(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    recur(root, res);
    return res;
}

public void recur(TreeNode root, List<Integer> res) {
    if (root != null) {
        if (root.left != null) {
            recur(root.left, res);
        }
        if (root.right != null) {
            recur(root.right, res);
        }
        res.add(root.val);
    }
}
```



**非递归遍历的通用模板**

递归的本质就是压栈，了解递归本质后就完全可以按照递归的思路来迭代。
怎么压，压什么？压的当然是待执行的内容，后面的语句先进栈，所以进栈顺序就决定了前中后序。

![image-20200608063953308](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200608063953308.png)

三大遍历的非递归模板，以不变应万变

在压入栈时按照读取的顺序反向压入，如前序遍历中，根左右则压入的顺序为右左根

#### 非递归前序遍历  

根左右

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();  //保存结果
        Stack<TreeNode> stack = new Stack<>();   //调用栈
        if (root == null){
			return res;
        }
      	
        stack.push(root);    //先将根结点入栈
        while (!stack.isEmpty()) {
            TreeNode t = stack.pop();   //弹出结点并判断是否访问过
            //非空说明没访问过，然后右结点入栈，左结点入栈，最后根节点入栈，并入栈一个空结点
            //表明当前结点以访问过
            if (t != null) {   
                if (t.right != null) stack.push(t.right);  
                if (t.left != null) stack.push(t.left); 
                stack.push(t);  
                stack.push(null); 
                //注意压入null
            } else {  
                res.add(stack.pop().val);    //如果弹出结点为空结点，表明当前栈顶结点已访问过
            }
        }
        
        return res;
    }
}
```





#### 非递归中序遍历

左根右，压入顺序：右根左

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();  //保存结果
        Stack<TreeNode> stack = new Stack<>();   //调用栈
        if (root == null) {
			return res;
        }
        stack.push(root);    //先将根结点入栈
        while (!stack.isEmpty()) {
            TreeNode t = stack.pop();   
            if (t != null) {   
                if (t.right != null) stack.push(t.right);  
                stack.push(t);  //在左结点之前重新插入该结点，以便在左结点之后处理（访问值）
                stack.push(null); //空结点随之入栈，标识已经访问过，但还没有被处理（还可以进行额外操作）
                if (t.left != null) stack.push(t.left); 
            } else {  
                res.add(stack.pop().val);   
            }
        }
        return res;
    }
}
```





#### 非递归后序遍历

左右根  压入顺序：根右左

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();  //保存结果
        Stack<TreeNode> stack = new Stack<>();   //调用栈
        if (root == null) {
			return res;
        }
        stack.push(root);    //先将根结点入栈
        while (!stack.isEmpty()) {
            TreeNode t = stack.pop();   
            if (t != null) {   
                stack.push(t);   //完全模拟递归，真的是秒杀全场
                stack.push(null);    //！完美
                if (t.right != null) stack.push(t.right);  
                if (t.left != null) stack.push(t.left); 
            } else {  
                res.add(stack.pop().val);   
            }
        }
        return res;
    }
}
```





####  层次遍历（经典）

​		从上到下，同一层从左到右（难点），基于DFS实现，常用在需要对树的结构进行分析时

1）主函数新建返回值链表，对树判空，调用DFS

​		2）DFS传参第二参数为层数，初始值0

```java
dfs(TreeNode root,int level,List<List<Integer>> res)
```

​		2）终止条件为树空

​		3）当链表的大小小于层数，在该层新建一个链表

```java
if(res.size()<level){
	res.add(level,new ArrayList<>());
}
```

​		4）把当前层的值加到当前层的链表中

```java
res.get(level).add(root.val);
```

​		5）分别对左右节点递归，并且层数加1

```java
dfs(root.left,level+1,res);
dfs(root.right,level+1,res);
```

原代码

```java
    //    层次遍历
    public List<List<Integer>> leverOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        dfs(root, 0, res);

        return res;
    }

    public void dfs(TreeNode root, int level, List<List<Integer>> res) {
        if (root == null) {
            return;
        }
        if (res.size() <= level) {
            res.add(level, new ArrayList<Integer>());
        }
        res.get(level).add(root.val);
        dfs(root.left, level + 1, res);
        dfs(root.right, level + 1, res);
    }
```





####  N叉树的前序遍历

给定一个 N 叉树，返回其节点值的前序遍历。

解题思路

和一般前序遍历类似，不过要依次遍历节点

```java
	List<Integer> res = new ArrayList<Integer>();
    public List<Integer> preorder(Node root) {
        recur(root);
        return res;
    }
    public void recur(Node root) {
        if(root == null) {
            return;
        }
        res.add(root.val);
        int s = root.children.size();
        for(int i = 0; i < s; i++) {
            recur(root.children.get(i));
        }
    }

```



#### N叉树的后序遍历

给定一个 N 叉树，返回其节点值的*后序遍历*。

```java
	List<Integer> res = new ArrayList<Integer>();
    public List<Integer> postorder(Node root) {
        recur(root);
        return res;
    }
    public void recur(Node root) {
        if(root == null) {
            return;
        }
        int s = root.children.size();
        for(int i = 0; i < s; i++) {
            recur(root.children.get(i));
        }
        res.add(root.val);
    }

```



N叉树先序和后序之间的唯一区别是统计节点的顺序



#### N叉树的层序遍历

给定一个 N 叉树，返回其节点值的*层序遍历*。 (即从左到右，逐层遍历)。

要点在于对N叉树的每个孩子节点进行遍历递归

```java
public List<List<Integer>> levelOrderN(Node root) {
        List<List<Integer>> res=new ArrayList<>();
        if(root==null){
            return res;
        }
        recur(root,0,res);
        return res;
    }
    public void recur(Node node,int level,List<List<Integer>> res){
        if(res.size()<=level){
            res.add(new ArrayList<>());
        }
        res.get(level).add(node.val);
        if(node.children!=null){
            for(int i=0;i<node.children.size();i++){
                recur(node.children.get(i),level+1,res);
            }
        }
    }
```





#### 二叉树的锯齿形层次遍历

给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：
给定二叉树 [3,9,20,null,null,15,7],

```
    3
   / \
  9  20
    /  \
   15   7
 [
  [3],
  [20,9],
  [15,7]
]
```



解题思路

直接做层次遍历，再奇数层反转列表



解题实现

```java
public static List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        recur(root, 0, res);
        for (int i = 0; i < res.size(); i++) {
            if (i % 2 == 1) {
                Collections.reverse(res.get(i));
            }
        }
        return res;
    }

    public static void recur(TreeNode root, int level, List<List<Integer>> res) {
        if (root == null) {
            return;
        }
        if (res.size() <= level) {
            res.add(level, new ArrayList<>());
        }
        res.get(level).add(root.val);
        recur(root.left, level + 1, res);
        recur(root.right, level + 1, res);
    }		
```



#### 重建二叉树

通过前序和中序重建二叉树

​		输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

解题思路

通过前序和中序重建二叉树，明确锚点，采用分而治之的方法，将问题缩小化



解题实现

1）判断前序列表，为空或长度为0时直接返回

```java
if (preorder == null || preorder.length == 0) {
	return null;
}
```

2）创建中序映射，并且将中序列表存入映射

```java
Map<Integer, Integer> indexMap = new HashMap<Integer, Integer>();
int length = preorder.length;
for (int i = 0; i < length; i++) {
	indexMap.put(inorder[i], i);
}
```

3）递归，参数为前序列表，前序首锚，前序尾锚，中序列表，中序首锚，中序尾锚，中序映射

```java
TreeNode root = buildTree(preorder, 0, length - 1, inorder, 0, length - 1, indexMap);
```



递归函数

终止条件，两个终止条件要注意

4）前序首锚大于前序尾锚，直接返回

```java
if (preorderStart > preorderEnd) {
    return null;
}
```

单级功能

5）获得前序首值，新建树节点

```java
int rootVal = preorder[preorderStart];
TreeNode root = new TreeNode(rootVal);
```

终止条件

6）前序首锚等于前序尾锚，返回

```java
if (preorderStart == preorderEnd) {
	return root;
}
```

单级功能

7）否则获取中序断点，计算左右节点数

```java
int rootIndex = indexMap.get(rootVal);
int leftNodes = rootIndex - inorderStart, rightNodes = inorderEnd - rootIndex;
```

8）分别左右树节点递归，对应赋值并返回树

```java
root.left = buildTree(preorder, preorderStart + 1, preorderStart + leftNodes, inorder, inorderStart, rootIndex - 1, indexMap);
root.right = buildTree(preorder, preorderEnd - rightNodes + 1, preorderEnd, inorder, rootIndex + 1, inorderEnd, indexMap);
```

9）返回root





#### 从中序与后序遍历序列构造二叉树

根据一棵树的中序遍历与后序遍历构造二叉树。

**注意:**
你可以假设树中没有重复的元素。

```
中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]

    3
   / \
  9  20
    /  \
   15   7
```



解题思路

中序数组建立Map，后序数组寻找根节点，确定两个数组的左右递归区间，充分利用分治思想解题



解题实现

```java
class Solution {
    public  TreeNode buildTree(int[] inorder, int[] postorder) {
        Map<Integer, Integer> inMap = new HashMap<>();
        int inLen = inorder.length;
        int postLen = postorder.length;
        for (int i = 0; i < inLen; i++) {
            inMap.put(inorder[i], i);
        }

        TreeNode res=recur(0, inLen - 1, inorder, 0, postLen - 1, postorder, inMap);

        return res;
    }

    public  TreeNode recur(int inStart, int inEnd, int[] inorder,
                          int postStart, int postEnd, int[] postorder, Map<Integer, Integer> inMap) {
        if (inStart > inEnd) {
            return null;
        }
        int node = postorder[postEnd];
        TreeNode root = new TreeNode(node);
        if(inStart==inEnd){
            return root;
        }
        int index = inMap.get(node);
        int leftNodes = index - inStart;
        int rightNodes = inEnd - index;

        root.left = recur(inStart, index - 1, inorder, postStart, postStart + leftNodes - 1, postorder, inMap);
        root.right = recur(index + 1, inEnd, inorder, postStart + leftNodes, postStart + leftNodes + rightNodes - 1, postorder, inMap);

        return root;
    }

}
```







### 两树问题

#### 两颗二叉树镜像或相等

​		判断两颗树是否对称或镜像，均为空时返回真，任意一棵树先为空返回假，判断目标位置值是否相等，分别对两边子树进行递归，镜像时，左右翻转，相等时，左右对应。

**解题思路**

终止条件：

1）左右均为空，返回真

```java
if(root1==null&&root2==null) return true;
```

2）一个为空，另一个不为空，返回假

```java
if(root1==null||root2==null) return false;
```

返回值：

3）三个逻辑判断，当前值是否相等左右子树反转判断。

```java
return(root1.val==root2.val)
    &&isMirror(root1.left,root2.right)
    &&isMirror(root1.right,root2.left);
```



##### 变体：相等二叉树

​	判断两颗树是否相等，判断逻辑一致，第三步逻辑判断为，左右子树对应递归

```java
return(root1.val==root2.val)
	&&Mirror(root1.left,root2.left)
	&&Mirror(root1.right,root2.right);
```



##### 变体：对称二叉树

​	判断一颗树是否对称，代码与两颗二叉树镜像时情况一样，只是在递归传入时，左右子树均为自己。

```
check(root,root);
```

```
return(root1.val==root2.val)
	&&check(root1.left,root2.right)
	&&check(root1.right,root2.left);
```







#### 翻转（镜像）一颗二叉树

对左右节点递归，每次交换左右节点，翻转二叉树和镜像二叉树是一个概念，代码一样

**解题思路**

终止条件

1）递归函数的终止条件，节点为空时返回

```java
if(root==null) {
    return null;
}
```

单级功能

2）将当前节点的左右子树交换

```java
TreeNode tmp = root.right;
root.right = root.left;
root.left = tmp;
```

返回值

3）递归交换当前节点的 左子树 右子树

```java
Mirror(root.left);
Mirror(root.right);
```





#### 判断一颗二叉树对称或镜像

​		判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

解题思路

回溯法

![image-20200413032744248](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200413032744248.png)

实现步骤

1）判断树是否为空，为空则直接返回true，否则，对这颗树的左右子树调用递归函数

2）接下来的代码就和判断两棵树镜像一致。



#### 剑指 Offer 27. 二叉树的镜像

输入一个二叉树，该函数输出它的镜像。



解题思路

本题的解法有：递归 / 辅助栈

推荐使用递归方法

![image-20200724173354435](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200724173354435.png)

辅助栈

![image-20200724173412372](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200724173412372.png)



解题实现

递归

```java
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        //树空判断
        if(root == null) return null;
        //借助递归交换，很像交换两个数字，交换的左右顺序无关
        TreeNode tmp = root.left;
        root.left = mirrorTree(root.right);
        //注意：对temp也要递归
        root.right = mirrorTree(tmp);
        return root;
    }
}
```





#### 另一个树的子树

给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

```
     3
    / \
   4   5
  / \
 1   2
 
   4 
  / \
 1   2
 
 true
```



解题思路

看到题目描述，首先判断一个树是否是另一棵树的子树，很明显想到可以用递归，但是两棵树完全相同也可以看做一棵树是另一棵树的子树。
所以自然而然想到用一个判断两棵树是否相同的递归函数。

本题为两次递归，母函数本身就是递归函数，子函数再次递归



解题实现

1）终止条件：若t为null，一定为真，如果s为null，一定为假

2）返回值：对s的左右节点和 t 递归，调用树相等判断函数，或连接

```
return isSubTree(s.left,t)||isSubTree(s.right,t)||isSameTree(s,t);
```

树相等判断函数

1）终止条件，s,t均为null时，返回真；

​	s,t有一个为假时，返回假；

​	如果s的值不等于t的值，返回假

2）返回值：对 s和t的左节点，右节点递归

```
return isSameTree(s.left,t.left)&&isSameTree(s.right,t,right);
```







```
int count = 0;
    public int numTilePossibilities(String tiles) {
        //求组合排列数
        char[] chs = tiles.toCharArray();
        Arrays.sort(chs);

        dfs(chs, 0, new boolean[chs.length]);
        return count;
    }

    //全排列
    private void dfs(char[] chs, int n, boolean[] visited){
        int len = chs.length;
        //n 表示添加了 n 个，如果全部添加完成，那么次数 + 1
        if(n == len){
            return;
        }

        for(int i = 0; i < len; i++){
            if(!visited[i]){
                if(i > 0 && chs[i] == chs[i - 1] && !visited[i - 1]){
                    continue;
                }
				/*
				边遍历递归，边计算组合数，每次新添加一个元素，都是一种新的组合方法
				
				比如 AAB，那么我们第一个添加的是 第一个 A，递归过程中就将 后面的能跟 A 组合的都遍历过了，并且每添加一个元素 count++ ，即组合数 + 1
				那么对于第二个 A，我们无需第一个就去添加它了，因为前面的 A 已经将所有组合情况都组合过了，达到去重的效果
				*/
                count++;
                visited[i] = true;
                dfs(chs, n + 1, visited);
                visited[i] = false;
            }
        }
    }
```





### 二叉树操作与性质

#### 平衡二叉树

​		给定一个二叉树，判断它是否是高度平衡的二叉树，一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过1。

**解题思路**

终止条件

1）终止条件，树为空

```java
if (root == null) {
	return true;
}	
```

返回值

2）判断左右子树的高度差是否小于2，并左右子树递归

```java
return Math.abs(height(root.left) - height(root.right)) < 2
    && isBalanced(root.left)
    && isBalanced(root.right);
```



#### 合并二叉树

​		给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

​		你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

![image-20200409154945707](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200409154945707.png)



**解题思路**

这张图

终止条件

1）分别对两颗树判空，如果一颗树为空，返回另一颗树

```java
if(root1==null){
	return root2;
}
if(root2==null){
	return root1;
}
```

单级功能

2）把第二颗树加到第一颗树上

```java
root1.val+=root2.val;
```

返回值

3）左右递归，并返回到第一颗树上

```
root1.left=mergeTree(root1.left,root2.left);
root1.right=mergeTree(root1.right,root2.right)
```





#### 验证二叉树

​       二叉树上有 n 个节点，按从 0 到 n - 1 编号，其中节点 i 的两个子节点分别是 leftChild[i] 和 rightChild[i]。只有 所有 节点能够形成且 只 形成 一颗 有效的二叉树时，返回 true；否则返回 false。如果节点 i 没有左子节点，那么 leftChild[i] 就等于 -1。右子节点也符合该规则。

注意：节点没有值，本问题中仅仅使用节点编号。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200414163712951.png" alt="image-20200414163712951" style="zoom:67%;" />

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200414163729832.png" alt="image-20200414163729832" style="zoom:67%;" />

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200414163812762.png" alt="image-20200414163812762" style="zoom:67%;" />









#### 输出二叉树



解题思路

![image-20200608043103960](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200608043103960.png)



解题实现

1）获取二叉树的高度

2）新建二维数组，尺寸为 height × ( 2 ^ height - 1 ) ，注意可用位运算得到

```
String[][] arr=new String[height][(1<<height)-1];
```

3）数组填充  ” “

4）新建返回值列表

5）调用递归函数

```
recur(arr,root,0,0,arr[0].length);
```

6）将二维数组转为返回值列表形式

```
for(Stringp[] arr1:arr){
	res.add(Arrays.asList(arr1));
}
```

7）返回



递归函数

1）如果树节点为空，直接返回

2）存放节点位置为  [ i ] [ (l + r) / 2 ]

```
arr[i][(l+r)/2]=""+root.val;
```

3）调用递归，注意

左子树为 arr, root.left, i + 1, l, (l + r) / 2

右子树为 arr, root.right, i + 1, (l + r + 1) / 2, r

```
recur(arr,root.left,i+1,l,(l+r)/2);
recur(arr,root.right,i+1,(l+r+1)/2,r);
```

树深度获取函数





#### 单值二叉树

如果二叉树每个节点都具有相同的值，那么该二叉树就是*单值*二叉树。

只有给定的树是单值二叉树时，才返回 `true`；否则返回 `false`

**解题思路**

1）获取这颗树的所有值，任何一种遍历

2）遍历所有值，判断是否等于第一个值即可



#### 最大二叉树

给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

二叉树的根是数组中的最大元素。
左子树是通过数组中最大值左边部分构造出的最大二叉树。
右子树是通过数组中最大值右边部分构造出的最大二叉树。
通过给定的数组构建最大二叉树，并且输出这个树的根节点。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200512123343962.png" alt="image-20200512123343962" style="zoom:80%;" />



解题思路

![image-20200512123407244](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200512123407244.png)

解题实现

1）调用递归函数，传入数组，左起点索引和右终点索引，直接返回树

​		递归函数

​		2）终止条件：当左右索引相同时返回空

​		3）通过自定义函数获取一个区间内数组的最大值

​		4）将这个最大值创建为树节点

​		5）分别对左右区间调用递归函数，返回值为数节点的左右子节点

```
root.left=recur(nums,l,max_i);
root.right=recur(nums,max_i+1,r);
```

​		6）返回值：返回root

​		最大值函数

​		1）初始化临时索引为1

​		2）变量判断如果临时索引对应的临时变量小于当前索引的变量，替换临时索引

​		3）返回临时索引









#### 序列化二叉树

请实现两个函数，分别用来序列化和反序列化二叉树。

二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。

二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。











#### 剑指offer-二叉树的下一个结点

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。



解题思路

首先知道中序遍历的规则是：左根右

![img](https://uploadfiles.nowcoder.com/files/20171225/773262_1514198075109_20151104234034251)

逻辑

![image-20200713213815558](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200713213815558.png)



解题实现

1）树空判断

2）如果有右子树，则找右子树的最左节点

3）没右子树，则找第一个当前节点是父节点左孩子的节点

4）退到了根节点仍没找到，则返回null

```java
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode) {
        if (pNode == null)
            return pNode;
        if (pNode.right != null) { // 节点有右子树
            pNode = pNode.right;
            while (pNode.left != null) {
                pNode = pNode.left;
            }
            return pNode;
        } else if ( pNode.next != null && pNode.next.left == pNode) { // 节点无右子树且该节点为父节点的左子节点
            return pNode.next;
        } else if (pNode.next != null && pNode.next .right == pNode) { // 节点无右子树且该节点为父节点的右子节点
            while(pNode.next != null && pNode .next .left != pNode){
                pNode = pNode.next ;
            }
            return pNode.next ;
        }else{
            return pNode.next ;//节点无父节点 ，即节点为根节点
        }
    }
}
```







#### 剑指 Offer-从上往下打印二叉树

从上往下打印出二叉树的每个节点，同层节点从左至右打印。

解题思路

层次遍历实现，见前面。

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> list=new ArrayList<>();
        if(root==null){
            return list;
        }
        recur(root,0,list);
        for(int i=0;i<list.size();i++){
            if(i%2==1){
                Collections.reverse(list.get(i));
            }
        }
        return list;
        
    }

    public void recur(TreeNode root,int level,List<List<Integer>> list){
        if(root==null){
            return;
        }
        if(list.size()<=level){
            list.add(level,new ArrayList());
        }
        list.get(level).add(root.val);
        recur(root.left,level+1,list);
        recur(root.right,level+1,list);
    }
}
```





#### 二叉树的坡度

给定一个二叉树，计算整个树的坡度。

一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。

整个树的坡度就是其所有节点的坡度之和。

![image-20200409174842193](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200409174842193.png)

**解题思路**

​		用递归函数 traverse，在任何结点调用该函数，都会返回当前结点下面（包括其自身）的结点和。借助于任何结点的左右子结点的这一和值，我们可以直接获得该结点所对应的坡度。



1）主函数直接调用递归函数

2）递归函数：判断节点为空，返回0

3）分别对左右节点递归，计算出左右节点下的总值

```java
int left=helper(root.left);
int right=helper(root.right);
```

4）计算坡度

```java
tilt=Math.abs(left-right);
```

5）返回值为 左右节点值与当前值

```java
return left+right+root.val;
```



#### 剑指 Offer-二叉树的深度（必记）

​		递归获取二叉树的深度

解题思想

```java
class Solution {
    public int maxDepth(TreeNode root) {
        //对左右节点递归计算深度，判断去较大值，并加1
        return root==null?0:1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}
```



#### N叉树的最大深度

给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

解题思路

递归终止条件：root==null时，返回0
每层递归需要做的事情：分别求出当前节点子节点的最大深度，然后求出其最大值，最大值+1即为最大深度

解题实现

1）空值讨论，初始化返回值

2）遍历根节点的所有孩子，对其递归，得到深度

3）将得到的深度更新返回值

```
for(Node n:node.children){
	int depth=maxDepth(node);
	res=Math.max(res,depth);
}
```

4）返回 res+1





#### 二叉树的最小深度

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

```
  	3
   / \
  9  20
    /  \
   15   7
```



解题实现

1）两个终止条件，如果树为空时，返回0，如果树的左右节点均为null，返回1

2）如果左节点或者右节点为空，返回右节点和左节点的递归，并加1

```
if(root.left==null){
	return minDepth(root.right)+1;
}
if(root.right==null){
	return minDepth(root.left)+1;
}
```

3）返回左节点，右节点的较小值加1

```
return 1+Math.min(minDepth(root.left),minDepth(root.right));
```







#### 二叉树最大宽度

给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。

每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200512144919415.png" alt="image-20200512144919415" style="zoom:80%;" />

解题思路

![image-20200512144942341](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200512144942341.png)

![image-20200512144953183](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200512144953183.png)

解题实现

1）初始化全局变量：初始化返回值为0和 左端元素位置 映射HashMap

2）调用深度搜索函数，传入参数：树，深度和位置指针都为0



深度搜索函数

​		1）终止条件，树为空时，返回

​		2）添加最左侧的元素，当第一次走到某一层的时候，此时map里面是空，更新一次位置信息。

​		左端映射，缺省计算  computeIfAbsent，键存放深度，值存放位置指针，这注意computeIfAbsent

```
leftMap=computeIfAbsent(depth,x->pos);
```

​		3）计算当前结点跟最左侧结点位置的距离，并更新返回。取返回值和当前计算树宽度的较大值，注意计算方法，注意加1

```
res=Math.max(res,pos-leftMap.get(depth)+1);
```

​		4）分别对左右子树调用递归，传入参数depth+1，左子树传入2 *pos，右子树传入 2 * pos+1

```
dfs(root.left,depth+1,2*pos);
dfs(root.right,depth+1,2*pos+1);
```





#### 二叉树寻路

在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。

如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；

而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。

![image-20200512130245733](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200512130245733.png)

![image-20200512130256700](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200512130256700.png)



解题思路![image-20200512130346163](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200512130346163.png)

先判断label处于哪一层，反向找结果，从大到小

解题实现

1）初始化最小值，最大值，深度均为1，初始化返回列表

2）循环，当label大于最大值时

​		3）min等于上一层min的两倍，max等于当前层min两倍-1，深度自增

```
while(label>max){
	min=min*2;
	max=min*2-1;
	depth++;
}
```

4）循环，当深度大于0时

​		5）返回值列表头插label

​		6）最小值和最大值自除2，label等于最小值和最大值之和减label除2

​		7）深度自减

```
while(depth>0){
	res.add(0,label);
	min/=2;
	max/=2;
	label=max+min-label/2;
}
```

8）返回返回值列表











#### 二叉树剪枝

给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。

返回移除了所有不包含 1 的子树的原二叉树。

( 节点 X 的子树为 X 本身，以及所有 X 的后代。)

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200512121510866.png" alt="image-20200512121510866" style="zoom:80%;" />

解题思路

![image-20200512121548690](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200512121548690.png)

解题实现

1）调用递归函数，如果递归结果为真，返回root，否则返回null

​		递归函数

​		2）终止条件：当节点为空时，直接返回false

​		3）分别对左右字树递归，返回递归结果

​		4）判断，如果左右子树的递归结果为false，置为空

```
if(!a1) root.left=null;
if(!a2) root.right=null;
```

​		5）返回值：判断当前节点是否为1且只要有一个子树为真便返回真（或）

```
return root.val==1||a1||a2;
```







#### 二叉树的直径

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。**这条路径可能穿过也可能不穿过根结点**。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200414171136434.png" alt="image-20200414171136434" style="zoom: 80%;" />

解题思想

![image-20200414180709247](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200414180709247.png)

![image-20200414180723889](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200414180723889.png)

解题实现

1）初始化ans为1，调用递归函数

​		2）当节点为空时，返回0

​		3） 分别对左右侧递归，求左子树和右子树的深度

```
int L=recur(root.left);
int R=recur(root.right);
```

​		4）计算ans等于L+R+1，并更新返回值为较大值

```
ans=Math.max(ans,L+R+1);
```

​		5）返回值为左右节点的较大值+1

```
return Math.max(L,R)+1;
```

6）返回值为ans-1；













#### 二叉树展开为链表

给定一个二叉树，[原地](https://baike.baidu.com/item/原地算法/8010757)将它展开为一个单链表。注意是原地

```
    1
   / \
  2   5
 / \   \
3   4   6

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```



解题思路

展开后的链表是1->2->3->4->5->6，这个顺序就是二叉树前序遍历的顺序，我们用前序遍历的方式遍历这棵树，将结果保存到一个数组中，再把这个数组中的每个元素前后串联起来就可以了。

解题实现

1）树空判断，新建列表，前序遍历先将树元素保存到列表中

2）以列表首元素新建树，注意删除列表首元素

3）while循环，直到列表为空

​		4）新建树节点，将新树节点添加到目的树上	

```
while(list.size()>0){
	TreeNode temp=new TreeNode(list.get(0));
	list.remove(0);
	temp.left=null;
	head.right=temp;
	head=head.right;
}
```







#### 二叉树的堂兄弟节点

在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。

如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。

我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。

只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200512135800520.png" alt="image-20200512135800520" style="zoom:80%;" />

解题思路

![image-20200512135852768](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200512135852768.png)

两个Map，分别用于记录当前节点和深度和父节点，然后直接按题目要求比较。

解题实现

1）新建两个全局Map，分别用于记录当前节点的深度和父节点

2）调用递归函数，传入参数root和null（根节点的父节点为null)

递归函数

​		3）终止条件，树节点为空，（当不为空时执行）

​		4）深度Map，判断父节点是否为空，如果为空存放0，否则记录当前节点的深度

```
depth.put(node.val,per!=null?1+depth.get(per),0);
```

​		5）父节点Map：直接存放当前节点的父节点

```
parent.put(node.val,per);
```

​		6）分别对当前树节点的左右节点递归



7）返回值，比较x,y的深度和父节点条件，深度相等，且父节点不相等

```
return (depth.get(x) == depth.get(y) && parent.get(x) != parent.get(y));
```



#### 祖父节点值为偶数的节点和

给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：

该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）
如果不存在祖父节点值为偶数的节点，那么返回 0 。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/10/1473_ex1.png)

```
输入：root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
输出：18
解释：图中红色节点的祖父节点的值为偶数，蓝色节点为这些红色节点的祖父节点。

```

解题思路

判断当前节点是否为偶数，如果是偶数，直接找到其孙节点，并计算总和，对左右节点依次递归

解题实现

```
	int sum = 0;

    public  int sumEvenGrandparent(TreeNode root) {
        if (root == null) {
            return 0;
        }
        if (root.val % 2 == 0) {
            sum += getSonValue(root);
        }
        sumEvenGrandparent(root.left);
        sumEvenGrandparent(root.right);
        return sum;
    }

    public  int getSonValue(TreeNode root) {
        int res = 0;
        if (root.left != null && root.left.left != null) {
            res += root.left.left.val;
        }
        if (root.left != null && root.left.right != null) {
            res += root.left.right.val;
        }
        if (root.right != null && root.right.left != null) {
            res += root.right.left.val;
        }
        if (root.right != null && root.right.right != null) {
            res += root.right.right.val;
        }

        return res;
    }
```









#### 统计二叉树中好节点的数目

给你一棵根为 `root` 的二叉树，请你返回二叉树中好节点的数目。

「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/16/test_sample_1.png)

```
输入：root = [3,1,4,3,null,1,5]
输出：4
解释：图中蓝色节点为好节点。
根节点 (3) 永远是个好节点。
节点 4 -> (3,4) 是路径中的最大值。
节点 5 -> (3,4,5) 是路径中的最大值。
节点 3 -> (3,1,3) 是路径中的最大值
```



解题思路

通过一个Deque将搜索的路径保存起来，将每个点与这个Deque进行比较，判断是否好节点，其中也有回溯的思想







#### 左叶子之和

计算给定二叉树的所有左叶子之和。

```
    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```



解题实现

1）借助辅助递归函数实现



辅助递归函数

1）初始化总和值为0

2）如果节点为空，直接返回0

3）与判断，如果左节点不为空，且为叶子节点，总和值进行累计

```
if(root.left!=null&&(root.left.left==null&&root.left.right==null)){
	sum+=root.left.val;
}
```

4）分别对左右节点递归并加入总和值

```
sum+=recur(root.left,root.right);
```

5）返回



























#### 所有可能的满二叉树

满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。

返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。

答案中每个树的每个结点都必须有 node.val=0。

你可以按任何顺序返回树的最终列表。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200526052058903.png" alt="image-20200526052058903" style="zoom:80%;" />

解题思路

![image-20200526052134478](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200526052134478.png)

解题实现

1）新建静态记忆映射 menory

2）判断N是否已计算

​		3）如果没有计算，新建当前N的临时结果列表

​		4）当N等于1时，临时结果列表直接添加一个空节点

​		5）否则判断N是否为奇数

​				6）如果是奇数，遍历x从0到N-1，x,y分别代表左右子树节点个数，因为是求所有情况，因此遍历

```
if(N==1){
	ans.add(new TreeNode(0))
}else if(N%2==1){
	for(int x=0;x<N;x++){
		int y=N-1-x;
	}
}
```

​				7）双层遍历，遍历对x递归的结果，遍历对y遍历的结果

​						8）新建根节点，将遍历结果分别建树，并把树的结果添加到临时结果列表。

```
for(TreeNode left:allPossibleFBT(x)){
	for(TreeNode right:allPossibleFBT(y)){
		TreeNode bans=new TreeNode(0);
		bans.left=left;
		bans.right=right;
		ans.add(bans);
	}
}
```

​		9）记忆映射加入当前临时结果列表

10）返回记忆映射的第N个值









#### 二叉树中的列表

给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。

如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。

一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200512134338053.png" alt="image-20200512134338053" style="zoom:80%;" />

解题思路

![image-20200512132942522](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200512132942522.png)

嵌套递归，分为主递归和相等匹配递归两层递归实现

解题实现

主递归

1）终止条件：当root为空时返回false

2）判断root的值是否和头节点的值相等

​	3）对head的下一位和左右子树调用相等匹配递归函数，判断两个子树是否有一个子树匹配上了，返回为布尔型

```
boolean b=recur(head.next,root.left)||recur(head.next,root.right);
```

​	4）如果子树是否匹配上（布尔型为true），返回真

5）返回值：匹配不上，对当前树节点的左右子树调用主递归，关系用或连接

```
return isSubPath(head,root.left)||isSubPath(head,root.right);
```

相等匹配递归

6）终止条件：当head为空，返回真，当树节点为空，返回假，当head值不等于树节点的值，返回假

```
if(head==null){
	return true;
}
if(node==null){
	return false;
}
if(head.val!=node.val){
	return false;
}
```

7）对head的下一位元素和树节点的左右子节点分别调用相等匹配递归，之间用或连接

```
return recur(head.next,node.left)||recur(head.next,node.right);
```























### LCA

#### 最大公共祖先







#### 剑指 Offer-二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

![image-20200511161301874](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200511161301874.png)

解题思路

![image-20200511162349890](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200511162349890.png)

解题实现

1）三重或判断，树为空 或 根为p 或 根为q，直接返回root

2）对左子节点递归，返回值left，同理对右子节点递归，返回值right

3）分别会有四种情况，分别讨论

当left和right为空时，返回null；

当left为空时，返回right，

当right为空时，返回left，

否则两边都不为空，返回这个节点

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //空值判断
        if(root==null||root==p||root==q) return root;
        //左右递归再判断
        TreeNode left=lowestCommonAncestor(root.left,p,q);
        TreeNode right=lowestCommonAncestor(root.right,p,q);
        if(left==null) return right;
        if(right==null) return left;
        return root;
    }
}
```









#### 剑指 Offer-二叉搜索树的最近公共祖先

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)

解题实现

解法一：一般方法

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //空值判断
        if(root==null||root==p||root==q) return root;
        //左右递归再判断
        TreeNode left=lowestCommonAncestor(root.left,p,q);
        TreeNode right=lowestCommonAncestor(root.right,p,q);
        if(left==null) return right;
        if(right==null) return left;
        return root;
    }
}
```

解法二：体现搜索树的特点

1）root的值分别与p和q的值比较，确定递归的方向

2）返回root

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //root的值分别与p和q的值比较，确定递归的方向
        //均小于，对右边递归
        if(root.val < p.val && root.val < q.val)
            //注意是返回
            return lowestCommonAncestor(root.right, p, q);
        //均大于，对左边递归
        if(root.val > p.val && root.val > q.val)
            return lowestCommonAncestor(root.left, p, q);
        //直接返回
        return root;
    }
}
```







### 二叉树路径

#### 路径总和

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例: 
给定如下二叉树，以及目标和 sum = 22，

```
       		 5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
```

解题实现

1）终止条件

2）左右节点均为null，且节点值等于Sum时，返回true

3）分别对左右节点递归，且对sum进行处理

```
return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);
```





####  路径总和 II

给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

说明: 叶子节点是指没有子节点的节点。

示例:
给定如下二叉树，以及目标和 sum = 22

```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1


[
   [5,4,11,2],
   [5,8,4,5]
]
```





解题思路

![image-20200614230850839](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200614230850839.png)

解题实现

1）新建返回值列表和路径列表

2）回溯

3）返回

回溯函数

1）终止条件

2）路径加入节点值

3）当满足条件时，路径列表集成

4）对左右节点递归，并对总和值处理

5）路径剔除节点值

```
path.addLast();
if(root.left==null&&root.right==null&&root.val==sum){
	res.add(new ArrayList<>(path));
}
dfs(root.left,sum-root.val,path,res);
dfs(root.right,sum-root.val,path,res);
path.removeLast();
```







#### 路径总和 III

给定一个二叉树，它的每个结点都存放着一个整数值。

找出路径和等于给定数值的路径总数。

路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。

```
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1.  5 -> 3
2.  5 -> 2 -> 1
3.  -3 -> 11

```



解题思路

![image-20200614222331218](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200614222331218.png)

双层递归实现



解题实现

1）终止条件

2）调用递归函数，计算以此节点为根节点的路径个数

3）分别对左右节点递归，计算路径，注意sum不用做处理，表示路径的起点可以不一定从根节点

```
int res=countPath(root,sum);
int left=pathSum(root.left,sum);
int right=pathSum(root.right,sum);
```

4）返回路径总和



递归函数

1）终止条件

2）总和值减去当前节点值

3）判断当前节点是否路径

```
sum-=root.val;
int res=sum==0?1:0;
```

4）返回res+对左右节点的计算结果

```
return res+countPath(root.left,sum)+countPath(root.right,sum);
```







#### 二叉树中和为某一值的路径

​		输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

![image-20200409225717090](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200409225717090.png)

回溯法解决，其包含 **先序遍历 + 路径记录** 两部分，与路径总和II 同题，解法也相同

解题思路

1）新建 静态 双层返回值链表和路径列表

2）调用回溯函数trace，**注意返回值为void，不需要输入返回值列表**

​	3）终止条件树为空

​	4）**路径添加当前节点值**，回溯的第一步

```
path.add(root.val);
```

​	5）目标值减去当前值

```
sum-=root.val;
```

​	6）当目标值为空，且左右节点均为空，将当前路径添加到返回值链表中

```
if(sum==0&&root.left==null&&root.right==null){
	res.add(new ArrayList(path));
}
```

​	7）对左右节点分别递归

```
trace(root.left,sum);
trace(root.right,sum);
```

​	8）**路径链表移除最后一位**，完成回溯

```
path.remove(path.size()-1);
```









#### 二叉树的路径总和

给定一个二叉树和一个整数，判断所有路径中，路径和是否有等于这个整数的。

解题思路

1）树判空

2）目标值sum减节点值

3）当左右节点均为空时，判断并返回目标值是否已为空

```
if(root.left==null&&root.right==null){
	return (sum==0);
}
```

4）对左右节点递归

```
return hasPathSum(root.left,sum)||hasPathSum(root.right,sum);
```



####  二叉树的所有路径

给定一个二叉树，返回所有从根节点到叶子节点的路径。

**说明:** 叶子节点是指没有子节点的节点。

![image-20200511160002407](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200511160002407.png)

解题思路

最直观的方法是使用递归。在递归遍历二叉树时，需要考虑当前的节点和它的孩子节点。如果当前的节点不是叶子节点，则在当前的路径末尾添加该节点，并递归遍历该节点的每一个孩子节点。如果当前的节点是叶子节点，则在当前的路径末尾添加该节点后，就得到了一条从根节点到叶子节点的路径，可以把该路径加入到答案中。

解题实现

1）新建返回值链表列表

2）调用递归函数

```
recur(root,"",paths)
```

​		3）当根非空时

​		4）子路径加入当前节点值

```
path+=Integer.toString(root.val);
```

​		5）判断，如果为子节点时，直接把子路径加入返回值链表列表

​		6）否则加入"->"，再分别对左右节点递归

```
path+="->";
recur(root.left,path,paths);
recur(root.right,path,paths);
```

7）返回







#### 二叉树中的最长交错路径

给你一棵以 root 为根的二叉树，二叉树中的交错路径定义如下：

​			选择二叉树中 任意 节点和一个方向（左或者右）。如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。改变前进方向：左变右或者右变左。重复第二步和第三步，直到你在树中无法继续移动。交错路径的长度定义为：访问过的节点数目 - 1（单个节点的路径长度为 0 ）。

请你返回给定树中最长 交错路径 的长度。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200511154332201.png" alt="image-20200511154332201" style="zoom:80%;" />

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200511154349125.png" alt="image-20200511154349125" style="zoom:80%;" />









### 二叉搜索树

#### 剑指 Offer 54. 二叉搜索树的第k大节点

给定一棵二叉搜索树，请找出其中第k大的节点

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```



解题思路

维护一个中序遍历的列表，返回即可



版本1，返回一个值  解题实现

```java
class Solution {
    public int kthLargest(TreeNode root, int k) {
        List<Integer> res=new ArrayList<>();
        recur(root,res);
        return res.get(res.size()-k);
    }

    public void recur(TreeNode root,List<Integer> res){
        if(root!=null){
            if(root.left!=null){
                recur(root.left,res);
            }
            res.add(root.val);
            if(root.right!=null){
                recur(root.right,res);
            }
        }
    }
}
```



版本2，返回树节点  解题实现

```java
public class Solution {
    TreeNode KthNode(TreeNode pRoot, int k)
    {
        //k和树空判断
        if(k<=0||pRoot==null){
            return null;
        }
        ArrayList<TreeNode> res=new ArrayList<TreeNode>();
        TreeNode test=new TreeNode(-1);
        if(res.size()==0){
            res.add(test);
        }
        recur(pRoot,res);
        if(k>res.size()-1) return null;
        return res.get(k);
    }
    
    public void recur(TreeNode pRoot,ArrayList<TreeNode> res){
        if(pRoot==null) return;
        recur(pRoot.left,res);
        res.add(pRoot);
        recur(pRoot.right,res);
    }
}
```













#### 二叉搜索树中的搜索

给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200511173007637.png" alt="image-20200511173007637" style="zoom:80%;" />



解题思路

![image-20200511173557040](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200511173557040.png)

解题实现

1）若root为空，root的值为目标值，返回root

2）判断root的值和目标值比较，如果小于目标值，对右树递归（搜索），如果大于目标值，对左树递归

```
return root.val<val?searchBST(root.left,val):searchBST(root.right,val);
```



#### 有序链表转换二叉搜索树

给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

```
给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```



解题思路

![image-20200616174013777](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200616174013777.png)



解题实现

1）将链表转化为列表，列表创建为静态变量

2）调用递归函数，传入左右指针位置



递归函数

3）终止条件，当左指针大于右指针时，返回null

4）计算中间位置mid，将mid位置元素当做当前根节点

5）如果左右指针重合，直接返回root

```
if(left==right){
	return root;
}
```

6）分别对链表的左右递归，返回值赋予root的左右节点

```
root.left=recur(left,mid-1);
root.right=recur(mid+1,right);
```

7）返回root







#### 验证二叉搜索树

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

- 节点的左子树只包含**小于**当前节点的数。
- 节点的右子树只包含**大于**当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

解题思路

![image-20200511165141597](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200511165141597.png)



解题实现

1）直接调用递归函数，返回

```java
helper(root,null,null);
```

2）如果节点为空时，终止递归返回真

```java
if(root==null){
	return true;
}
```

3）将当前值与上下界进行比较，如果下界存在，且小于下界，返回错，如果上界存在，且大于上界，返回错

```java
int val=root.val;
if(lower!=null&&val<=lower) return false;
if(upper!=null&&val>=upper) return false;
```

4）右子树与上界递归，左子树与下界递归，如果不成立，返回错

```java
if(!helper(root.left,lower,val)) return false;
if(!helper(root.right,val,upper)) return false;
```

5）返回true



#### 最小高度树

​		给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200520144709341.png" alt="image-20200520144709341" style="zoom:80%;" />

解题思路

​		sortedArrayToBST方法是传入一个数组，然后取数组中间的数建立根节点root，然后以中间为分界，将左边的子数组和右边的子数组分别传入sortedArrayToBST进行递归，返回的是左子树和右子树的根节点，令其等于root.left和root.right即可

解题实现

1）数组空值判定

2）以数组中间元素新建根节点

3）对数组左段递归生成左子树，右段递归生成右子树。

```
n.left=sortedArrayToBST(Arrays.copyOfRange(nums,0,nums.length/2));
n.right=sortedArrayToBST(Arrays.copyOfRange(nums,nums.length/2+1,nums.length));
```

4）返回











#### 二叉搜索树的后序遍历序列

​		输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200412221857300.png" alt="image-20200412221857300" style="zoom: 67%;" />

解题思路

![image-20200412222420172](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200412222420172.png)

解题实现：

1）**先对数组进行判空**并调用递归函数recur

```
return recur(postorder,0,postorder.length-1);
```

终止条件

2）当i **大于等于** j时直接返回真

```java
if(i>=j) return true;
```

递归工作

3）预设定位指针p等于i

4）循环 找到第一个比根节点大的值作为左右分割界

```java
while(postOrder[p]<postOrder[j]) p++;
```

5）预设分界指针m等于p

6）循环 当分界节点后的值都大于根节点时，注意是 p

```java
while(postOrder[p]>postOrder[j]) p++;
```

返回值

7）返回判断三个逻辑，p是否等于j，并对左右子树进行递归，左子树为i到m-1，右子树为m到 j-1

```java
return p==j&&recur(postOrder,i,m-1)&&recur(postOrder,m,j-1);
```



复杂度分析

![image-20200412223539781](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200412223539781.png)



#### 修剪二叉搜索树

给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200414162136606.png" alt="image-20200414162136606"  />

解题思路

![image-20200414162318321](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200414162318321.png)

解题实现

1）判断树空则退出

2）树的值比右界大，则返回对左子树递归，比左界小，则返回对右子树递归

```
if(root.val>R) return trimBST(root.left,L,R);
if(root.val<L) return trimBST(root.right,L,R);
```

3）左子树等于左递归，右子树等于右递归

```
root.left=trimBST(root.left,L,R);
root.right=trimBST(root.right,L,R);
```

4）返回根节点









#### 二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

![image-20200412231726088](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200412231726088.png)

![image-20200412231736929](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200412231736929.png)



解题思路

![image-20200412233126234](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200412233126234.png)

![image-20200412233200958](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200412233200958.png)





解题实现

1）创建静态指针pre，head，对树的判空

2）调用递归函数

​		3）若当前节点cur为空，返回

​		4）对左节点递归

​		5）如果pre不为空，pre的右指针指向当前节点cur，否则 head指向cur（即头节点）

```
if(pre!=null){
	pre.right=cur;
}else{
	head=cur;
}
```

​		6）当前节点cur的左指针指向pre，将pre移动到cur位

```
cur.left=pre;
pre=cur;
```

​		7）对右节点递归

8）所有节点递归完，为实现循环链表，将头尾进行一次关联

9）返回head





复杂度分析

![image-20200412233318204](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200412233318204.png)







#### 把二叉搜索树转换为累加树

给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。

```
输入: 原始二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13
```



解题思路

![image-20200608060042524](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200608060042524.png)

反序中序遍历

​		对右边递归，更新累积值，再更新当前节点，再递归左边

正常的中序遍历：左中右，反序中序遍历：右中左







解题实现

1）初始化全局变量 sum

2）判断，如果树节点不为空，执行

​		3）对右节点递归

​		4）计算总和

​		5）将总和赋给当前递归到的节点

​		6）对左节点递归

```
recur(root.right);
sum+=root.val;
root.val=sum;
recur(root.left);
```

7）返回







#### BiNode

​		二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求值的顺序保持不变，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。

返回转换后的单向链表的头节点。

![image-20200508152351229](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200508152351229.png)

解题思路

直接中序遍历即可，使用递归

![image-20200508152959894](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200508152959894.png)



解题实现

1）新建空头节点

2）调用递归，传入树根节点，链表头节点

​	3）终止条件：root为空

​	4）中序递归

​	5）单级功能：树节点左指针置空，链表临时节点右指针指向树节点，链表临时节点指向树节点（后移）

```
if(root!=null){
	prev=inorder(root.left,prev);
	root.left=null;
	prev.right=root;
	prev=root;
	prev=inorder(root.right,prev);
}
```

​	6）返回链表头节点

7）返回头节点下一位











### 字典树













### 01字典树









### 线段树









### 最小生成树



















