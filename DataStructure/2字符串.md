# 字符串

## 概述

















## 算法案例

leetcode 字符串题目集锦

https://blog.csdn.net/xiangxianghehe/article/details/82081917

















#### 









#### 剑指 Offer-左旋转字符串



解题思路

本题的主要方法可分两种：遍历拼接 或 字符串切片函数  

遍历拼接

![image-20200716220730985](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200716220730985.png)



字符串切片函数

![image-20200716220802238](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200716220802238.png)



解题实现

substring()函数

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        return s.substring(n, s.length()) + s.substring(0, n);
    }
}
```



**推荐使用**：遍历拼接，利用求余运算

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        StringBuilder res = new StringBuilder();
        //注意取余操作后的遍历范围
        for(int i = n; i < n + s.length(); i++)
            res.append(s.charAt(i % s.length()));
        return res.toString();
    }
}
```

StringBuilder 改成 " "

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        String res = "";
        for(int i = n; i < n + s.length(); i++)
            res += s.charAt(i % s.length());
        return res;
    }
}
```



#### 剑指 Offer  字符流中第一个不重复的字符

请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。

解题思路z

使用一个HashMap来统计字符出现的次数，同时用一个ArrayList来记录输入流，每次返回第一个出现一次的字符都是在这个ArrayList（输入流）中的字符作为key去map中查找。

```java
public class Solution {
    HashMap<Character, Integer> map=new HashMap();
    ArrayList<Character> list=new ArrayList<Character>();
    //Insert one char from stringstream
    public void Insert(char ch)
    {
        if(map.containsKey(ch)){
            map.put(ch,map.get(ch)+1);
        }else{
            map.put(ch,1);
        }
         
        list.add(ch);
    }
     
    //return the first appearence once char in current stringstream
    public char FirstAppearingOnce()
    {   
        char c='#';
        for(char key : list){
            if(map.get(key)==1){
                c=key;
                break;
            }
        }
         
        return c;
    }
}
```







#### 剑指 Offer-翻转单词顺序

输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。

```
输入: "the sky is blue"
输出: "blue is sky the"
```



解题思路

本题有两种解法：双指针 和 分割 + 倒序遍历

双指针

![image-20200716214854776](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200716214854776.png)

分割 + 倒序遍历

![image-20200716214927226](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200716214927226.png)





解题实现

面试中建议使用双指针法

1）删除首尾空格

2）新建双指针，返回值串

3）三个while循环解决本题

​		4） while(i >= 0)  保证不退出循环

​		       while(i >= 0 && s.charAt(i) != ' ') i--; // 搜索首个空格

​				while(i >= 0 && s.charAt(i) == ' ') i--; // 跳过单词间空格

​		5）截取单词：res.append(s.substring(i + 1, j + 1) + " "); 

​		6）移动右指针 j 

7）转换并返回

```java
class Solution {
    public String reverseWords(String s) {
        s = s.trim(); // 删除首尾空格
        int j = s.length() - 1, i = j;
        StringBuilder res = new StringBuilder();
        while(i >= 0) {
            //注意两个while，一个是不等于，另一个是等于
            while(i >= 0 && s.charAt(i) != ' ') i--; // 搜索首个空格
            res.append(s.substring(i + 1, j + 1) + " "); // 添加单词
            while(i >= 0 && s.charAt(i) == ' ') i--; // 跳过单词间空格
            j = i; // j 指向下个单词的尾字符
        }
        return res.toString().trim(); // 转化为字符串并返回
    }
}
```







#### 剑指 Offer 05. 替换空格

把字符串 `s` 中的每个空格替换成"%20"。



解题思路

本题可用字符数组解决

![image-20200724175415626](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200724175415626.png)



解题实现

```java
class Solution {
    public String replaceSpace(String s) {
        int len = s.length();
        //建立数组的大小为len*3,保证容纳全部数字
        char[] arr = new char[len * 3];
        int size = 0;
        for (int i = 0; i < len; i++) {
            char c = s.charAt(i);
            //分别就空值和有值两种情况进行分析
            if (c == ' ') {
                arr[size++] = '%';
                arr[size++] = '2';
                arr[size++] = '0';
            } else {
                arr[size++] = c;
            }
        }
        //注意返回时的截取
        String newStr = new String(arr, 0, size);
        return newStr;
    }
}
```





#### 字节跳动2019春招-自动校对机



自动校正：

\1. 三个同样的字母连在一起，一定是拼写错误，去掉一个的就好啦：比如 helllo -> hello

\2. 两对一样的字母（AABB型）连在一起，一定是拼写错误，去掉第二对的一个字母就好啦：比如 helloo -> hello

\3. 上面的规则优先“从左到右”匹配，即如果是AABBCC，虽然AABB和BBCC都是错误拼写，应该优先考虑修复AABB，结果为AABCC

解题思路

分别讨论AABB和AAA的情况，最后还要单独讨论最后三位为连续的情况



解题实现

1）空串或串长小于2直接返回

2）遍历到字符串倒数第三位

​		3）判断AABB的情况，调用处理函数，传入i+2，i --

​		4）判断AAA的情况，调用处理函数，传入i，i --

```
for(int i=0;i<s.length-3;i++){
	if(s.charAt(i)==s.charAt(i+1)&&s.charAt(i+2)==s.charAt(i+3){
		s=delete(s,i+2);
		i--;
	}
	if(s.charAt(i)==s.charAt(i+1)&&s.charAt(i)==s.charAt(i+2)){
		s=delete(s,i)
		i--;
	}
}
```

5）获取处理后数组长度

6）判断末尾可能存在AAA的情况，调用处理函数，传入i-1

```
if(s.charAt(n-1)==s.charAt[n-2]&&s.charAt[n-2]==s.charAt[n-3]){
	s=delete(s,n-1);
}
```

7）返回字符串



处理函数

1）拼接 0-i 和 i+1

```
return s.substring(0,i)+s.substring(i+1);
```







解题思路

![image-20200605071208004](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200605071208004.png)



解题实现

1）转字符数组，获取数组长度，初始化左右指针

2）while循环，当左边小于右边时循环

​		3）从左往右搜索，然后从右往左搜索，找有没有元音

​		4）如果left>right，表示没有元音，直接break

​		5）交换left和right

​		6）left自增，right自减

```
while(left<right){
	if(left<n&&check(arr[left])){
		left++;
	}
	if(right>=0&&check(arr[right])){
		right--;
	}
	if(left>=right){
		break;
	}
	swap(arr,left,right);
	left++;
	right--;
}
```

7）返回字符数组转字符串



元音判断函数

原则：a,e,i,o,u和A,E,I,O,U，为元音，用或连接















#### 字符串相加

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。

注意：

num1 和num2 的长度都小于 5100.
num1 和num2 都只包含数字 0-9.
num1 和num2 都不包含任何前导零。
你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。



解题思路

![image-20200605065702215](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200605065702215.png)

解题实现

1）新建StringBuilder 保存结果

2）获取两串长度，初始化进位为1

3）while循环，当i,j大于等于0时循环

​		4）对i，j判断，是否大于0，如果大于0，说明有实值，计算实值，否则当作0

​		5）计算temp = n1 + n2 + carry;

​		6）计算进位tmp / 10

​		7）返回值加入tmp % 10

​		8）i,j自减

```
while(i>0||j>0){
	int n1=i>0?num1.charAt(i)-'0':0;
	int n2=j>0?num2.charAt(j)-'0':0;
	int temp=n1+n2+carry;
	int carry=temp/10;
	res.add(temp%10);
	i--;j--;
}
```

9）判断进位是否为1，则返回值串还要压入1

10）返回返回值串前还要做一次反向再返回值











#### 翻转字符



#### 增减字符串匹配

给定只含 "I"（增大）或 "D"（减小）的字符串 S ，令 N = S.length。

返回 [0, 1, ..., N] 的任意排列 A 使得对于所有 i = 0, ..., N-1，都有：

如果 S[i] == "I"，那么 A[i] < A[i+1]
如果 S[i] == "D"，那么 A[i] > A[i+1]

![image-20200518143851284](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200518143851284.png)

解题思路

![image-20200518143926179](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200518143926179.png)

解题实现

1）获取字符串长度，维护当前情况下最小值和最大值，初始值分别为0和N

2）新建返回值数组

3）遍历 i 从0到 N-1

​	4）如果取出字符为 "I" (注意是字符）返回值数组赋最小值++

​	    否则取出字符为 "O" 返回值数组赋最大值--

```
for(int i=0;i<N;i++){
	if(S.charAt(i)=="I"){
		res[i]=low++;
	}else{
		res[i]=high--;
	}
}
```

5）返回值第N位赋值最小值

6）返回

















#### 字符串的排列





#### 第一个只出现一次的字符









#### 把字符串转换成整数













#### 





#### 表示数值字符串







#### 查找最长公共前缀



#### 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

![image-20200507183450623](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200507183450623.png)

解题思路

![image-20200507183711146](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200507183711146.png)



解题实现

1）当字符串为空时直接返回" "

2）初始化前缀返回值为字符串数组第一位

3）遍历字符串数组，i从1到最后一位

​		4）循环判断，前缀返回值是否为当前字符串的前缀

​					5）如果不是，将前缀返回值末尾去掉一位，判断前缀返回值是    				否为空，如果为空，直接返回

```
while(strs[i].indexOf(prefix)!=0){
	prefix=prefix.substring(0,prefix.length-1);
	if(prefix.isEmpty()) return "";
}
```

6）返回

此处注意：strs[i].indexOf(prefix)!=0时说明的是prefix不为strs[i]的前缀







#### 字符串的排列

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

![image-20200421130152591](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200421130152591.png)



**解题思路**
		排列方案数量： 对于一个长度为 nn 的字符串（假设字符互不重复），其排列共有 n \times (n-1) \times (n-2) … \times 2 \times 1n×(n−1)×(n−2)…×2×1 种方案。

​		排列方案的生成方法： 根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过字符交换，先固定第 11 位字符（ nn 种情况）、再固定第 22 位字符（ n-1n−1 种情况）、... 、最后固定第 nn 位字符（ 11 种情况）。

![image-20200421130347146](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200421130347146.png)

​		重复方案与剪枝： 当字符串存在重复字符时，排列方案中也存在重复方案。为排除重复方案，需在固定某位字符时，保证 “每种字符只在此位固定一次” ，即遇到重复字符时不交换，直接跳过。从 DFS 角度看，此操作称为 “剪枝” 。

![image-20200421130408033](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200421130408033.png)

![image-20200421130420200](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200421130420200.png)

复杂度分析

![image-20200421130527982](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200421130527982.png)

**解题实现**

1）新建返回值列表和字符数组

```
List<String> res=new LinkedList<>();
char[] c;
```

2）字符串转字符数组，调用递归函数，输入参数固定位x为0

​		3）当固定位x等于字符数组长度减1时，字符数组转字符串再放入返回值列表中，返回

```
if(x==c.length-1){
	res.add(String.valueOf(c));
	return;
}
```

​		4）新建字符集合

​		5）遍历字符数组 i 从x到c.length

```
for(int i=x;i<c.length;i++){
}
```

​			  6）当集合中包含了这个字符，跳过本次遍历

```
if(set.contains(c[i])) continue;
```

​			  7）集合加入字符

​		  	 8）交换 i 和 x，将 c[i] 固定在第 x 位 ，对x+1位递归，再次交换 i 和 x

```
swap(i,x);
dfs(x+1);
swap(i,x);
```

9）交换函数，传入参数a和b，交换字符数组a，b位上的元素

```
void swap(int a,int b){
	char tmp=c[a];
	c[a]=c[b];
	c[b]=tmp;
}
```

10）返回，返回值列表转String数组，返回值列表长度新建String，转数组，注意new String[]

```
return res.toArray(new String[res.size()]);
```







### Manache算法





#### 回文字符串


#### 验证回文串


#### 最长回文子串











### 字符串匹配算法

概述

​		此算法通常输入为原字符串（string）和子串（pattern），要求返回子串在原字符串中首次出现的位置。比如原字符串为“ABCDEFG”，子串为“DEF”，则算法返回3。

​		字符串匹配算法有几种相对比较出名的，分别是BF(暴力破解)，RK()、BM()、KMP()。



#### BF(暴力破解)

​		在主串中，检查的起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串(n为主串的长度， m为模式串的长度)，看有没有跟模式串匹配的。这种算法的时间复杂度为O(n*m), 空间复杂度为O(1)。

解题实现

1）首先判断needle非空而且不为" "

2）获取haystack和needle的长度

3）循环 i 从0 到 haystack长度-needle长度

4）判断 haystack 的第 i 位是否等于needle的第0位，且haystack的subString等于needle，成立直接返回 i

```java
for(int i=0;i<len1-len2;i++){
if(haystack.charAt(i)==needle.charAt(0)&&haystack.substring(i,i+len2).equals(needle)){
		return -1;
	}
}
```

5）未找到 返回-1



#### KMP

​		KMP 算法目的就是：**在出错时，利用原有的匹配信息，尽量减少重新匹配的次数。** KMP 算法的主串下标永不后退，而暴力算法一旦出错，则回退至匹配起始的下一个下标重头开始。



​		每当一趟匹配过程中出现字符比较不等时，不需回溯i指针，而是利用已经得到的“部分匹配”的结果将模式向右“滑动”尽肯能远的一段距离后，继续进行比较。

核心：前缀匹配数组求取

![这里写图片描述](https://img-blog.csdn.net/20171008193112006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzgzNjY3Nzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

​		next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1。就是找最大对称长度的前缀后缀，然后整体右移一位，初值赋为-1



KMP算法实现

1）空值判定，模式串长度小于0，主字符串和模式串为空，或长度小于1返回-1

```
if(pattern.length()<1){
	return 0;
}
if(text==null||pattern==null||text.length()<1||pattern.length()<1){
	return -1;
}
```

2）初始化主字符串和模式串下标为0

3）将主字符串和模式串转为字符数组

4）获得Next数组

5）while循环 当主字符串下标和模式串下标小于对应数组的长度时

​		6）三种判断，

​		如果主字符串此刻值等于模式串

​				主字符串下标和模式串下标自增

​		否则如果next数组的模式串下标位置值等于-1

​		(如果为第一位都不匹配则直接下一个字符)

​				主字符串下标自增

​		否则

​		(next[index2]不等于-1)

​				模式串从next数组中取值

```
while(index1<char1.length&&index2<char2.length){
	if(char1[index1]==char2[index2]){
		index1++;
		index2++;
	}else if(next[index2]==-1){
		index1++;
	}else{
		index2=next[index2];
	}
}
```

7）返回判断，如果模式串下标等于模式串长度，返回主字符串下标和模式串下标之差，否则返回-1

```
return index2==char2.length?index1-index2:-1;
```



前缀匹配数组计算函数  getNext（）

1）当模式串长度为1时，直接返回长度为-1的数组

2）新建next数组，**首位和第二位赋值分别为-1和0**

3）新建指向当前元素最长前缀的指针 cn为0，**模式串下标index为2**

4）while循环 当模式位置小于模式串数组长度时

​	5）三种判断

​		如果模式串数组下标-1位的值等于模式串数组cn位元素的值

​		（index-1位置元素和cn位置元素相等）

​		否则如果cn大于0

​		（cn大于0的时候，才从next中取值，否则不取值）

​		否则

​		（next的index++位置应该是0）

​				next数组的index++位设0；

```
while(index<char2.length){
	if(char2[index-1]==char2[cn]){
		next[index++]=++cn;
	}else if(cn>0){
		cn=next[cn];
	}else{
		next[index++]=0;
	}
}
```

6）返回next数组



规律

1）前三个判断是对index1,2的操作，后三个判断是为对next数组和cn的





```java
/**
* kmp算法，让前面匹配的结果指导后面开始的匹配。
* 1.求模式串needle的nexts数组。
*    前缀：从第一个元素开始不包含末尾元素的子串；后缀：从最后一个元素开始不包含头元素的子串。
*    比如字符串abc，前缀可以是a或者ab，后缀可以是c或者bc
*    最长公共元素：前缀与后缀相同并且保证长度最长，ababab的最长前缀为abab，
*    前缀和后缀允许包含相同的元素但不能完全相同。
*    具体步骤如下
*    1)下标为0，1位置的nexts元素固定为-1，0
*    2)nexts数组当前下标为i，假设在这个下标之前的nexts数组元素都正确，i-1位置的next数组元素为n，n即为i-1的最长前缀
*       如果i-1位置的最长前缀的下一个元素和i-1位置的元素相同，那么i位置的最长前缀为n+1.否则继续找i-1位置的最长前缀的
*       最长前缀的下一个元素和i-1位置的元素是否相同，每次都这样找，直到找到或者找不到为止。找到的话最长前缀为找到时候的前缀
*       长度+1，否则就为0(即没有最长前缀)。
*       如ababcababe，需要找e位置的最长前缀。已知e之前的next数组对应为[-1,0,0,1,2,0,1,2,3,n]。求n
*       用i表示当前e元素的下标，i-1就是e前一个位置的下标。i-1对应的元素b存在最长前缀aba。aba的下一个元素b和i-1位置的b相同
*       则n就是它前一个元素的最长前缀3加上1，所以n=4.
* 2.主串haystack与needle开始匹配。
*       haystack的m位置和needle的n位置不匹配，但n之前的元素都匹配，只需要找到n的最长前缀k，下一次匹配从m位置和k的下一个元素进行匹配
*/
class Solution {
    public int strStr(String haystack, String needle) {
        //如果needle为空，则返回0
        if(needle.length()<1){
            return 0;
        }
        if(haystack == null || needle == null || haystack.length() < 1 || needle.length() < 1){
            return -1;
        }        
        
        //主字符串haystack的下标
        int index1 = 0;
        //模式串needle的下标
        int index2 = 0;
        char[] char1 = haystack.toCharArray();
        char[] char2 = needle.toCharArray();
        //获得nexts数组
        int[] nexts = getNexts(char2);
        while(index1 < char1.length && index2 < char2.length){
            if(char1[index1] == char2[index2]){
                index1++;
                index2++;
            }else if(nexts[index2] == -1){//如果为第一位都不匹配则直接下一个字符
                index1++;
            }else{
                index2 = nexts[index2];
            }
        }
        return index2 == char2.length ? index1 - index2 : -1;
    }
    //获得next数组
    public int[] getNexts(char[] str2){
        if(str2.length == 1){
            return new int[]{-1};
        }
        int[] nexts = new int[str2.length];
        nexts[0] = -1;
        nexts[1] = 0;
        //指向当前元素最长前缀的指
        int cn = 0;
        //遍历字符串时的下标
        int index = 2;
        while(index < str2.length){
            if(str2[index - 1] == str2[cn]){
                nexts[index++] = ++cn;
            }else if(cn > 0){
                cn = nexts[cn];
            }else{
                nexts[index++] = 0;
            }
        }
        return nexts;
    }
}


```











































