# 集合

## 概述

![image-20200227161742634](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200227161742634.png)

​	Set：注重独一无二的性质,该体系集合可以知道某物是否已近存在于集合中,不会存储重复的元素，用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。

#### 	HashSet 

​	  哈希表里存放的是哈希值。HashSet存储元素的顺序并不是按照存入时的顺序（和List显然不同） 是按照哈希值来存的所以取数据也是按照哈希值取得。由于Set集合是不能存入重复元素的集合。那么HashSet也是具备这一特性的。

![image-20200227161236976](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200227161236976.png)

实例：

```java
// Set 集合存和取的顺序不一致。
Set hs = new HashSet();
hs.add("世界军事");
hs.add("兵器知识");
hs.add("舰船知识");
hs.add("汉和防务");
// 返回此 set 中的元素的数量
System.out.println(hs.size()); // 4
// 如果此 set 尚未包含指定元素，则返回 true
boolean add = hs.add("世界军事"); // false
System.out.println(add);
// 返回此 set 中的元素的数量
System.out.println(hs.size());// 4
Iterator it = hs.iterator();
while (it.hasNext()) {
	System.out.println(it.next());
}
```

基于链表底层自定义HashSet

![image-20200227163135797](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200227163135797.png)

#### TreeSet



#### LinkedHashSet



### 运用案例

#### 自定义HashSet

![image-20200227163214990](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200227163214990.png)



```java
public class MyHashSet {
    public Bucket[] bucketArray;
    public int Base;

    /**
     * Initialize your data structure here.
     * 基数设置为质数 769
     */
    public MyHashSet() {
        this.Base = 769;
        this.bucketArray = new Bucket[this.Base];
        for (int i = 0; i < this.Base; ++i) {
            this.bucketArray[i] = new Bucket();
        }
    }
    
//    哈希函数
    public int _hash(int key) {
        return (key % this.Base);
    }
    
//    先计算哈希索引,再在bucketIndex位置插入
    public void add(int key) {
        int bucketIndex = this._hash((key));
        this.bucketArray[bucketIndex].insert(key);
    }

//    先计算哈希索引,再在bucketIndex位置删除
    public void remove(int key) {
        int bucketIndex = this._hash(key);
        this.bucketArray[bucketIndex].delete(key);
    }

    /**
     * Returns true if this set contains the specified element
     * 判断bucketArray中是否存在指定key
     */
    public boolean contains(int key) {
        int bucketIndex = this._hash(key);
        return this.bucketArray[bucketIndex].exists(key);
    }
}

//辅助 桶类
class Bucket {
    public LinkedList<Integer> container;

    public Bucket() {
        container = new LinkedList<Integer>();
    }

    public void insert(Integer key) {
//        方法返回在此列表中指定元素的第一个匹配项的索引，
//        或者-1，如果此列表中不包含该元素。
        int index = this.container.indexOf(key);
        if (index == -1) {
//            如果不存在，则用头插法插入
            this.container.addFirst(key);
        }
    }

    public void delete(Integer key) {
        this.container.remove(key);
    }

    public boolean exists(Integer key) {
        int index = this.container.indexOf(key);
        return (index != -1);
    }
}
```







#### 解题经验





