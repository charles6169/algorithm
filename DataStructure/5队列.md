# 队列



## 概述

### 队列的介绍



### 使用场景





### 常见操作



## 实现

### 单向队列实现

3.1.  定义

​	队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。

​	而队列又有单向队列和双向队列两种，其中，单向队列的特点是，遵守“先进先出”的规则，每次在队列末尾添加元素，从队列头部取出元素。

​	**Queue接口与List、Set同一级别，都是继承了Collection接口。LinkedList实现了Deque接 口**

![img](https://images2017.cnblogs.com/blog/1182892/201711/1182892-20171122100317930-842768608.png)



LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用

队列的基础操作

```java
public class Main {
    public static void main(String[] args) {
        //add()和remove()方法在失败的时候会抛出异常(不推荐)
        Queue<String> queue = new LinkedList<String>();
        //添加元素
        queue.offer("a");
        queue.offer("b");
        queue.offer("c");
        queue.offer("d");
        queue.offer("e");
        for(String q : queue){
            System.out.println(q);
        }
        System.out.println("===");
        System.out.println("poll="+queue.poll()); //返回第一个元素，并在队列中删除
        for(String q : queue){
            System.out.println(q);
        }
        System.out.println("===");
        System.out.println("element="+queue.element()); //返回第一个元素 
        for(String q : queue){
            System.out.println(q);
        }
        System.out.println("===");
        System.out.println("peek="+queue.peek()); //返回第一个元素 
        for(String q : queue){
            System.out.println(q);
        }
    }
}
```

经典方法：

![image-20200225215754486](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200225215754486.png)

常用拓展：

队列的两种遍历方式

```java
// 集合方式遍历，元素不会被移除  
for (String s : queue) {  
    System.out.println(s);  
}  

// 队列方式遍历，元素逐个被移除  
while (!queue.isEmpty()) {  
    // 获取并移除此队列的头，如果此队列为空，则返回 null  
    System.out.println(queue.poll());  
}  
```

### 数组队列实现

https://zhuanlan.zhihu.com/p/87046659

### 循环队列实现



## 解题技巧

### 单调队列













## 算法案例

【LeetCode】队列 queue（共8题）

https://www.cnblogs.com/zhangwanying/p/9886581.html





#### 队列与栈的互相模拟问题

​	最关键部分就是说压入元素，即push，其他几个比较好模拟

用队列模拟栈：

​	基本思路是用两个队列来模拟，当压入元素时，先将该元素放到空的队列（1）中，再把非空队列（2）的元素依次弹出压入这个队列（1）中，交替使用，其中队列（1）理解为主队列。

1-2-3-4 => 4-3-2-1

用栈模拟队列：

​	基本思路是用两个栈来模拟，当压入元素时，先将非空栈（1）中的元素弹出压入空栈（2）中，然后把元素压入栈（1），再把栈（2）的元素弹出压回栈（1），每次交替，其中栈（1）可以理解为主栈

1-2-3-4 => 1-2-3-4

```
简而言之都是轮流使用，再加入新元素之前先做一次清空操作，再插入
```



### 单调队列

#### 剑指 Offer -滑动窗口的最大值







解题思路

本题有暴力解法和单调队列解法

暴力解法的分析

![image-20200721205539756](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200721205539756.png)

单调队列

![image-20200721205632834](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200721205632834.png)

![image-20200721205702291](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200721205702291.png)

![image-20200721205715506](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200721205715506.png)



复杂度分析

![image-20200721205735627](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200721205735627.png)



解题实现

1）空值判断

2）新建队列

3）新建返回值数组

4）遍历

​		5）判断，如果 i > 0 && deque.peekFirst() == nums[i - 1]，出队

​		6）循环，如果 !deque.isEmpty() && deque.peekLast() < nums[j] 出队

​		7）队列加入nums[j]

​		8）判断 如果 i >= 0，返回值数组赋值：res[i] = deque.peekFirst();

9）返回

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums.length == 0 || k == 0) return new int[0];
        //注意队列的创建方式
        Deque<Integer> deque = new LinkedList<>();
        //新建数组的大小为：len-k+1
        int[] res = new int[nums.length - k + 1];
        //遍历起点：j->0 i->1-k 
        for(int j = 0, i = 1 - k; j < nums.length; i++, j++) {
            //保证队列单调递减 i > 0不取等  注意是和nums[i-1]比较
            if(i > 0 && deque.peekFirst() == nums[i - 1]) deque.removeFirst(); // 删除 deque 中对应的 nums[i-1]
            //注意deque.peekLast() < nums[j] 注意deque.peekLast()应该为最小
            while(!deque.isEmpty() && deque.peekLast() < nums[j]) deque.removeLast(); // 保持 deque 递减
            deque.addLast(nums[j]);
            if(i >= 0) res[i] = deque.peekFirst();  // 记录窗口最大值
        }
        return res;
    }
}


```

