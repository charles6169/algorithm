# 并查集

## 概述

原理图解

![image-20200610220152013](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200610220152013.png)

![image-20200610220211038](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200610220211038.png)





## 简单实现

并查集主要涉及到两种操作，合并和查找。假设有一个动态集合：S={s1，s2，s3，…..sn}。在这个集合里面每一个元素都是一个江湖人物。比如S1代表了岳不群等等。

我们实现一个并查集的时候首先要考虑的就是存储结构，一般情况下有两种：数组和链表。

### 数组实现

```
private int[] parent = new int[1000];
```

​		int pre[1000] 这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。

```
public static int find(int target, int[] parent) {
        int parentIndex = target;
        //当一个数组等于角标时，说明找到了根节点
        //从while循环出来的temp即为target对应的树的根节点所在patent数组的下标
        while (parent[parentIndex] != parentIndex) {
            parentIndex = parent[parentIndex];
        }
        //路径压缩
        int i = target;
        //把target以及target的双亲节点的全部赋值为根节点
        while (i != parentIndex) {
            //找到i对应的双亲节点
            i = parent[i];
            //把i的双亲节点直接赋值为根节点，达到路径压缩的目的
            parent[i] = parentIndex;
        }
        return parentIndex;
    }

```

路径压缩算法

​		建立门派的过程是用join函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么胎唇样，我也完全无法预计，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。 设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能揍。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是记己人，西礼西礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位同学请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其习偶们的掌门是曹公公。不如偶们一起及接拜在曹公公手下吧，省得级别太低，以后查找掌门麻环。” “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。路径压缩的代码，看得懂很好，看不懂也没关系，直接抄上用就行了。总之它所实现的功能就是这么个意思。
![image-20200610221216301](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200610221216301.png)



​	



​	如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。	 find这个函数就是找掌门用的，意义再清楚不过了（路径压缩算法先不论，后面再说）。

​	

```
//要将两个树合并，分别找个两个树的根节点，把其中一个赋值为另一个的父节点即完成两颗树合并
    public static void join(int target1, int target2, int[] parent) {
        int root1 = find(target1, parent);
        int root2 = find(target2, parent);
        if (root1 != root2) {
            parent[root1] = root2;
        }
    }
```

​		再来看看join函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？ 还是举江湖的例子，假设现在武林中的形势如图所示。虚竹小和尚与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”抗议无效，上天安排的，最大。反正谁加入谁效果是一样的，我就随手指定了一个。这段函数的意思很明白了吧？




完整代码

```java
public class DisJoinSetArray {

    private int[] parent = new int[1000];

    public static int find(int target, int[] parent) {
        int parentIndex = target;
        //当一个数组等于角标时，说明找到了根节点
        //从while循环出来的temp即为target对应的树的根节点所在patent数组的下标
        while (parent[parentIndex] != parentIndex) {
            parentIndex = parent[parentIndex];
        }
        //路径压缩
        int i = target;
        //把target以及target的双亲节点的全部赋值为根节点
        while (i != parentIndex) {
            //找到i对应的双亲节点
            i = parent[i];
            //把i的双亲节点直接赋值为根节点，达到路径压缩的目的
            parent[i] = parentIndex;
        }
        return parentIndex;
    }

    //要将两个树合并，分别找个两个树的根节点，把其中一个赋值为另一个的父节点即完成两颗树合并
    public static void join(int target1, int target2, int[] parent) {
        int root1 = find(target1, parent);
        int root2 = find(target2, parent);
        if (root1 != root2) {
            parent[root1] = root2;
        }
    }


}
```















### 运用案例

LeetCode】并查集 union-find（共16题）

https://www.cnblogs.com/zhangwanying/p/9964303.html





