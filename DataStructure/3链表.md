链表

## 概述

1.1 什么是链表

链表是一种用于存储数据集合的数据结构。主要有哪些属性呢，如下所示：
- 链表是由内存中一系列不相连的结构组成
- 一种线性表，但是并不会按线性的顺序存储数据
- 每一个结构均含有表元素和next指针，最后一个元素的后续指针是NULL
- 程序执行过程中，链表长度可以增加和缩小
- 没有内存空间的浪费，但是指针需要一些额外的内存开销

- 链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理，如何理解这句话？

​        链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。

#### 1.2 链表优缺点
- 优点是插入和删除比较方便(不需移动其他元素, 只需改变指针)，缺点是访问效率低，存储空间利用率低。



#### 1.3 为何用链表
- 使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。



## 链表分类

#### 2.1 单向链表
- 单链表是链表中结构最简单的。
  
    - 一个单链表的节点(Node)分为两个部分，第一个部分(data)保存或者显示关于节点的信息，另一个部分存储下一个节点的地址。最后一个节点存储地址的部分指向空值。
    
- 结构图如下所示
  
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-f11de49039f74535.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190808011802666.png)
    
- 单链表的节点类
  
    ```java
    //链表的每个节点类
    private class Node{
        private Object data;//每个节点的数据
        private Node next;//每个节点指向下一个节点的连接
        
        public Node(Object data){
            this.data = data;
        }
    }
    ```




#### 2.2 双向链表
- 为什么会有双向链表
  
    - 对于单项链表，我们如果想在尾部添加一个节点，那么必须从头部一直遍历到尾部，找到尾节点，然后在尾节点后面插入一个节点。这样操作很麻烦，如果我们在设计链表的时候多个对尾节点的引用，那么会简单很多。
    
- 结构图如下图所示[LinkedList中双向链表]
  
    - ![LinkedList内部结构](https://user-gold-cdn.xitu.io/2018/3/19/1623e363fe0450b0?w=600&h=481&f=jpeg&s=18502)
    
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20181124213245741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDI4OTg1,size_16,color_FFFFFF,t_70)
    
    
    
    双向链表的节点类：
    
    - 这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。
    ```java
    private static class Node<E> {
        E item;//节点值
        Node<E> next;//后继节点
        Node<E> prev;//前驱节点
    
        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
    ```





#### 2.3 循环链表
- 如下所示
  
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-83d9119fe9d527d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190228231244333.)
    
- 循环链表的节点类
  
    ```
    
    ```



参考博客

循环链表、仿真链表：https://www.cnblogs.com/smyhvae/p/4768538.html







## 链表操作

### 单链表操作

#### 单链表创建

创建单链表并且遍历打印存储的值。代码如下所示

- Node节点采用的是内部类来表示
- 为了方便添加和遍历的操作，在LinkList类中添加一个成员变量current，用来表示当前节点的索引

```java
public class LinkList {
    public Node head;
    public Node current;
    
    class Node {
        //注：此处的两个成员变量权限不能为private，因为private的权限是仅对本类访问。
        int data; //数据域
        Node next;//指针域
        public Node(int data) {
            this.data = data;
        }
    }

    //方法：遍历链表（打印输出链表。方法的参数表示从节点node开始进行遍历
    public void print(Node node) {
        if (node == null) {
            return;
        }
        current = node;
        while (current != null) {
            System.out.println(current.data);
            current = current.next;
        }
    }
}
```

测试代码

```java
public void test() {
    LinkList list = new LinkList();
    //向LinkList中添加数据
    for (int i = 0; i < 10; i++) {
        list.add(i);
    }
    list.print(list.head);// 从head节点开始遍历输出
}
```



####  尾部插值

1）新建节点

2）判断当为空节点时，直接赋值返回

```
if(head==null){
	head=tNode;
	return head;
}
```

3）临时指针找到链表末尾

```
ListNode cur=head;
while(cur!=null){
	cur=cur.next;
}
```

4）将新节点插入到尾部





#### 头部插值

1）新建节点

2）判断当为空节点时，直接赋值返回

3）借助临时指针，将节点插到头部

```
ListNode cur=head;
tNode.next=cur;
head=tNode;
```

4）返回头节点





#### 反向链表操作

标准模板

```java
class Solution {
    List<Integer> tmp=new ArrayList<>();
    public int[] reversePrint(ListNode head) {
        recur(head);
		//tmp中存放的是链表的反向数据
    }

    public void recur(ListNode head){
        if(head==null) return;
        recur(head.next);
        tmp.add(head.val);
    }
}
```





#### 指定位置插值

1）获取链表的长度

2）判断插入的位置是否正确

3）当插入位置为首和尾时，使用头插法和尾插法

4）如果是中间插，新建临时指针，节点，辅助位置变量为1

```
ListNode cur=head;
ListNode Node=new ListNode(node);
int tLength=1;
```

5）借助临时指针遍历链表

6）辅助位置变量自增等于位置值时，即找到目标位置，将节点插入到指定的位置，直接退出循环

```
if(pos==++tLength){
	node.next=cur.next;
	cur.next=node;
	break;
}
```

7）返回头节点





其他功能

```java
    //    获取链表长度
    public static int getLength(ListNode head) {
        ListNode temp = head;
        int length = 1;
        while (temp.next != null) {
            temp = temp.next;
            length++;
        }
        return length;
    }

    //    位置参数判断
    public static void posJudge(ListNode head, int pos) {
        int length = getLength(head);
        if (pos < 0) {
            System.out.println("输入参数过小");
            return;
        }
        if (pos > length) {
            System.out.println("输入参数过大");
            return;
        }
    }


    //    数组转链表
    public static ListNode arrToList(int[] arr) {
        if (arr == null || arr.length == 0) {
            throw new IllegalArgumentException("数组不能为空!");
        }
        ListNode head = new ListNode(arr[0]);
        ListNode cur = head;
        for (int i = 1; i < arr.length; i++) {
            cur.next = new ListNode(arr[i]);
            cur = cur.next;
        }
        return head;
    }

    




    //    删除指定位置元素
    public static ListNode delNodeByIndex(ListNode head, int pos) {
        posJudge(head, pos);
        ListNode cur = head;
        int tLength = 1;
        while (cur.next != null) {
            if (pos == ++tLength) {
//                删除的方法
                cur.next = cur.next.next;
                break;
            }
            cur = cur.next;
        }
        return head;
    }


    //    打印链表
    public static void printListNode(ListNode head) {
        StringBuilder res = new StringBuilder();
        ListNode cur = head;
        while (cur != null) {
            res.append(cur.val + "->");
            cur = cur.next;
        }
        res.append("NULL");
        System.out.println(res.toString());
    } 
```





#### 用单向链表实现栈

用单向链表实现栈

解题思路

​		栈的pop()方法和push()方法，对应于链表的在头部删除元素deleteHead()以及在头部增加元素addHead()。

```java
public class MyStack {
    class Node {// 定义节点
        private Node next;
        public Object value;
    }

    Node top = null;

    void init() {//初始话头结点
        top = new Node();
        top.next = null;
        top.value = null;
    }

    public void push(Object element) {//采用头插发的方式模拟入栈
        Node e = new Node();
        e.value = element;
        if (top.next == null) {
            top.next = e;
        } else {
            e.next = top.next;
            top.next = e;

        }

    }

    public Object pop() {//弹出栈顶元素，也就是头结点后面的第一个元素
        Object ele = null;
        if (top.next == null) {
            System.out.println("栈为空!");
        } else {
            ele = top.next.value;
            top.next = top.next.next;//移动指针。相当于删除链表中第一个元素
        }
        return ele;
    }
 
    public Object peek()//返回栈顶元素,不执行出栈操作
    {
        if(top.next==null)
        {
            return -1;
        }
        else
        return top.next.value;
    }
    public boolean isempty()//判断栈是否为空
    {
        return top.next==null?true:false;
    }
    
    public int size() {//返回栈的大小，含有的元素个数
        Node temp = top;
        int i = 0;
        while (temp.next != null) {
            i++;
            temp = temp.next;
        }
        return i;
    }

    public void print() {//打印栈中存在的元素
        Node temp = top;
        if(temp.next==null)
        {
            System.out.println("栈为空！");
        }
        while (temp.next != null) {
            System.out.print(temp.next.value + "  ");
            temp = temp.next;
        }
    }

    public static void main(String[] args) {
        MyStack stack = new MyStack();
        stack.init();
        for (int i = 0; i < 5; i++) {
            stack.push(i);
        }
        /*Object ele1 = stack.pop();
        Object ele2 = stack.pop();
        Object ele3 = stack.pop();
        Object ele4 = stack.pop();
        Object ele5 = stack.pop();
        System.out.println(ele1);
        System.out.println(ele2);
        System.out.println(ele3);
        System.out.println(ele4);
        System.out.println(ele5);*/
        Object ele1 = stack.pop();
        System.out.println("此次弹出的元素为:"+ele1);
        System.out.print("栈中剩余的元素为:");
        stack.print();
        System.out.println();
        System.out.println("栈顶元素为:"+stack.peek());
    }
}
```









### 双向链表操作

- 代码如下所示

  ```java
  public class DoublePointLinkedList {
      private Node head;//头节点
      private Node tail;//尾节点
      private int size;//节点的个数
      
      private class Node{
          private Object data;
          private Node next;
          
          public Node(Object data){
              this.data = data;
          }
      }
      
      public DoublePointLinkedList(){
          size = 0;
          head = null;
          tail = null;
      }
      
      //链表头新增节点
      public void addHead(Object data){
          Node node = new Node(data);
          if(size == 0){//如果链表为空，那么头节点和尾节点都是该新增节点
              head = node;
              tail = node;
              size++;
          }else{
              node.next = head;
              head = node;
              size++;
          }
      }
      
      //链表尾新增节点
      public void addTail(Object data){
          Node node = new Node(data);
          if(size == 0){//如果链表为空，那么头节点和尾节点都是该新增节点
              head = node;
              tail = node;
              size++;
          }else{
              tail.next = node;
              tail = node;
              size++;
          }
      }
      
      //删除头部节点，成功返回true，失败返回false
      public boolean deleteHead(){
          if(size == 0){//当前链表节点数为0
              return false;
          }
          if(head.next == null){//当前链表节点数为1
              head = null;
              tail = null;
          }else{
              head = head.next;
          }
          size--;
          return true;
      }
      //判断是否为空
      public boolean isEmpty(){
          return (size ==0);
      }
      //获得链表的节点个数
      public int getSize(){
          return size;
      }
      
      //显示节点信息
      public void display(){
          if(size >0){
              Node node = head;
              int tempSize = size;
              if(tempSize == 1){//当前链表只有一个节点
                  System.out.println("["+node.data+"]");
                  return;
              }
              while(tempSize>0){
                  if(node.equals(head)){
                      System.out.print("["+node.data+"->");
                  }else if(node.next == null){
                      System.out.print(node.data+"]");
                  }else{
                      System.out.print(node.data+"->");
                  }
                  node = node.next;
                  tempSize--;
              }
              System.out.println();
          }else{//如果链表一个节点都没有，直接打印[]
              System.out.println("[]");
          }
      }
  }
  ```

双链表创建和使用

循环链表创建和使用











### 双指针技巧

​		双指针技巧还可以分为两类，一类是**「快慢指针」**，另一类是**「左右指针」**。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。

快慢指针的常见算法

​		快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。

#### 判定链表中是否含有环

​		这应该属于链表最基本的操作了，如果读者已经知道这个技巧，可以跳过。单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。如果链表中不包含环，那么这个指针最终会遇到空指针 null 表示链表到头了，这还好说，可以判断该链表不含环。

```
boolean hasCycle(ListNode head) {
    while (head != null)
        head = head.next;
    return false;
}
```

​		但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 null 指针作为尾部节点。经典解法就是用两个指针，一个每次前进两步，一个每次前进一步。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。

```
boolean hasCycle(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while(fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        
        if (fast == slow)
            return true;
    }
    return false;
}
```

​		已知链表中含有环，返回这个环的起始位置

![img](https://img2018.cnblogs.com/blog/1566782/201906/1566782-20190626075016458-1495003044.jpg)

这个问题其实不困难，有点类似脑筋急转弯，先直接看代码：

```
ListNode detectCycle(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow)
            break;
    }
    
    slow = head;
    while (slow != fast) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
}
```

​		可以看到，当快慢指针相遇时，让其中任一个指针重新指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步（也就是环的长度）。

![img](https://img2018.cnblogs.com/blog/1566782/201906/1566782-20190626075054000-1816921447.jpg)

​		设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。

![img](https://img2018.cnblogs.com/blog/1566782/201906/1566782-20190626075122685-698940711.jpg)

​		所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后就会相遇，相遇之处就是环的起点了。

#### 寻找链表的中点

​		类似上面的思路，我们还可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。

```
ListNode slow, fast;
slow = fast = head;
while (fast != null && fast.next != null) {
    fast = fast.next.next;
    slow = slow.next;
}
// slow 就在中间位置
return slow;
```

​		当链表的长度是奇数时，slow 恰巧停在中点位置；如果长度是偶数，slow 最终的位置是中间偏右：

![img](https://img2018.cnblogs.com/blog/1566782/201906/1566782-20190626075146010-1979098095.jpg)

​		寻找链表中点的一个重要作用是对链表进行归并排序。回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。但是现在你学会了找到链表的中点，就能实现链表的二分了。关于归并排序的具体内容本文就不具体展开了。

#### 寻找链表的倒数第 k 个元素

​		我们的思路还是使用快慢指针，让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点（为了简化，假设 k 不会超过链表长度）：

```
ListNode slow, fast;
slow = fast = head;
while (k-- > 0) 
    fast = fast.next;
 
while (fast != null) {
    slow = slow.next;
    fast = fast.next;
}
return slow;
```

### 左右指针的常用算法

​	左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1 。

#### 二分查找

​		前文 [二分查找算法详解](https://www.cnblogs.com/kyoner/p/11080078.html) 有详细讲解，这里只写最简单的二分算法，旨在突出它的双指针特性：

#### 两数之和

直接看一道 LeetCode 题目：

![img](https://img2018.cnblogs.com/blog/1566782/201906/1566782-20190626075621446-2077996103.jpg)

​		只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 可以调整 sum 的大小：

#### 反转数组

```
void reverse(int[] nums) {
    int left = 0;
    int right = nums.length - 1;
    while (left < right) {
        // swap(nums[left], nums[right])
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
        left++;
        right--;
    }
}
```



#### 回文判断

回文数的解决，最佳就是双指针法，链表也可以转为数组再做解决，代码：

```java
int front = 0;
int back = vals.size() - 1;
while (front < back) {
    if (!vals.get(front).equals(vals.get(back))) {
            return false;
        }	
        front++;
        back--;
}
return true;
```









## 算法案例

### 增







### 删

#### 剑指Offer-删除链表中重复的结点

在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5



解题思路

解法一，比较简单的思路是通过一个哈希表实现，但是无论是时间复杂度还是空间复杂度都很高

解法二，双指针，左右指针都往一个方向移动

![image-20200713220533566](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200713220533566.png)





解题实现

1）初始操作

```java
if(head==null || head.next==null) {
	return head;
}
ListNode dummy = new ListNode(-1);
dummy.next = head;
ListNode a = dummy;
ListNode b = head;

```



2）移动指针

```java
	  while(b!=null && b.next!=null) {
            //初始化的时a指向的是哑结点，所以比较逻辑应该是a的下一个节点和b的下一个节点
            if(a.next.val!=b.next.val) {
                a = a.next;
                b = b.next;
            }
            else {
                //如果a、b指向的节点值相等，就不断移动b，直到a、b指向的值不相等 
                while(b!=null && b.next!=null && a.next.val==b.next.val) {
                    b = b.next;
                }
                a.next = b.next;
                b = b.next;
            }
        }
        return dummy.next;

```







#### 删除排序链表中的重复元素

给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

```
输入: 1->1->2->3->3
输出: 1->2->3
```

解题思路

![image-20200713215545042](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200713215545042.png)

解题实现

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode cur=head;
        while(cur!=null&&cur.next!=null){
            if(cur.val==cur.next.val){
                cur.next=cur.next.next;
            }else{
                cur=cur.next;
            }
        }
        return head;
    }
}
```







#### 剑指 Offer -反转链表

输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

解题思路

这个解法有个口诀：TCPC

但是不建议使用，技巧灵活性较低，建议直接使用一个栈实现链表的反转

```java
	public ListNode reverseList(ListNode head) {
        Stack<Integer> stack=new Stack<>();
        ListNode cur=head;
        while(cur!=null){
            stack.push(cur.val);
            cur=cur.next;
        }
        ListNode dummy=new ListNode(-1);
        ListNode cur1=dummy;
        while(!stack.isEmpty()){
            cur1.next=new ListNode(stack.pop());
            cur1=cur1.next;
        }
        return dummy.next;
    }
```



#### 分隔链表

给定一个链表和一个特定值 *x*，对链表进行分隔，使得所有小于 *x* 的节点都在大于或等于 *x* 的节点之前。你应当保留两个分区中每个节点的初始相对位置。

![image-20200416135433040](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200416135433040.png)





解题思路

![微信图片_20200220211135.jpg](https://pic.leetcode-cn.com/d30d9910bcedf4b443b51debda2c585f48deeb8dffc6e067c01a8b6c1c2ec9e4-%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200220211135.jpg)

解题实现

1）分别新建小链表和大链表，并且用对应指针指向其头节点

```
ListNode Min=new ListNode(-1);
ListNode minP=Min;
ListNode Max=new ListNode(-1);
ListNode maxP=max;
```

2）当head不为空遍历（**用head遍历**）

​		3）判断当head的值较分隔值小，放入小指针的下一位，并小指针指向head，否则head的值较分隔值大，放入大指针的下一位，并大指针指向head

```
if(head.val<x){
	minP.next=head;
	minP=head;
}else{
	maxP.next=head;
	maxP=head;
}
```

​		4）head移向下一位

5）合并：大链表下一位为null，小指针的下一位为大链表的下一位

```
Max.next=null;
minP.next=Max.next;
```

6）返回小链表的下一位



#### 排序链表

在 *O*(*n* log *n*) 时间复杂度和常数级空间复杂度下，对链表进行排序。

![image-20200416152138067](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200416152138067.png)

解题思路

![image-20200416152450497](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200416152450497.png)

![image-20200416152504537](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200416152504537.png)

解题实现：

1）链表空值判定

2）新建快慢指针，快指针指向head的下一位，慢指针指向head

3）当快指针以及快指针的下一位不为空时循环

​		4）慢指针一次走一步，快指针一次走两步

```
slow=slow.next;
fast=fast.next.next;
```

5）分割：临时指针指向慢指针的下一位，慢指针的下一位置空

```
ListNode temp=slow.next;
slow.next=null;
```

6）对head递归，返回值为左节点，对临时指针递归，返回值为右节点

7）创建临时头h，临时指针res指向哑节点

8）合并：当左节点和右节点都不为空时循环

​		9）如果左值小于右值，临时头的下一位指向左节点，左节点后移一位，否则左值大于右值，临时头的下一位指向右节点，右节点后移一位。临时头后移一位

10）三目运算，左节点是否为空，如果不为空，临时头的下一位指向左节点，否则指向右节点。

11）返回临时指针res的下一位。







#### 求单链表中节点的个数

01.题目要求

- 求单链表中节点的个数

02.问题分析

- 注意检查链表是否为空。时间复杂度为O（n）。

03.实例代码

- 代码如下所示

  ```java
  public class LinkList {
      public Node head;
      public Node current;
      
      class Node {
          //注：此处的两个成员变量权限不能为private，因为private的权限是仅对本类访问。
          int data; //数据域
          Node next;//指针域
          public Node(int data) {
              this.data = data;
          }
      }
      
      //方法：向链表中添加数据
      public void add(int data) {
          //判断链表为空的时候
          if (head == null) {//如果头结点为空，说明这个链表还没有创建，那就把新的结点赋给头结点
              head = new Node(data);
              current = head;
          } else {
              //创建新的结点，放在当前节点的后面（把新的结点合链表进行关联）
              current.next = new Node(data);
              //把链表的当前索引向后移动一位
              current = current.next;   //此步操作完成之后，current结点指向新添加的那个结点
          }
      }
  
      //方法：获取单链表的长度
      public int getLength(Node head) {
          if (head == null) {
              return 0;
          }
  
          int length = 0;
          Node current = head;
          while (current != null) {
              length++;
              current = current.next;
          }
  
          return length;
      }
  }
  ```

- 测试代码

  ```java
  public void test() {
      LinkList list = new LinkList();
      //向LinkList中添加数据
      for (int i = 0; i < 10; i++) {
          list.add(i);
      }
      list.getLength(list.head);// 获取单链表的长度
  }
  ```







#### 删除链表的倒数第N个节点

01.题目要求

- 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

02.问题分析

2.1 一句话概括

- **示例：**

  ```
  给定一个链表: 1->2->3->4->5, 和 n = 2.
  当删除了倒数第二个节点后，链表变为 1->2->3->5.
  ```

- **说明：**

  - 给定的 n 保证是有效的。

- **进阶：**

  - 你能尝试使用一趟扫描实现吗？



2.2 解题思路

- 可以这样分析:
  - 注意到这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (L - n + 1)个结点，其中 L是列表的长度。只要我们找到列表的长度 L，这个问题就很容易解决。

03.实例代码

- **两次遍历法**

  - 首先将添加一个 **哑结点**作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 L。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n) 个结点那里。**我们把第 (L - n)个结点的 next 指针重新链接至第 (L - n + 2)个结点，完成这个算法。**

  ```java
  /**
   * Definition for singly-linked list.
   * public class ListNode {
   *     int val;
   *     ListNode next;
   *     ListNode(int x) { val = x; }
   * }
   */
  public class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
      // 哑结点，哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部
      ListNode dummy = new ListNode(0);
      // 哑结点指向头结点
      dummy.next = head;
      // 保存链表长度
      int length = 0;
      ListNode len = head;
      while (len != null) {
        length++;
        len = len.next;
      }
      length = length - n;
      ListNode target = dummy;
      // 找到 L-n 位置的节点
      while (length > 0) {
        target = target.next;
        length--;
      }
      // 把第 (L - n)个结点的 next 指针重新链接至第 (L - n + 2)个结点
      target.next = target.next.next;
      return dummy.next;
    }
  }
  ```

- **复杂度分析：**

  - **时间复杂度 O(L)** ：该算法对列表进行了两次遍历，首先计算了列表的长度 LL 其次找到第 (L - n)(L−n) 个结点。 操作执行了 2L-n2L−n 步，时间复杂度为 O(L)O(L)。
  - **空间复杂度 O(1)** ：我们只用了常量级的额外空间。 



04.一次遍历法

- **链表中倒数第N个节点也就是正数第(L-N+1)个节点。

  - 其实这种方法就和我们上面第四题找“链表中倒数第k个节点”所用的思想是一样的。**基本思路就是：**  定义两个节点 node1、node2;node1 节点先跑，node1节点 跑到第 n+1 个节点的时候,node2 节点开始跑.当node1 节点跑到最后一个节点时，node2 节点所在的位置就是第 （L-n ） 个节点（L代表总链表长度，也就是倒数第 n+1 个节点）

  ```
  /**
   * Definition for singly-linked list.
   * public class ListNode {
   *     int val;
   *     ListNode next;
   *     ListNode(int x) { val = x; }
   * }
   */
  public class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
      ListNode dummy = new ListNode(0);
      dummy.next = head;
      // 声明两个指向头结点的节点
      ListNode node1 = dummy, node2 = dummy;
  
      // node1 节点先跑，node1节点 跑到第 n 个节点的时候,node2 节点开始跑
      // 当node1 节点跑到最后一个节点时，node2 节点所在的位置就是第 （L-n ） 个节点，也就是倒数第 n+1（L代表总链表长度）
      while (node1 != null) {
        node1 = node1.next;
        if (n < 1 && node1 != null) {
          node2 = node2.next;
        }
        n--;
      }
  
      node2.next = node2.next.next;
      return dummy.next;
    }
  }
  ```

#### 







### 改

#### 剑指 Offer-复杂链表的复制

请实现函数ComplexListNode clone(ComplexListNode head),复制一个复杂链表。在复杂链表中，每个结点除了有一个next 域指向下一个结点外，还有一个sibling 指向链表中的任意结点或者null。

![image-20200416134827180](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200416134827180.png)















### 查

#### 剑指 Offer 22. 链表中倒数第k个节点

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。

```
给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.
```



解题思路

双指针法，两个指针相向移动







#### 剑指 Offer -从尾到头打印链表

从尾到头反过来返回每个节点的值（用数组返回）。



解题思路

本题有递归法、辅助栈法两种思路

![image-20200724180320839](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200724180320839.png)



辅助栈法

![image-20200724180702669](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200724180702669.png)

解题实现

递归法（推荐使用）

```java
class Solution {
    //全局列表
    List<Integer> list = new ArrayList<Integer>();
    public int[] reversePrint(ListNode head) {
        //直接对链表递归
        recur(head);
        //新建数组，并将递归后的列表的值给数组，返回数组
        int[] res = new int[list.size()];
        for(int i = 0; i < res.length; i++)
            res[i] = list.get(i);
        return res;
    }
    void recur(ListNode head) {
        //终止条件
        if(head == null) return;
        //先递归到最后
        recur(head.next);
        //再回溯到头部
        list.add(head.val);
    }
}
```







### 双链表问题

#### 剑指Offer-判断两个单链表相交的第一个交点（相交链表）

输入两个链表，找出它们的第一个公共节点。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)



解题思路

![image-20200720213531094](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200720213531094.png)





解题实现

基于双指针法

1）新建指针A，B指向两个链表的头节点A和头节点B

2）while循环 当指针A不等于指针B时循环

​		3）三目表达式：当指针A为空时，指针A指向头节点B，否则指针A往后移一位，当指针B为空时，指针B指向头节点A，否则指针B往后移一位

4）返回指针A

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
		//空值判定
        if (headA == null || headB == null) return null;
    	//定义指针 A,B
        ListNode A = headA, B = headB;
        while (A != B) {
            A = A == null ? headB : A.next;
            B = B == null ? headA : B.next;
        }
        return A;
    }
```







#### 合并两个排序的链表

01.题目要求

输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

```
链表1：1->2->3->4
链表2：2->3->4->5
合并后：1->2->2->3->3->4->4->5
```



解题思路

- 分析

  ```
  1.假设我们有两个链表 A,B；
  2.A的头节点A1的值与B的头结点B1的值比较，假设A1小，则A1为头节点；
  3.A2再和B1比较，假设B1小,则，A1指向B1；
  4.A2再和B2比较。。。。。。。
  就这样循环往复就行了，应该还算好理解。
  ```

- 需要注意

  - 尤其要注意两个链表都为空、和其中一个为空的情况。

1）不讨论链表空的情况，定义哑节点，并定义临时指针cur指向哑节点

2）当链表1和链表2均非空时循环

```
if(l1!=null&&l2!=null)
```

​	3）当链表1的值小于链表2时，cur下一位指向链表1，链表1往后移位

```
cur.next=l1;
l1=l1.next;
```

​	4）否则

​       cur下一位指向链表2，链表2往后移位			

```
cur.next=l2;
l2=l2.next;
```

​	5）cur往后移位

6）cur下一位指向链表1，并判断是否空，不为空则返回链表1，否则返回链表2

```
cur.next=l1!=null?l1:l2;
```

7）返回哑节点的下一位





####  合并K个排序链表

合并 *k* 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

![image-20200416131734709](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200416131734709.png)



解题思路

分而治之，链表两两合并，再整体合并

解题实现

1）总列表判空

```
if(lists==null||lists.length==0) return null;
```

2）调用主递归函数，传入参数为列表，左右位置值

​	3）终止条件：当左右位置相等时，返回总列表的第一个值

```
if(left==right) return lists[left];
```

​	4）求得二分的中心位置

```
int mid=left+(right-left)/2;
```

​	5）分别对左右区域的进行分治递归，返回值分别为链表1和链表2，返回值为对链表1和链表2调用双链表合并递归函数（与常规合并一致）

```
ListNode l1=merge(lists,left,mid);
ListNode l2=merge(lists,mid+1,right);
```

​			6）当l1为空，返回l2，反正l2为空，返回l1

```
if(l1==null) return l2;
if(l2==null) return l1;
```

​			7）l1的值小于l2，对l1的下一个位和l2调用合并递归函数，返回值为l1的下一位，返回l1。否则对l2的下一个位和l1调用合并递归函数，返回值为l2的下一位，返回l2(next都在一边)

```
if(l1.val<l2.val){
	l1.next=mergeTwoLists(l1.next,l2);
	return l1;
}else{
	l2.next=mergeTwoLists(l1,l2.next);
	return l2;
}
```













#### 双链表求和

给定两个用链表表示的整数，每个节点包含一个数位。

这些数位是反向存放的，也就是个位排在链表首部。

编写函数对这两个整数求和，并用链表形式返回结果。

![image-20200416143853138](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200416143853138.png)

解題思路

链表左对齐，从左到右，对位相加。当有进位时，就是大于等于10，下一次对位需要++

解题实现

1）新建返回值头节点head和指针result指向head，初始进位判断preFlag为false；

2）当链表1非空，链表2非空和进位判断 “或” 关系为真时循环

```
while(l1!=null||l2!=null||preFlag){
}
```

​		3）计算临时值temp，链表1,2的节点值如果有则取，无则为0

```
int temp=(l1==null?0:l1.val)+(l2==null?0:l2.val);
```

​		4）解决进位问题，判断preFlag是否为真，临时值还得加1，如果**temp大于等于10**，preFlag设置为真，否则为假

```
if(preFlag){
	temp++;
}
if(temp>10){
	preFlag=true;
}else{
	preFlag=false;
}
```

​		5）指针result的下一位指向值为temp%10的新节点，result向后移位

```
result.next=new ListNode(temp%10);
result=result.next;
```

​		6）判断，如果链表1和链表2不为空，则向都后移一位

```
if(l1!=null){
	l1=l1.next;
}
if(l2!=null){
	l2=l2.next;
}
```

7）返回头节点的下一位









### 链环问题

#### 剑指Offer-链表中环的入口结点

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200416123657544.png" alt="image-20200416123657544" style="zoom: 80%;" />

解题思路

哈希表法，与环形链表I的区别在于，找到环后，直接返回当前节点即可。return node;



双指针法 

![image-20200714210425925](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200714210425925.png)



解题实现

双指针法 

```java
public class Solution {
 
    ListNode EntryNodeOfLoop(ListNode pHead){
        if(pHead == null || pHead.next == null)
            return null;
        ListNode slow = pHead;
        ListNode fast = pHead;
        while(p2 != null && p2.next != null ){
            slow = slow.next;
            fast = fast.next.next;
            if(slow == fast){
                fast = pHead;
                while(slow != fast){
                    slow = slow.next;
                    fast = fast.next;
                }
                if(slow == fast)
                    return slow;
            }
        }
        return null;
    }
}
```









#### 环形链表  判断单链表是否有环

​		这里也是用到两个指针，如果一个链表有环，那么用一个指针去遍历，是永远走不到头的。

解题思路

1 哈希表法：

我们可以通过检查一个结点此前是否被访问过来判断链表是否为环形链表。常用的方法是使用哈希表。我们遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。如果当前结点为空结点 null（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。如果当前结点的引用已经存在于哈希表中，那么返回 true（即该链表为环形链表）。

2 双指针法 

first指针每次走一步，second指针每次走两步，如果first指针和second指针相遇，说明有环。时间复杂度为O (n)。





解题实现

1）新建哈希表

2）循环遍历

​	3）如果哈希表已有该节点，返回真

```java
if(nodeSet.contains(head)){
	return true;
}
```

​	4）否则添加到表中

​	5）往后移位哈希表中

6）如果都没有，就返回假



```
public class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> set=new HashSet<>();
        ListNode cur=head;
        while(cur!=null){
            if(set.contains(cur)){
                return true;
            }
            set.add(cur);
            cur=cur.next;
        }
        return false;
    }
}
```









#### 取出有环链表中环的长度

01.题目要求

如下所示
- ![image](https://upload-images.jianshu.io/upload_images/4432347-ee0679b2231e7a41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- ![image](https://upload-images.jianshu.io/upload_images/4432347-febce3db59ff184a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



02.问题分析

​		这里面，我们需要先判断链表是否有环，这个方法的返回值是boolean型，但是现在要把这个方法稍做修改，让其返回值为相遇的那个结点。然后，我们拿到这个相遇的结点就好办了，这个结点肯定是在环里嘛，我们可以让这个结点对应的指针一直往下走，直到它回到原点，就可以算出环的长度了。



解题思路

​		





















#### 约瑟夫问题

问题描述：有N个人围成一圈做游戏，编号为1->2->3->...->1,让第m个人开始报数，报到底k个数的那个人出队，出队的下一个人继续报数，报到第k个数的人再出队。。。以此类推，求出最后一个出队的人。

Josephu问题为：设编号为1,2…n的n个人围坐一圈，约定编号为k（l<=k<=n)的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。

josephu问题解析

 解决思路：这个问题可以转化成数据结构的循环链表问题。具体抽象为创建循环链表，输出链表，按照题意找到符合要求的那个结点并删除，循环删除的过程，直到循环链表只剩下一个元素，即为最后一个出队的元素。







#### 解题经验

计算链表长度

```java
// 计算链表长度
ListNode first = head;
while (first != null) {
    first = first.next;
    l++;
}
```

##### 哑节点法

方法概述：哑结点作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。

典型用法：

```java
//定义哑节点
ListNode dummy = new ListNode(0);
dummy.next = head;
```

##### 

##### 哈希集合法

方法概述：遍历链表并将每个结点的地址/引用存储在哈希表中，可用于解决判断链表中是否有重复元素的问题。

典型用法：判断两个链表是否相交

```java
Set<ListNode> nodes = new HashSet<>();
ListNode cur1 = headA;
while (cur1 != null) {
    nodes.add(cur1);
    cur1 = cur1.next;
}
ListNode cur2 = headB;
while (cur2 != null) {
    if (nodes.contains(cur2)) {
        return cur2;
    }
    cur2 = cur2.next;
}
return null;
```



##### 双指针法

方法概述：定义两个指针，利用这两个指针的空间位置，来解决一些问题。

##### 新链表法

方法概述：新建一支链表，解决一些链表新增和删除的问题。



注意：

1.遍历链表时的两种while

```java
while (cur != null) 与 while (cur.next != null)
```

前者执行最后一位，后者不执行最后一位。

2.删除某个节点的时候需要单独判断是否为头节点

3.插入一个位置的时候要判断输入的位置是否正确。





## 跳跃表 专题

### 概述

Skip list是一个“概率型”的数据结构，可以在很多应用场景中替代平衡树。Skip list算法与平衡树相比，有相似的渐进期望时间边界，但是它更简单，更快，使用更少的空间。 

Skip list是一个分层结构多级链表，最下层是原始的链表，每个层级都是下一个层级的“高速跑道”。

![image-20200703194233923](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200703194233923.png)

#### 链表到跳跃表 的演化

对于下面这个链表

![img](http://5b0988e595225.cdn.sohucs.com/images/20190204/3338f3e0baa64ea09f6a1cca02bfc1d4.png)

假如我们要查找元素9，按道理我们需要从头结点开始遍历，一共遍历8个结点才能找到元素9。能否采取某些策略，让我们遍历5次以内就找到元素9呢？请大家花一分钟时间想一下如何实现？

由于元素的有序的，我们是可以通过增加一些路径来加快查找速度的。例如

![img](http://5b0988e595225.cdn.sohucs.com/images/20190204/2412bdd7b3644dad8e4b83a36fff799e.png)

通过这种方法，我们只需要遍历5次就可以找到元素9了（红色的线为查找路径）。

![img](http://5b0988e595225.cdn.sohucs.com/images/20190204/132ce5e7660240b39336ecbea55e18cd.png)

还能继续加快查找速度吗？

答是可以的，再增加一层就行了，这样只需要4次就能找到了，这就如同我们搭地铁的时候，去某个站点时，有快线和慢线几种路线，通过快线 + 慢线的搭配，我们可以更快着到达某个站点。

![img](http://5b0988e595225.cdn.sohucs.com/images/20190204/f8d9d4caa29d4320b09a194260365f7a.png)

当然，还能在增加一层，

![img](http://5b0988e595225.cdn.sohucs.com/images/20190204/ab38e55851b64dffbfa590db3624d89a.png)

基于这种方法，对于具有 n 个元素的链表，我们可以采取 ** (logn + 1) 层指针路径的形式**，**就可以实现在 O(logn) 的时间复杂度内，查找到某个目标元素了，这种数据结构，我们也称之为跳跃表**，**跳跃表也可以算是链表的一种变形，只是它具有二分查找的功能。



跳跃表的性能

跳表的查询复杂度是O(lgn),仅插入或删除的复杂度是O(1),但是插入、删除之前需要先查询位置，所以还是O(lgn）



#### 跳跃表的有关性质

(1). 跳跃表的每一层都是一条**有序的链表**.

(2). 跳跃表的查找次数近似于层数，时间复杂度为O(logn)，插入、删除也为 O(logn)。

(3). 最底层的链表包含所有元素。

(4). 跳跃表是一种随机化的数据结构(通过抛硬币来决定层数)。

(5). 跳跃表的空间复杂度为 O(n)。

空间换时间，达到更好的性能



#### 跳跃表 和二叉搜索树和红黑树

跳跃表 vs 二叉查找树

```
有人可能会说，也可以采用二叉查找树啊，因为查找查找树的插入、删除、查找也是近似 O(logn) 的时间复杂度。

不过，二叉查找树是有可能出现一种极端的情况的，就是如果插入的数据刚好一直有序，那么所有节点会偏向某一边。例如
```

<img src="http://5b0988e595225.cdn.sohucs.com/images/20190204/2f2d61b898b44b6e961f92a489d29bb5.png" alt="img" style="zoom:67%;" />

这种接结构会导致二叉查找树的查找效率变为 O(n),这会使二叉查找树大打折扣。

跳跃表 vs 红黑树

```
红黑可以说是二叉查找树的一种变形，红黑在查找，插入，删除也是近似O(logn)的时间复杂度，但学过红黑树的都知道，红黑树比跳跃表复杂多了，反正我是被红黑树虐过。在选择一种数据结构时，有时候也是需要考虑学习成本的。

而且红黑树插入，删除结点时，是通过调整结构来保持红黑树的平衡，比起跳跃表直接通过一个随机数来决定跨越几层，在时间复杂度的花销上是要高于跳跃表的。

当然，红黑树并不是一定比跳跃表差，在有些场合红黑树会是更好的选择，所以选择一种数据结构，关键还得看场合。
```



#### 跳跃表的应用

维护一组有序的集合，并且希望在查找、插入、删除等操作上尽可能快，那么跳跃表会是不错的选择。redis 中的数据数据便是采用了跳跃表，当然，ridis也结合了哈希表等数据结构，采用的是一种复合数据结构。







#### 设计跳表

不使用任何库函数，设计一个跳表。

跳表是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。

例如，一个跳表包含 [30, 40, 50, 60, 70, 90]，然后增加 80、45 到跳表中，以下图的方式操作：

![image-20200703195450719](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200703195450719.png)

跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。

```
Skiplist skiplist = new Skiplist();

skiplist.add(1);
skiplist.add(2);
skiplist.add(3);
skiplist.search(0);   // 返回 false
skiplist.add(4);
skiplist.search(1);   // 返回 true
skiplist.erase(0);    // 返回 false，0 不在跳表中
skiplist.erase(1);    // 返回 true
skiplist.search(1);   // 返回 false，1 已被擦除
```





























































