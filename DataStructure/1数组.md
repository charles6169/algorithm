

# 数组

## 概述

### 数组的优缺点

- 数组作为数据存储结构有一定的缺陷。
  - 在无序数组中，搜索性能差，在有序数组中，插入效率又很低，而且这两种数组的删除效率都很低，并且数组在创建后，其大小是固定了，设置的过大会造成内存的浪费，过小又不能满足数据量的存储。



### 数组使用场景

- 数组是一种通用的数据结构，能用来实现栈、队列等很多数据结构。



二维数组



稀疏数组

​		当一个数组中大部分元素为同一个值时可以使用稀疏数组来存该数组

树状数组

​		顾名思义，就是用数组来模拟树形结构呗。那么衍生出一个问题，为什么不直接建树？答案是没必要，因为树状数组能处理的问题就没必要建树。和Trie树的构造方式有类似之处。



### 数组常用的技巧



#### 列表与数组互转

```java
 // int[] 转 List<Integer>
 List<Integer> list1 = Arrays.stream(data).boxed().collect(Collectors.toList());
 // Arrays.stream(arr) 可以替换成IntStream.of(arr)。
 // 1.使用Arrays.stream将int[]转换成IntStream。
 // 2.使用IntStream中的boxed()装箱。将IntStream转换成Stream<Integer>。
 // 3.使用Stream的collect()，将Stream<T>转换成List<T>，因此正是List<Integer>。

// List<Integer> 转 int[]
int[] arr1 = list1.stream().mapToInt(Integer::valueOf).toArray();
// 想要转换成int[]类型，就得先转成IntStream。
// 这里就通过mapToInt()把Stream<Integer>调用Integer::valueOf来转成IntStream
// 而IntStream中默认toArray()转成int[]。

// int[] 转 Integer[]
Integer[] integers1 = Arrays.stream(data).boxed().toArray(Integer[]::new);
// 前两步同上，此时是Stream<Integer>。
// 然后使用Stream的toArray，传入IntFunction<A[]> generator。
// 这样就可以返回Integer数组。
// 不然默认是Object[]。

// List<Integer> 转 Integer[]
Integer[] integers2 = list1.toArray(new Integer[0]);
//  调用toArray。传入参数T[] a。这种用法是目前推荐的。
// List<String>转String[]也同理。

// Integer[] 转 int[]
int[] arr2 = Arrays.stream(integers1).mapToInt(Integer::valueOf).toArray();
// 思路同上。先将Integer[]转成Stream<Integer>，再转成IntStream。

// Integer[] 转 List<Integer>
List<Integer> list2 = Arrays.asList(integers1);
// 最简单的方式。String[]转List<String>也同理。

// 同理
String[] strings1 = {"a", "b", "c"};
// String[] 转 List<String>
List<String> list3 = Arrays.asList(strings1);
// List<String> 转 String[]
String[] strings2 = list3.toArray(new String[0]);
```



#### 双指针（见链表）





#### 取数字的各个位数

charAt(?)可以控制取数字的第几位

```
int n = 1234;
String s = String.valueOf(n);
int m = s.charAt(0) - '0';
```







## 算法案例



####  剑指 Offer -数组中重复的数字

在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

解题思路

本题可以用哈希集合做，一般推荐使用数位数组解决



解题实现

```java
  public boolean duplicate(int numbers[], int length, int[] duplication) {
      	//建立数位数组
        boolean[] k = new boolean[length];
        for (int i = 0; i < k.length; i++) {
            if (k[numbers[i]] == true) {
                duplication[0] = numbers[i];
                return true;
            }
            k[numbers[i]] = true;
        }
        return false;
    }
```









#### 剑指 Offer 66. 构建乘积数组

给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。

```
输入: [1,2,3,4,5]
输出: [120,60,40,30,24]
```



解题思路

![image-20200714221456704](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200714221456704.png)

![image-20200714221510214](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200714221510214.png)



解题实现

1）新建左右数组，填充为1 ，分别从左右遍历，填充左右数组

2）左右数组对位相乘即可









#### 剑指 Offer- 扑克牌顺子

从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。



解题思路

此 5 张牌是顺子的 **充分条件** 如下：

```
1 除大小王外，所有牌 无重复 ；
2 设此 55 张牌中最大的牌为 maxmax ，最小的牌为 minmin （大小王除外），则需满足：
max - min < 5
```

![image-20200716213405711](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200716213405711.png)

有两种解法：

1 集合 Set + 遍历

![image-20200716213444868](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200716213444868.png)

2 排序 + 遍历

![image-20200716213500903](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200716213500903.png)



解题实现

（排序 + 遍历）

1）初始化索引 index 为 0

2）数组排序

3）遍历，如果有大小王，索引增加，如果有重复，直接返回

4）以最大减最小，若小于5则成为顺子

```java
class Solution {
    public boolean isStraight(int[] nums) {
        int index = 0;
        Arrays.sort(nums); // 数组排序
        for(int i = 0; i < 4; i++) {
            if(nums[i] == 0) index++; // 统计大小王数量
            else if(nums[i] == nums[i + 1]) return false; // 若有重复，提前返回 false
        }
        return nums[4] - nums[index] < 5; // 最大牌 - 最小牌 < 5 则可构成顺子
    }
}
```









#### 剑指 Offer- 把数组排成最小的数

输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

```
输入: [3,30,34,5,9]
输出: "3033459"
```



**解题思路**

![image-20200720220907458](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200720220907458.png)

![image-20200720220926885](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200720220926885.png)



解题实现

1）新建存数字符串数组

2）遍历数组，将数组的每一个转字符串再放入字符串数组

3）快速排序

4）StringBuilder类型返回值

5）遍历字符串数组，将其组合入返回值

6）再次转换 ，返回String类型返回值





#### 从数组中删除重复项

01.题目要求

- 问题如下所示：
  - 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
  - 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。



02.问题分析

- 示例 1:

  ```
  给定数组 nums = [1,1,2], 
  函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
  你不需要考虑数组中超出新长度后面的元素。
  ```

- 示例 2:

  ```
  给定 nums = [0,0,1,1,1,2,2,3,3,4],
  函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
  你不需要考虑数组中超出新长度后面的元素。
  ```

​	首先做空值判断

​	初始化currentV为首值，遍历数组

​	如果与currentV不等，替换currentV，并且新值放入新建数组



解题实现：

1）数组空值判定

2）初始化指针为第0项，count为0

3）从第1项开始遍历数组

4）如果数组值与currentV不等，count++，数组值替换currentV，并且currentV放入新建数组count位（理解为如果重复元素则直接跳过了）

```
if(num[i]!=currentV){
	count++;
	currentV=num[i];
	num[count]=currentV;
}
```

5）返回值为count+1





#### 合并两个有序数组

给你两个有序整数数组 *nums1* 和 *nums2*，请你将 *nums2* 合并到 *nums1* 中*，*使 *nums1* 成为一个有序数组。

```
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```



















#### 啤酒与饮料

01.题目要求

- 问题如下所示：
  - 啤酒每罐2.3元，饮料每罐1.9元。小明买了若干啤酒和饮料，一共花了82.3元。我们还知道他买的啤酒比饮料的数量少，请你计算他买了几罐啤酒。

02.问题分析

- 思路：
  - 使用暴力搜索即可解出：
  - 如果82.3全买啤酒最多能买82.3/2.3=35瓶
  - 如果82.3全买饮料最多能买82.3/1.9=43瓶
  - 以此作为控制条件



解题实现

1）计算边界值，题中为36和44

2）两层循环遍历

​		3）判断条件：总值为消费额，且满足啤酒比饮料的数量少

```
if(2.3*i+j*1.9==82.3&&i<j){
	i,j;
}
```







#### 网易2020校招笔试-翻倍

![image-20200707212804907](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200707212804907.png)

```
in
2
1 5 7 2
3 5 1 2
out
1
2
```

解题思路

这题由于q限定了大于等于2，所以不必考虑到底是直接加还是乘了加哪个快，直接先比较A+p是否大于等于B，若大于等于那就结束，否则就p=p*q，然后循环。 

  要注意的是B的范围大于了Int的范围，所以用long类型来解决。



解题实现

1）读取数据，在while循环内执行操作

2）读取A,B,p,q

3）while循环，判断

```
if A+p<B  p*=q
else      A+=p
```

4）退出循环后输出





#### 招商银行信用卡中心2019秋招IT笔试-鸡鸭分类问题

农场有n只鸡鸭排为一个队伍，鸡用“C”表示，鸭用“D”表示。当鸡鸭挨着时会产生矛盾。需要对所排的队伍进行调整，使鸡鸭各在一边。每次调整只能让相邻的鸡和鸭交换位置，现在需要尽快完成队伍调整，你需要计算出最少需要调整多少次可以让上述情况最少。例如：CCDCC->CCCDC->CCCCD这样就能使之前的两处鸡鸭相邻变为一处鸡鸭相邻，需要调整队形两次。

```
in
输入一个长度为N，且只包含C和D的非空字符串。
CCDCC
out
使得最后仅有一对鸡鸭相邻，最少的交换次数
2
```



解题思路

![image-20200708212738914](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200708212738914.png)



解题实现

```java
public class Main {
 
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.next();
        //比较移鸡和鸭所需的动作，取其小值
        System.out.println(Math.min(move(s,'C'), move(s,'D'))); 
    }
 
    static int move(String s, char c){
        int count=0;  //左边已有多少只鸡
        int res=0; //需要移动的次数
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i)==c){
                //若某鸡的下标为i  其左边还有count只鸡  则最少需要i - count次才能将其移到左鸡堆的最右边
                res+=i-count;
                count++;
            }
        }
        return res;
    }
}
```





### 次数问题







#### 1～n整数中1出现的次数

输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。

例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。

![image-20200427112140834](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200427112140834.png)



**解题思路**

![image-20200427112731312](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200427112731312.png)

**解题实现**

1）主函数直接调用递归函数

​    2）如果n小于等于0，直接返回0

​	3）数字先转为字符串格式

​	4）获取最高位，获取位数整数，获取后续几位（关键）

```
int high=s.charAt(0)-'0';
int pow=(int)Math.pow(10,s.length()-1);
int last=n-high*pow;
```

​	5）当最高位为1时，递归执行关系式1，否则执行关系式2（关键）

```
if(high==1){
	return f(pow-1)+last+1+f(fast);
}else{
	return pow+high*f(pow-1)+f(fast);
}
```





#### 好数对的数目

给你一个整数数组 nums 。

如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i < j ，就可以认为这是一组 好数对 。

返回好数对的数目。

```
输入：nums = [1,2,3,1,1,3]
输出：4
解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始
```

解题思路

用一个次数数组解决这类重复性问题

解题实现

```java
public int numIdenticalPairs(int[] nums) {
        int[] count = new int[101];
        int total = 0;
        for(int d : nums) {
            //统计次数数组
            ++count[d];
            //在后一位的数字 统计好数对
            total += count[d] - 1;
        }
        return total;
    }
```





#### 数组中数字出现的次数

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

![image-20200427120330881](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200427120330881.png)

**解题思路**

排序/HashSet/异或都可以实现	只有异或方法满足时间O(n), 空间O(1)。排序法和`HashSet`并**不符合**题目复杂度的要求

 ![image-20200427124411592](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200427124411592.png)

**解题实现**

1）初始化数组异或值为数组第一位元素

2）遍历数组，相邻各位树做异或判定，得到运算后的数组异或值

```
for(int i=1;i<nums.length;i++){
	xor^=nums[i];
}
```

3）利用与运算，计算最低位的1的位置的数（如十进制数10，转二进制为1010，其最低位数就是10，也就是2）

```
int onePosition=xor&(-xor);
```

4）初始化两个返回结果数

5）再次遍历数组，用与条件将数组划分为两个数组，其中一组的最低位的1的位置的数与之前求得的位置数一致，另一组不一致。并且还对两组数组都做异或判定

```
for(int j=0;j<nums.length;j++){
	if((nums[j]&onePosition)==onePosition){
		ans1^=nums[j];
	}else{
		ans2^=nums[j];
	}
}
```

6）返回新建数组















#### 调整数组顺序

01.题目要求

- 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

02.问题分析

- 我们首先统计奇数的个数假设为n,然后新建一个等长数组，然后通过循环判断原数组中的元素为偶数还是奇数。如果是则从数组下标0的元素开始，把该奇数添加到新数组；如果是偶数则从数组下标为n的元素开始把该偶数添加到新数组中。

解题思路

![image-20200415143742605](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200415143742605.png)

![image-20200415143756466](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200415143756466.png)



解题实现

1）初始化左右指针分别为左右端位置，临时指针

2）当i小于j时循环

​		3）当i小于j且数组值为奇数时，左指针循环右移，当i小于j且数组值为偶数时，右指针循环左移

​		4）i,j位换位

5）返回数组



#### 旋转数组

给定一个数组，将数组中的元素向右移动 *k* 个位置，其中 *k* 是非负数。

![image-20200415153649819](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200415153649819.png)

解题思路

最简单的方法是旋转 k 次，每次将数组旋转 1 个元素。

解题实现

1）初始化临时值和动态指针previous

2）遍历i 从0到k

​	3）动态指针预设为数组的最后一个值

​	4）遍历j从0到数组长度

​			5）将第j位的值与动态指针互换

```
temp=nums[j];
nums[j]=previous
previous=temp;
```











#### 按既定顺序创建目标数组

给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组：

目标数组 target 最初为空。
按从左到右的顺序依次读取 nums[i] 和 index[i]，在 target 数组中的下标 index[i] 处插入值 nums[i] 。
重复上一步，直到在 nums 和 index 中都没有要读取的元素。
请你返回目标数组。

题目保证数字插入位置总是存在。

```
输入：nums = [0,1,2,3,4], index = [0,1,2,2,1]
输出：[0,4,1,3,2]
解释：
nums       index     target
0            0        [0]
1            1        [0,1]
2            2        [0,1,2]
3            2        [0,1,3,2]
4            1        [0,4,1,3,2]
```

解题思路

![image-20200415144548146](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200415144548146.png)

借助ArrayList实现

解题实现

1）新建一个列表

2）循环遍历，在列表的第index[i]位插入nums[i]

```
for(int i=0;i<nums.length;i++){
	list.add(index[i],nums[i]);
}
```

3）将列表转回数组返回

```
int[] res=
list.stream().mapToInt(Integer::valueOf).toArray();
```





#### 非递增顺序的最小子序列

给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。

如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。

与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。

注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。

![image-20200415150453840](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200415150453840.png)

解题思路

![image-20200415151126146](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200415151126146.png)

解题实现

1）新建返回值列表，取出数组的长度，初始化返回数组总和sum为0

2）对数组升序排序

3）从最后一位往前遍历，i从len-1到0

```
for(int i=len-1;i>=0;i--){
}
```

​	4）初始化临时总和为0

​	5）返回数组总和叠加当前数组值

​	6）当前值加入列表中

​	7）剩余的值累加求和到临时总和，j从i-1到0

```
for(int j=i-1;j>=0;j--){
	temp+=nums[i];
}
```

​	8）判断返回数组总和是否大于等于临时总和

​			9）如果数组总和等于临时总和，返回值列表再加上当前值的前一位值，并且数组总和累加，如果数组总和大于临时总和，返回列表。

```
if(sum==temp){
	list.add(nums[i-1]);
	sum+=num[i-1];
}
if(sum>temp){
	return list;
}
```

10）返回列表







#### 找出常用的数字

01.题目要求

- 问题如下所示：
  - 给你一个长度为n的数组，其中有一个数字出现的次数至少为n/2，找出这个数字
  - 注意，需要的是排序的数组

02.问题分析

- 使用栈的思想来做

  - 如果栈是空的，那么先把数据存进去
  - 然后继续遍历其他的数据，只要发现栈中的数据和遍历中的数据不一样，那么就出栈
  - 如果是相同的，那么就入栈
  - 其实就是捉住数字出现的次数多于数组一半的长度这里入手。如果这个数出现的次数是大于这个数组长度的2/1，那么最后留下的肯定是这个数

- 示例 1:

  ```
  输入: [1,1,1,2,5,7,8,8,8,8,10]
  输出: 8
  ```

03.实例代码

- 如下所示

  ```java
  int removeDuplicates(int[] num) {
      if (num==null || num.length==0){
          return 0;
      }
      int currentV = num[0];
      int count = 0;
      for(int i = 1 ; i < num.length; i++){
          if(num[i] != currentV){
              count++;
              currentV = num[i];
              num[count] = currentV;
          }
      }
      return count+1;
  }
  ```



04.如何优化

- 其实没必要用整个栈来装载数组，因为使用栈顶元素(出现次数最多的那个),而栈的大小也可以通过一个变量就可以来确定了
- 只要元素相同->入栈(长度+1)。元素不相同-->出栈(长度-1)
- 最终留下来的肯定是出现最频繁的那个数字!



05.优化代码

- 如下所示

  ```java
  public int findMajorityElement2(int[] arrays) {
      if (arrays==null || arrays.length==0){
          return 0;
      }
      // 装载栈的元素
      int candidate = -1;
      // 栈的大小(长度)
      int count = 0;
      // 遍历给出的数组
      for (int i = 0; i < arrays.length; i++) {
          // 判断该栈为空，那么直接将元素入栈
          if (count == 0) {
              candidate = arrays[i];
              count++;
          } else if (candidate == arrays[i]) {
              // 该元素是否与栈的元素一致-->入栈(栈多一个元素)
              count++;
          } else {
              // 只要不一致-->出栈(栈少一个元素)
              count--;
          }
      }
      // 只要该数字出现次数大于数组长度的2/1，那么留下来的数字肯定在栈顶中
      return candidate;
  }
  ```











#### 旋转数组的最小数字

01.题目要求

- 问题如下所示：
  - 把一个数组最开始的若干个元素搬到数组的末尾， 我们称之数组的旋转。输入一个递增排序的数组的一个旋转， 输出旋转数组的最小元素。例如数组{3,4,5,1,2 ｝为｛ 1,2,3,4,5}的一个旋转，该数组的最小值为1。



02.问题分析

- **Step1.**和二分查找法一样，我们用两个指针分别指向数组的第一个元素和最后一个元素。
- **Step2.**接着我们可以找到数组中间的元素：
  - 如果该中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。此时数组中最小的元素应该位于该中间元素的后面。我们可以把第一个指针指向该中间元素，这样可以缩小寻找的范围。如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时该数组中最小的元素应该位于该中间元素的前面。
- **Step3.**接下来我们再用更新之后的两个指针，重复做新一轮的查找。



03.实例代码

- 如下所示

  ```
  public class Test {  
    
      /** 
       * @param numbers 旋转数组 
       * @return 数组的最小值 
       */  
      public static int min(int[] numbers) {  
          // 判断输入是否合法  
          if (numbers == null || numbers.length == 0) {  
              throw new RuntimeException("Invalid input.");  
          }  
    
          // 开始处理的第一个位置  
          int lo = 0;  
          // 开始处理的最后一个位置  
          int hi = numbers.length - 1;  
          // 设置初始值  
          int mi = lo;  
    
          // 确保lo在前一个排好序的部分，hi在排好序的后一个部分  
          while (numbers[lo] >= numbers[hi]) {  
              // 当处理范围只有两个数据时，返回后一个结果  
              // 因为numbers[lo] >= numbers[hi]总是成立，后一个结果对应的是最小的值  
              if (hi - lo == 1) {  
                  return numbers[hi];  
              }  
    
              // 取中间的位置  
              mi = lo + (hi - lo) / 2;  
    
              // 如果三个数都相等，则需要进行顺序处理，从头到尾找最小的值  
              if (numbers[mi] == numbers[lo] && numbers[hi] == numbers[mi]) {  
                  return minInorder(numbers, lo, hi);  
              }  
    
              // 如果中间位置对应的值在前一个排好序的部分，将lo设置为新的处理位置  
              if (numbers[mi] >= numbers[lo]) {  
                  lo = mi;  
              }  
              // 如果中间位置对应的值在后一个排好序的部分，将hi设置为新的处理位置  
              else if (numbers[mi] <= numbers[hi]) {  
                  hi = mi;  
              }  
          }  
    
          // 返回最终的处理结果  
          return numbers[mi];  
      }  
    
      /** 
       * 找数组中的最小值 
       * 
       * @param numbers 数组 
       * @param start   数组的起始位置 
       * @param end     数组的结束位置 
       * @return 找到的最小的数 
       */  
      public static int minInorder(int[] numbers, int start, int end) {  
          int result = numbers[start];  
          for (int i = start + 1; i <= end; i++) {  
              if (result > numbers[i]) {  
                  result = numbers[i];  
              }  
          }  
          return result;  
      }    
  }  
  ```









#### 调整数组顺序使奇数位于偶数前面

01.题目要求

- 问题如下所示：

  - 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位予数组的后半部分。

- 示例 :

  ```
  
  ```



02.问题分析

- 这个题目要求把奇数放在数组的前半部分，偶数放在数组的后半部分，因此所有的奇数应该位于偶数的前面。也就是说我们在扫描这个数组的时候， 如果发现有偶数出现在奇数的前面，我们可以交换它们的顺序，交换之后就符合要求了。
- 因此我们可以维护两个指针，第一个指针初始化时指向数组的第一个数字，它只向后移动：第二个指针初始化时指向数组的最后一个数字， 它只向前移动。在两个指针相遇之前，第一个指针总是位于第二个指针的前面。如果第一个指针指向的数字是偶数，并且第二个指针指向的数字是奇数，我们就交换这两个数字。

03.实例代码

- 如下所示

  ```
  public class Test {
  
      /**
       * 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，
       * 使得所有奇数位于数组的前半部分，所有偶数位予数组的后半部分。
       *
       * @param arr 输入的数组
       */
      public static void reorderOddEven(int[] arr) {
          // 对于输入的数组为空，或者长度小于2的只接返回
          if (arr == null || arr.length < 2) {
              return;
          }
  
          // 从左向右记录偶数的位置
          int start = 0;
          // 从右向左记录奇数的位置
          int end = arr.length - 1;
          // 开始调整奇数和偶数的位置
          while (start < end) {
              // 找偶数
              while (start < end && arr[start] % 2 != 0) {
                  start++;
              }
              // 找奇数
              while (start < end && arr[end] % 2 == 0) {
                  end--;
              }
  
              // 找到后就将奇数和偶数交换位置
              // 对于start=end的情况，交换不会产生什么影响
              // 所以将if判断省去了
              int tmp = arr[start];
              arr[start] = arr[end];
              arr[end] = tmp;
          }
      }
  }
  ```





#### 顺时针打印矩阵

01.题目要求

- 问题如下所示：

  - 输入一个矩阵，按照从外向里以顺时针的顺序依次扫印出每一个数字。

- 示例 :

  ```
  
  ```



02.问题分析

- 把打印一圈分为四步：第一步从左到右打印一行，第二步从上到下打印一列，第三步从右到左打印一行，第四步从下到上打印一列。每一步我们根据起始坐标和终止坐标用一个循环就能打印出一行或者一列。
- 不过值得注意的是，最后一圈有可能退化成只有一行、只有一列，甚至只有一个数字，因此打印这样的一圈就不再需要四步。
- 因此我们要仔细分析打印时每一步的前提条件。第一步总是需要的， 因为打印一圈至少有一步。如果只有一行，那么就不用第二步了。也就是需要第二步的前提条件是终止行号大于起始行号。需要第三步打印的前提条件是圈内至少有两行两列，也就是说除了要求终止行号大于起始行号之外，还要求终止列号大于起始列号。同理，需要打印第四步的前提条件是至少有三行两列，因此要求终止行号比起始行号至少大2 ， 同时终止列号大于起始列号。

03.实例代码

- 如下所示

  ```java
  public class Test {
      /**
       * 输入一个矩阵，按照从外向里以顺时针的顺序依次打印每一个数字
       *
       * @param numbers 输入的二维数组，二维数组必须是N*M的，否则分出错
       */
      public static void printMatrixClockWisely(int[][] numbers) {
          // 输入的参数不能为空
          if (numbers == null) {
              return;
          }
  
          // 记录一圈（环）的开始位置的行
          int x = 0;
          // 记录一圈（环）的开始位置的列
          int y = 0;
          // 对每一圈（环）进行处理，
          // 行号最大是(numbers.length-1)/2
          // 列号最大是(numbers[0].length-1)/2
          while (x * 2 < numbers.length && y * 2 < numbers[0].length) {
              printMatrixInCircle(numbers, x, y);
              // 指向下一个要处理的的环的第一个位置
              x++;
              y++;
          }
      }
  
      public static void printMatrixInCircle(int[][] numbers, int x, int y) {
          // 数组的行数
          int rows = numbers.length;
          // 数组的列数
          int cols = numbers[0].length;
  
          // 输出环的上面一行，包括最中的那个数字
          for (int i = y; i <= cols - y - 1; i++) {
              System.out.print(numbers[x][i] + " ");
          }
  
          // 环的高度至少为2才会输出右边的一列
          // rows-x-1：表示的是环最下的那一行的行号
          if (rows - x - 1 > x) {
              // 因为右边那一列的最上面那一个已经被输出了，所以行呈从x+1开始，
              // 输出包括右边那列的最下面那个
              for (int i = x + 1; i <= rows - x - 1; i++) {
                  System.out.print(numbers[i][cols - y - 1] + " ");
              }
          }
  
          // 环的高度至少是2并且环的宽度至少是2才会输出下面那一行
          // cols-1-y：表示的是环最右那一列的列号
          if (rows - x - 1 > x && cols - 1 - y > y) {
              // 因为环的左下角的位置已经输出了，所以列号从cols-y-2开始
              for (int i = cols - y - 2; i >= y; i--) {
                  System.out.print(numbers[rows - 1 - x][i] + " ");
              }
          }
  
          // 环的宽度至少是2并且环的高度至少是3才会输出最左边那一列
          // rows-x-1：表示的是环最下的那一行的行号
          if (cols - 1 - y > y && rows - 1 - x > x + 1) {
              // 因为最左边那一列的第一个和最后一个已经被输出了
              for (int i = rows - 1 - x - 1; i >= x + 1; i--) {
                  System.out.print(numbers[i][y] + " ");
              }
          }
      }
  }
  ```









#### 数组中出现次数超过一半的数字

01.题目要求

- 问题如下所示：

  - 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

- 示例 :

  ```
  
  ```



02.问题分析

- **解法一：基于Partition 函数的O(n)算法**
  - 数组中有一个数字出现的次数超过了数组长度的一半。如果把这个数组排序，那么排序之后位于数组中间的数字一定就是那个出现次数超过数组长度一半的数字。也就是说，这个数字就是统计学上的中位数，即长度为n 的数组中第n/2 大的数字。
  - 这种算法是受快速排序算法的启发。在随机快速排序算法中，我们先在数组中随机选择一个数字，然后调整数组中数字的顺序， 使得比选中的数字小数字都排在它的左边，比选中的数字大的数字都排在它的右边。如果这个选中的数字的下标刚好是n/2，那么这个数字就是数组的中位数。如果它的下标大于n/2 ，那么中位数应该位于它的左边，我们可以接着在它的左边部分的数组中查找。如果它的下标小于n/2，那么中位数应该位于它的右边，我们可以接着在它的右边部分的数组中查找。这是一个典型的递归过程。
- **解法二：根据数组组特点找出O(n)的算法**
  - 数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现次数的和还要多。因此我们可以考虑在遍历数组的时候保存两个值： 一个是数组中的一个数字， 一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1，如果下一个数字和我们之前保存的数字不同，则次数减1 。如果次数为零，我们需要保存下一个数字，并把次数设为1 。由于我们要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设为1 时对应的数字。



03.实例代码

- 如下所示

  ```
  public class Test {
  
      /**
       * 题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字
       *
       * @param numbers 输入数组
       * @return 找到的数字
       */
      public static int moreThanHalfNum(int[] numbers) {
  
          // 输入校验
          if (numbers == null || numbers.length < 1) {
              throw new IllegalArgumentException("array length must large than 0");
          }
  
          // 用于记录出现次数大于数组一半的数
          int result = numbers[0];
          // 于当前记录的数不同的数的个数
          int count = 1;
          // 从第二个数开始向后找
          for (int i = 1; i < numbers.length; i++) {
              // 如果记数为0
              if (count == 0) {
                  // 重新记录一个数，假设它是出现次数大于数组一半的
                  result = numbers[i];
                  // 记录统计值
                  count = 1;
              }
              // 如果记录的值与统计值相等，记数值增加
              else if (result == numbers[i]) {
                  count++;
              }
              // 如果不相同就减少，相互抵消
              else {
                  count--;
              }
          }
  
          // 最后的result可能是出现次数大于数组一半长度的值
          // 统计result的出现次数
          count = 0;
          for (int number : numbers) {
              if (result == number) {
                  count++;
              }
          }
  
          // 如果出现次数大于数组的一半就返回对应的值
          if (count > numbers.length / 2) {
              return result;
          }
          // 否则输入异常
          else {
              throw new IllegalArgumentException("invalid input");
          }
      }
  }
  ```





​	





### TopK问题

#### 最小的k个数

01.题目要求

- 问题如下所示：

  - 输入n个整数，找出其中最小的k个数。

- 示例 :

  ```
  例如输入4 、5 、1、6、2、7、3 、8 这8 个数字，则最小的4个数字是1 、2、3 、4
  ```



02.问题分析

- **解法一：O(n)时间算法，只有可以修改输入数组时可用。**
  - 可以基于Partition函数来解决这个问题。如果基于数组的第k个数字来调整，使得比第k个数字小的所有数字都位于数组的左边，比第k个数字大的所有数字都位于数组的右边。这样调整之后，位于数组中左边的k个数字就是最小的k 个数字（这k 个数字不一定是排序的〉。
- **解法二： O（nlogk）的算法，精剧适合处理海量数据。**
  - 先创建一个大小为k的数据容器来存储最小的k个数字，接下来我们每次从输入的n个整数中读入一个数．如果容器中已有的数字少于k个，则直接把这次读入的整数放入容器之中：如果容器中己有k 数字了，也就是容器己满，此时我们不能再插入新的数字而只能替换已有的数字。找出这己有的k 个数中的最大值，然后1在这次待插入的整数和最大值进行比较。如果待插入的值比当前己有的最大值小，则用这个数替换当前已有的最大值：如果待插入的值比当前已有的最大值还要大，那么这个数不可能是最小的k个整数之一，于是我们可以抛弃这个整数。
  - 因此当容器满了之后，我们要做3 件事情： 一是在k 个整数中找到最大数： 二是有可能在这个容器中删除最大数： 三是有可能要插入一个新的数字。我们可以**使用一个大顶堆在O(logk）时间内实现这三步操作**。

03.实例代码

- 如下所示

  ```java
  public class Test {
      /**
       * 大顶堆
       *
       * @param <T> 参数化类型
       */
      private final static class MaxHeap<T extends Comparable<T>> {
          // 堆中元素存放的集合
          private List<T> items;
          // 用于计数
          private int cursor;
  
          /**
           * 构造一个椎，始大小是32
           */
          public MaxHeap() {
              this(32);
          }
  
          /**
           * 造诣一个指定初始大小的堆
           *
           * @param size 初始大小
           */
          public MaxHeap(int size) {
              items = new ArrayList<>(size);
              cursor = -1;
          }
  
          /**
           * 向上调整堆
           *
           * @param index 被上移元素的起始位置
           */
          public void siftUp(int index) {
              T intent = items.get(index); // 获取开始调整的元素对象
  
              while (index > 0) { // 如果不是根元素
                  int parentIndex = (index - 1) / 2; // 找父元素对象的位置
                  T parent = items.get(parentIndex);  // 获取父元素对象
                  if (intent.compareTo(parent) > 0) { //上移的条件，子节点比父节点大
                      items.set(index, parent); // 将父节点向下放
                      index = parentIndex; // 记录父节点下放的位置
                  } else { // 子节点不比父节点大，说明父子路径已经按从大到小排好顺序了，不需要调整了
                      break;
                  }
              }
  
              // index此时记录是的最后一个被下放的父节点的位置（也可能是自身），所以将最开始的调整的元素值放入index位置即可
              items.set(index, intent);
          }
  
          /**
           * 向下调整堆
           *
           * @param index 被下移的元素的起始位置
           */
          public void siftDown(int index) {
              T intent = items.get(index);  // 获取开始调整的元素对象
              int leftIndex = 2 * index + 1; // // 获取开始调整的元素对象的左子结点的元素位置
  
              while (leftIndex < items.size()) { // 如果有左子结点
                  T maxChild = items.get(leftIndex); // 取左子结点的元素对象，并且假定其为两个子结点中最大的
                  int maxIndex = leftIndex; // 两个子节点中最大节点元素的位置，假定开始时为左子结点的位置
  
                  int rightIndex = leftIndex + 1;  // 获取右子结点的位置
                  if (rightIndex < items.size()) {  // 如果有右子结点
                      T rightChild = items.get(rightIndex);  // 获取右子结点的元素对象
                      if (rightChild.compareTo(maxChild) > 0) {  // 找出两个子节点中的最大子结点
                          maxChild = rightChild;
                          maxIndex = rightIndex;
                      }
                  }
  
                  // 如果最大子节点比父节点大，则需要向下调整
                  if (maxChild.compareTo(intent) > 0) {
                      items.set(index, maxChild); // 将子节点向上移
                      index = maxIndex; // 记录上移节点的位置
                      leftIndex = index * 2 + 1; // 找到上移节点的左子节点的位置
                  } else { // 最大子节点不比父节点大，说明父子路径已经按从大到小排好顺序了，不需要调整了
                      break;
                  }
              }
  
              // index此时记录是的最后一个被上移的子节点的位置（也可能是自身），所以将最开始的调整的元素值放入index位置即可
              items.set(index, intent);
          }
  
          /**
           * 向堆中添加一个元素
           *
           * @param item 等待添加的元素
           */
          public void add(T item) {
              items.add(item); // 将元素添加到最后
              siftUp(items.size() - 1); // 循环上移，以完成重构
          }
  
          /**
           * 删除堆顶元素
           *
           * @return 堆顶部的元素
           */
          public T deleteTop() {
              if (items.isEmpty()) { // 如果堆已经为空，就报出异常
                  throw new RuntimeException("The heap is empty.");
              }
  
              T maxItem = items.get(0); // 获取堆顶元素
              T lastItem = items.remove(items.size() - 1); // 删除最后一个元素
              if (items.isEmpty()) { // 删除元素后，如果堆为空的情况，说明删除的元素也是堆顶元素
                  return lastItem;
              }
  
              items.set(0, lastItem); // 将删除的元素放入堆顶
              siftDown(0); // 自上向下调整堆
              return maxItem; // 返回堆顶元素
          }
  
          /**
           * 获取下一个元素
           *
           * @return 下一个元素对象
           */
          public T next() {
  
              if (cursor >= items.size()) {
                  throw new RuntimeException("No more element");
              }
              return items.get(cursor);
  
          }
  
          /**
           * 判断堆中是否还有下一个元素
           *
           * @return true堆中还有下一个元素，false堆中无下五元素
           */
          public boolean hasNext() {
              cursor++;
              return cursor < items.size();
          }
  
          /**
           * 获取堆中的第一个元素
           *
           * @return 堆中的第一个元素
           */
          public T first() {
              if (items.size() == 0) {
                  throw new RuntimeException("The heap is empty.");
              }
              return items.get(0);
          }
  
          /**
           * 判断堆是否为空
           *
           * @return true是，false否
           */
          public boolean isEmpty() {
              return items.isEmpty();
          }
  
          /**
           * 获取堆的大小
           *
           * @return 堆的大小
           */
          public int size() {
              return items.size();
          }
  
          /**
           * 清空堆
           */
          public void clear() {
              items.clear();
          }
  
          @Override
          public String toString() {
              return items.toString();
          }
      }
  
      /**
       * 题目： 输入n个整数，找出其中最小的k个数。
       * 【第二种解法】
       * @param input  输入数组
       * @param output 输出数组
       */
      public static void getLeastNumbers2(int[] input, int[] output) {
          if (input == null || output == null || output.length <= 0 || input.length < output.length) {
              throw new IllegalArgumentException("Invalid args");
          }
  
          MaxHeap<Integer> maxHeap = new MaxHeap<>(output.length);
          for (int i : input) {
              if (maxHeap.size() < output.length) {
                  maxHeap.add(i);
              } else {
                  int max = maxHeap.first();
                  if (max > i) {
                      maxHeap.deleteTop();
                      maxHeap.add(i);
                  }
              }
          }
  
          for (int i = 0; maxHeap.hasNext(); i++) {
              output[i] = maxHeap.next();
          }
      }
  
  
      /**
       * 题目： 输入n个整数，找出其中最小的k个数。
       * 【第一种解法】
       * @param input  输入数组
       * @param output 输出数组
       */
      public static void getLeastNumbers(int[] input, int[] output) {
  
          if (input == null || output == null || output.length <= 0 || input.length < output.length) {
              throw new IllegalArgumentException("Invalid args");
          }
  
          int start = 0;
          int end = input.length - 1;
          int index = partition(input, start, end);
          int target = output.length - 1;
  
          while (index != target) {
              if (index < target) {
                  start = index + 1;
              } else {
                  end = index - 1;
              }
              index = partition(input, start, end);
          }
  
          System.arraycopy(input, 0, output, 0, output.length);
      }
  
      /**
       * 分区算法
       *
       * @param input 输入数组
       * @param start 开始下标
       * @param end   结束下标
       * @return 分区位置
       */
      private static int partition(int[] input, int start, int end) {
          int tmp = input[start];
  
          while (start < end) {
              while (start < end && input[end] >= tmp) {
                  end--;
              }
              input[start] = input[end];
  
              while (start < end && input[start] <= tmp) {
                  start++;
              }
              input[end] = input[start];
          }
  
          input[start] = tmp;
          return start;
      }
  }
  ```







#### 连续子数组的最大和

01.题目要求

- 问题如下所示：

  - 输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。

- 示例 :

  ```
  - 例如输入的数组为{1, -2, 3, 10, -4, 7, 2, -5}，那么最大的子数组为｛3, 10, -4, 7, 2}。因此输出为该子数组的和18 。
  ```



02.问题分析

- 解法一：举例分析数组的规律。
  - 我们试着从头到尾逐个累加示例数组中的每个数字。初始化和为0。第一步加上第一个数字1， 此时和为1。接下来第二步加上数字-2，和就变成了-1。第三步刷上数字3。我们注意到由于此前累计的和是－1 ，小于0，那如果用-1 加上3 ，得到的和是2 ， 比3 本身还小。也就是说从第一个数字开始的子数组的和会小于从第三个数字开始的子数组的和。因此我们不用考虑从第一个数字开始的子数组，之前累计的和也被抛弃。
  - 我们从第三个数字重新开始累加，此时得到的和是3 。接下来第四步加10，得到和为13 。第五步加上-4， 和为9。我们发现由于-4 是一个负数，因此累加-4 之后得到的和比原来的和还要小。因此我们要把之前得到的和13 保存下来，它有可能是最大的子数组的和。第六步加上数字7，9 加7 的结果是16，此时和比之前最大的和13 还要大， 把最大的子数组的和由13更新为16。第七步加上2，累加得到的和为18，同时我们也要更新最大子数组的和。第八步加上最后一个数字-5，由于得到的和为13 ，小于此前最大的和18，因此最终最大的子数组的和为18 ，对应的子数组是｛3, 10, -4, 7, 2｝。



03.实例代码

- 如下所示

  ```java
  public class Test {
      /**
       * 输入一个整型数组，数组里有正数也有负数。数组中一个或连
       * 续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。
       *
       * @param arr 输入数组
       * @return 最大的连续子数组和
       */
      public static int findGreatestSumOfSubArray(int[] arr) {
          // 参数校验
          if (arr == null || arr.length < 1) {
              throw new IllegalArgumentException("Array must contain an element");
          }
  
          // 记录最大的子数组和，开始时是最小的整数
          int max = Integer.MIN_VALUE;
          // 当前的和
          int curMax = 0;
          // 数组遍历
          for (int i : arr) {
              // 如果当前和小于等于0，就重新设置当前和
              if (curMax <= 0) {
                  curMax = i;
              }
              // 如果当前和大于0，累加当前和
              else {
                  curMax += i;
              }
  
              // 更新记录到的最在的子数组和
              if (max < curMax) {
                  max = curMax;
              }
          }
          return max;
      }
  }
  ```



04.测试代码

- 如下所示

  ```java
  public static void test() {
  	int[] a = {1, -2, 3, 10, -4, 7, 2, -5};
  	int moreThanHalfNum = findGreatestSumOfSubArray(a);
  	System.out.print(moreThanHalfNum);
  }
  
  //输出结果：18
  ```









#### 五子棋问题

Java代码：

```java
public class Chessbroad {
    public static void main(String[] args) {
        int chessArr1[][]=new int [11][11];
        chessArr1[1][2]=1;
        chessArr1[2][3]=2;

        for(int[] row:chessArr1){
            for(int data:row){
                System.out.printf("%d\t",data);

            }
            System.out.println();
        }

        int sum=0;
        for(int i=0;i<11;i++){
            for(int j=0;j<11;j++){
                if(chessArr1[i][j]!=0){
                    sum++;
                }
            }
        }

        int sparseArr[][]=new int[sum+1][3];
        sparseArr[0][0]=11;
        sparseArr[0][1]=11;
        sparseArr[0][2]=sum;

        int count=0;
        for(int i=0;i<11;i++){
            for(int j=0;j<11;j++){
                if(chessArr1[i][j]!=0){
                    count++;
                    sparseArr[count][0]=i;
                    sparseArr[count][1]=j;
                    sparseArr[count][2]=chessArr1[i][j];
                }
            }
        }

        System.out.println();

        for(int i=0;i<sparseArr.length;i++){
            System.out.printf("%d\t%d\t%d\t\n",sparseArr[i][0],
                sparseArr[i][1],sparseArr[i][2]);
            System.out.println();
        }
        System.out.println();

        int chessArr2[][]=new int[sparseArr[0][0]][sparseArr[0][1]];

        for(int i=1;i<sparseArr.length;i++){
            chessArr2[sparseArr[i][0]][sparseArr[i][1]]=sparseArr[i][2];

        }
        System.out.println();

        for(int[] row:chessArr2){
            for(int data:row){
                System.out.printf("%d\t",data);

            }
            System.out.println();
        }
    }
}

```

##  







### 区间最值查询 RMQ算法







### 树状数组

**概述**

顾名思义，就是用数组来模拟树形结构呗。那么衍生出一个问题，为什么不直接建树？答案是没必要，因为树状数组能处理的问题就没必要建树。和Trie树的构造方式有类似之处。

**树状数组可以解决什么问题**

可以解决大部分基于区间上的更新以及求和问题。

**树状数组和线段树的区别在哪里**

树状数组可以解决的问题都可以用线段树解决，这两者的区别在哪里呢？树状数组的系数要少很多，就比如字符串模拟大数可以解决大数问题，也可以解决1+1的问题，但没人会在1+1的问题上用大数模拟。

**树状数组的优点和缺点**

修改和查询的复杂度都是O(logN)，而且相比线段树系数要少很多，比传统数组要快，而且容易写。

缺点是遇到复杂的区间问题还是不能解决，功能还是有限。











#### 解题经验

常用方法：

toCharArray()方法：字符串转字符数组

注意：

打印数组应该使用Arrays.toString()方法，不能直接输出，否则输出首地址

```
System.out.println(Arrays.toString(res));
```



