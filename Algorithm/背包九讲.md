# 背包九讲

### 01背包

#### 分割等和子集

![image-20200822182134931](D:\gitee\back_end_interview_project\图片\image-20200822182134931.png)

```java
class Solution {
    public boolean canPartition(int[] nums) {
       int len = nums.length;
        if (len == 0) {
            return false;
        }
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        // 特判：如果是奇数，就不符合要求
        if ((sum & 1) == 1) {
            return false;
        }
        int target = sum / 2;
        // 创建二维状态数组，行：物品索引，列：容量（包括 0）
        boolean[][] dp = new boolean[len][target + 1];
        // 先填表格第 0 行，第 1 个数只能让容积为它自己的背包恰好装满
        if (nums[0] <= target) {
            dp[0][nums[0]] = true;
        }
	
        // dp核心部分
        for (int i = 1; i < len; i++) {
            for (int j = 0; j <= target; j++) {
                // 直接从上一行先把结果抄下来，然后再修正
                dp[i][j] = dp[i - 1][j];

                if (nums[i] == j) {
                    dp[i][j] = true;
                    continue;
                }
                if (nums[i] < j) {
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];
                }
            }
        }
        return dp[len - 1][target];

    }
}
```





#### 最后一块石头的重量 II

![image-20200822182604356](D:\gitee\back_end_interview_project\图片\image-20200822182604356.png)

```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        /* 由于石头拿走还能放回去，因此可以简单地把所有石头看作两堆
         * 假设总重量为 sum, 则问题转化为背包问题：如何使两堆石头总重量接近 sum / 2
         */
        int len = stones.length;
        /* 获取石头总重量 */
        int sum = 0;
        for (int i : stones) {
            sum += i;
        }
        /* 定义 dp[i] 重量上限为 i 时背包所能装载的最大石头重量 */
        int maxCapacity = sum/2;
        int[] dp = new int[maxCapacity + 1];
        for (int i = 0; i < len; i++) {
            int curStone = stones[i];
            for (int j = maxCapacity; j >= curStone; j--) {
                dp[j] = Math.max(dp[j], dp[j-curStone] + curStone);
            }
        }
        return sum - 2 * dp[maxCapacity];
    }
}
```







### 完全背包

#### 零钱兑换

![image-20200822183613997](D:\gitee\back_end_interview_project\图片\image-20200822183613997.png)

四大步骤

确定状态

![image-20200429152310965](D:\gitee\back_end_interview_project\图片\image-20200429152310965.png)

最后一步

![image-20200429152544436](D:\gitee\back_end_interview_project\图片\image-20200429152544436.png)

其中蕴含了两个关键思想

![image-20200429152756674](D:\gitee\back_end_interview_project\图片\image-20200429152756674.png)

（所谓最优子结构也就是指的是哪怕去掉最后一个硬币ak，前K-1枚硬币组成27-ak的方式也是最优结构）

那么就引出了“子问题”这个概念（所谓的大事化小）

![image-20200429153148355](D:\gitee\back_end_interview_project\图片\image-20200429153148355.png)

通过上述分析得知，问题转换为求子问题最优化，那么就可以得到状态转移方程

![image-20200430122532053](D:\gitee\back_end_interview_project\图片\image-20200430122532053.png)

其中有一个问题，动态规划和递归有什么关系，硬币题用递归求解如下：

![image-20200430122725356](D:\gitee\back_end_interview_project\图片\image-20200430122725356.png)

递归所存在的问题

![image-20200430123052732](D:\gitee\back_end_interview_project\图片\image-20200430123052732.png)

太多重复的步骤，会导致时间复杂度过大，用递归的求解一定不是最优解。

（二）最后得到转移方程，搞清楚子问题与最后一步得到转移方程就会容易很多

![image-20200430123810276](D:\gitee\back_end_interview_project\图片\image-20200430123810276.png)



（三）初始条件和边界情况

边界情况可以理解为，执行到那个位置停下来，越界

初始条件可以理解为，转移方程算不出来，需要手动定义



（四）计算顺序

一维问题，一般是从小到大，少数问题是从大到小

二维问题，一般是从上到下，从左到右

原则：如果转移方程右边的值已知，那么就是从小到大来计算

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        // 自底向上的动态规划
        if(coins.length == 0){
            return -1;
        }
		
        // dp[n]的值： 表示的凑成总金额为n所需的最少的硬币个数
        int[] dp = new int[amount+1];
        dp[0] = 0;
        for(int i = 1; i <= amount;i++){
            int min = Integer.MAX_VALUE;
            for(int j = 0;j < coins.length;j++){
                if(i - coins[j] >= 0 && dp[i-coins[j]] < min){
                    min = dp[i-coins[j]] + 1;
                }
            }
            // memo[i] = (min == Integer.MAX_VALUE ? Integer.MAX_VALUE : min);
            dp[i] = min;
        }

        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
}
```





#### 零钱兑换 II

![image-20200822184530358](D:\gitee\back_end_interview_project\图片\image-20200822184530358.png)

```java
class Solution {
  public int change(int amount, int[] coins) {
    int[] dp = new int[amount + 1];
    dp[0] = 1;

    for (int coin : coins) {
      for (int x = coin; x < amount + 1; ++x) {
        dp[x] += dp[x - coin];
      }
    }
    return dp[amount];
  }
}
```





####  完全平方数

![image-20200822184216047](D:\gitee\back_end_interview_project\图片\image-20200822184216047.png)



```java
class Solution {

  public int numSquares(int n) {
    int dp[] = new int[n + 1];
    Arrays.fill(dp, Integer.MAX_VALUE);
    // bottom case
    dp[0] = 0;

    // pre-calculate the square numbers.
    int max_square_index = (int) Math.sqrt(n) + 1;
    int square_nums[] = new int[max_square_index];
    for (int i = 1; i < max_square_index; ++i) {
      square_nums[i] = i * i;
    }

    for (int i = 1; i <= n; ++i) {
      for (int s = 1; s < max_square_index; ++s) {
        if (i < square_nums[s])
          break;
        dp[i] = Math.min(dp[i], dp[i - square_nums[s]] + 1);
      }
    }
    return dp[n];
  }
}
```





### 多重背包

####  一和零

![image-20200822182035590](D:\gitee\back_end_interview_project\图片\image-20200822182035590.png)

```java
public class Solution {

    private int[] countZeroAndOne(String str) {
        int[] cnt = new int[2];
        for (char c : str.toCharArray()) {
            cnt[c - '0']++;
        }
        return cnt;
    }

    public int findMaxForm(String[] strs, int m, int n) {
        int len = strs.length;
        int[][][] dp = new int[len + 1][m + 1][n + 1];

        for (int i = 1; i <= len; i++) {
            // 注意：有一位偏移
            int[] cnt = countZeroAndOne(strs[i - 1]);
            for (int j = 0; j <= m; j++) {
                for (int k = 0; k <= n; k++) {
                    // 先把上一行抄下来
                    dp[i][j][k] = dp[i - 1][j][k];

                    int zeros = cnt[0];
                    int ones = cnt[1];

                    if (j >= zeros && k >= ones) {
                        dp[i][j][k] = Math.max(dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones] + 1);
                    }
                }
            }
        }
        return dp[len][m][n];
    }
}
```





























