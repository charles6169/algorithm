# 排序算法





## 概述

对一序列对象根据某个关键字进行排序。

 **术语说明**

- **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；

- **不稳定**：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；

- **内排序**：所有排序操作都在内存中完成；

- **外排序**：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；

- **时间复杂度：** 一个算法执行所耗费的时间。

- **空间复杂度**：运行完一个程序所需内存的大小



![image-20200407163813128](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200407163813128.png)

几大排序动图参考  https://www.cnblogs.com/guoyaohua/p/8600214.html







### 十大排序分析

![image-20200608110315405](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200608110315405.png)![img](https://uploadfiles.nowcoder.com/images/20200101/300975041_1577837734664_4D4602C6B3AA11A907E97BDA0C7E2110)

![image-20200407163802369](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200407163802369.png)

**注意**

1）稳定的排序只有插入，冒泡，归并和基数排序

2）主要几个排序的最差复杂度大部分都是O(n2)，堆排序和归并是O(nlogn)，最好情况为插入，希尔，交换，为O(n)





**记忆**

快速：左小右大分治



要求掌握

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200525044342737.png" alt="image-20200525044342737" style="zoom:80%;" />

着重理解归并和快速中的分治思想









## 模板

## 基本三类排序

### 01.冒泡排序

1.基本思想

- 很好理解，从字面意思就知道类似于冒泡。在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对**相邻**的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。

2.排序过程

- 比较相邻的两个数据，如果第二个数小，就交换位置。
- 从后向前两两比较，一直到比较最前两个数据。最终最小数被交换到起始的位置，这样第一个最小数的位置就排好。
- 继续重复上述过程，依次将第2.3...n-1个最小数排好位置。
  - ![image](https://upload-images.jianshu.io/upload_images/4432347-fac40ff75693b278.gif?imageMogr2/auto-orient/strip)

**注意**

1）冒泡排序，最坏的情况即是每个元素两两都要相比较。如果线性表长度为10，复杂度用排列组合的思想即为C(10,9)=45

排序思想：从前往后，挨个比较交换

3.代码实现

bubbleSort（）

```java
for(int i=0;i<arr.length;i++){
	for(int index=0;index<arr.length-1-i;index++){
		if(arr[index]>arr[index+1]){
			swap(arr[index],arr[index+1]);
		}
	}
}
```





### 02.插入排序

1.基本思想

- 在要排序的一组数中，假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。
- 插入排序非常类似于整扑克牌顺序。

2.排序过程

- 从第一个元素开始，该元素可以认为已经被排序；
- 取出下一个元素，在已经排序的元素序列中从后向前扫描；
- 如果该元素(已排序)大于新元素，将该元素移到下一位置；
- 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
- 将新元素插入到该位置中，重复步骤2。
- ![image](https://upload-images.jianshu.io/upload_images/4432347-990253084cb641a3.gif?imageMogr2/auto-orient/strip)

**注意**

1）如果数组有序的话，插排只要O(n)

2）直接插入排序算法适用于待排序数据大部分已排序时

排序思想：从后往前，挨个比较交换，达到插入的效果



3.代码实现

insertSort()

```java
for(int i=0;i<arr.length;i++){
	for(int index=i;index>0;index--){
		//注意，因为index移动方向为从后往前，因此比较index和index-1位
		if(arr[index]<arr[index-1]){
			swap(arr[index],arr[index-1]);
		}
	}
}
```









### 03.选择排序

0.选择排序种类

- 选择排序分为三种，直接选择排序、树形选择排序（锦标赛排序）、堆排序（大根堆、小根堆）。直接选择排序和堆排序是不稳定排序，树形选择排序是稳定排序 。

1.直接选择排序

1.1 基本思想

- 在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；
- 第二次遍历n-2个数，找到最小的数值与第二个元素交换；
- 依此类推……
- 第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。

1.2 排序过程

- 通过设置哨位，将哨位位置的数与哨位之后（包括哨位）的序列中最小的数进行交换，然后哨位递增，直到哨位到达数组中最后一个数为止。
- ![image](https://upload-images.jianshu.io/upload_images/4432347-d406a59b8a29676f.gif?imageMogr2/auto-orient/strip)



排序思想：从前向后，挨个选择交换，达到选择的效果

1.3 代码实现

selectSort()

```java
for(int i=0;i<arr.length;i++){
	int minIndex=i;
	for(int index=i;index<arr.length;index++){
		if(arr[index]<arr[minIndex]){
			minIndex=index;
		}					
	}
	swap(i,minIndex);
}
```







​		直接选择排序的最好时间复杂度和最差时间复杂度都是O(n²)，因为即使数组一开始就是正序的，也需要将两重循环进行完，平均时间复杂度也是O(n²)。空间复杂度为O(1)，因为不占用多余的空间。直接选择排序是一种原地排序（In-place sort）并且稳定（stable sort）的排序算法，优点是实现简单，占用空间小，缺点是效率低，时间复杂度高，对于大规模的数据耗时长。



#### 横向比较

冒泡排序：从前往后，两两交换

![image-20200702191559001](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200702191559001.png)

插入排序：从后往前，比较插入

![image-20200702191645568](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200702191645568.png)

选择排序：从后往后，先选再换

![image-20200702191833286](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200702191833286.png)









## 对应改进三类排序

### 快速排序

1.基本思想

-  快速排序是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
-  冒泡排序的改进，单次排序看成从前和后相向的比较和交换。

2.排序过程

- 1、设待排序数组为arr
- 2、设置key = 0，i = 0，j = arr.length – 1，从j开始从后往前遍历数组，当找到arr[j] < arr[key]的数的时候，交换j和key位置的数，让key = j，j递减；然后开始递增i，当找到arr[i]>= arr[key]时，交换i和key位置的数，让key = i，i递减。
- 3、当i < j时，重复第二步，直到i == j，此时将数组以i为界分割为两段，一段是[0, i - 1]，一段是[i + 1, arr.length - 1]，对这两段分别进行快速排序，直到不能再分段为止，排序结束。
- ![image](https://upload-images.jianshu.io/upload_images/4432347-9d2b0336443de054.gif?imageMogr2/auto-orient/strip)

比哨值大则为紫色，比哨值小则为绿色。

**一次快排的举例**（加深理解）

28,16,32,12,60,2,5,72

一趟快速排序的算法是：

1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；

2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；

3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；

4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；

5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。

![img](http://img.shangxueba.cn/images/ct_csrmsdsm_crmsdschoosecn_02558(200911).jpg)



**注意**

1）中间结果：比参照数大的在参照数的右侧，比参照数小的，在参照数的左侧。

2）在待排序数据已有序时，花费时间反而最多的是快速排序

3）为实现快速排序算法，待排序序列宜采用的存储方式是顺序存储，顺序存储 适用于频繁查询时使用； 链式存储适用于频繁地插入、删除、更新元素时使用。

排序思想：

从前往后找第一个比基准值大的值，从后往前找第一个比基准值小的值

基准值在实现时表现为辅助left值和i值交换

递归的分界为 i

整个快排可以总结为 **交换1-移动-交换2-递归**



快排逻辑记忆

```
1）保存left值到base

2）i，j 对base比较  相向搜索

3）如果 i<j 交换 i,j

4）left与i交换

5）以i为界，对左右递归
```





3.代码实现

快排比较特殊，基于递归实现

1）空值判定，且数组长度大于1

2）调用递归函数，传入参数为数组，左指针和右指针

​		3）终止条件：右值大于左值

​		4）base中存放数组左值为基准数

​		5）新建动态指针i，j

​		6）while循环  当 i 不等于 j 时循环

​			7）while循环 数组 j 位大于等于基准位，且 i 小于 j 时

​					j 自减

​			8）while循环  数组i位小于等于基准位，且 i 小于 j 时

​					i 自增

​			9）判断如果 i 小于 j

​					交换 i 位和 j 位

​		10）基准数归位，i位赋给 左值，基准值 赋给 i 位

11）以 i 为界 分别对数组左右调用递归



完整模板

quickSort（）

```java
private static void quickSort(int[] num, int left, int right) {
		//如果left等于right，即数组只有一个元素，直接返回
		if(left>=right) {
			return;
		}
		//设置最左边的元素为基准值
		int base=num[left];
		//数组中比key小的放在左边，比key大的放在右边，key值下标为i
		int i=left,j=right;
		while(i<j){
			//j向左移，直到遇到比key小的值
			while(num[j]>=base && i<j){
				j--;
			}
			//i向右移，直到遇到比key大的值
			while(num[i]<=base && i<j){
				i++;
			}
			//i和j指向的元素交换
			if(i<j){
				int temp=num[i];
				num[i]=num[j];
				num[j]=temp;
			}
		}
		num[left]=num[i];
		num[i]=base;
		QuickSort(num,left,i-1);
		QuickSort(num,i+1,right);
	}

```





### 希尔排序

1.基本思想

- 在要排序的一组数中，根据某一增量分为若干子序列，并对子序列分别进行插入排序。
- 然后逐渐将增量减小，并重复上述过程。直至增量为1,此时数据序列基本有序,最后进行插入排序。

2.排序过程

- **也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本**。希尔排序是非稳定排序算法。
- 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。
- ![img](https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161128110416068-1421707828.png)

3.代码实现

```java
public static int[] shellSort(int[] ins){
		int n = ins.length;
		int gap = n/2;
		while(gap > 0){
			for(int j = gap; j < n; j++){
				int i=j;
				while(i >= gap && ins[i-gap] > ins[i]){
					int temp = ins[i-gap]+ins[i];
					ins[i-gap] = temp-ins[i-gap];
					ins[i] = temp-ins[i-gap];
					i -= gap;
				}
			}
			gap = gap/2;
		}
		return ins;
	}

```





4.算法步骤

- 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；

- 按增量序列个数 k，对序列进行 k 趟排序；

- 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。






### 堆排序

1.基本思想

- 堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，使得在当前无序区中选取最大（或最小）关键字的记录变得简单。



**堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆。**

1. **将无需序列构建成一个堆，根据升序需求选择大顶堆;**

   **将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;**

2. **重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。**

   

2.排序过程

- 1.先将初始文件R[1..n]建成一个大根堆，此堆为初始的无序区
- 2.再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key
- 3.由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。
- 4.直到无序区只有一个元素为止。
- ![image](https://upload-images.jianshu.io/upload_images/4432347-6517da92276b4ffb.gif?imageMogr2/auto-orient/strip)



3.代码实现

- 代码如下所示

  ```java
  public class Main {
      public static void main(String[] args) {
          int[] nums = {16,7,3,20,17,8};
          headSort(nums);
          for (int num : nums) {
              System.out.print(num + " ");
          }
      }
  
      /**
       * 堆排序
       */
      public static void headSort(int[] list) {
          //构造初始堆,从第一个非叶子节点开始调整,左右孩子节点中较大的交换到父节点中
          for (int i = (list.length) / 2 - 1; i >= 0; i--) {
              headAdjust(list, list.length, i);
          }
          //排序，将最大的节点放在堆尾，然后从根节点重新调整
          for (int i = list.length - 1; i >= 1; i--) {
              int temp = list[0];
              list[0] = list[i];
              list[i] = temp;
              headAdjust(list, i, 0);
          }
      }
      
      //堆调整
      private static void headAdjust(int[] list, int len, int i) {
          int k = i, temp = list[i], index = 2 * k + 1;
          while (index < len) {
              if (index + 1 < len) {
                  if (list[index] < list[index + 1]) {
                      index = index + 1;
                  }
              }
              if (list[index] > temp) {
                  list[k] = list[index];
                  k = index;
                  index = 2 * k + 1;
              } else {
                  break;
              }
          }
          list[k] = temp;
      }
  }
  ```

4.如何优化

5.复杂度

6.使用场景





#### 横向比较

快速排序：两边往中间，相遇再交换，递归来分治

![image-20200702215919852](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200702215919852.png)



希尔排序：gap二倍递减，遍历选择交换

![image-20200702215932994](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200702215932994.png)





### 归并排序

1.基本思想

- 堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，使得在当前无序区中选取最大（或最小）关键字的记录变得简单。



2.排序过程

具体的实现，归并排序包括"从上往下"和"从下往上"2种方式。

1. 从下往上的归并排序：将待排序的数列分成若干个长度为1的子数列，然后将这些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。这样就得到了我们想要的排序结果。(参考下面的图片)
2. 从上往下的归并排序：它与"从下往上"在排序上是反方向的。它基本包括3步：
    ① 分解 -- 将当前区间一分为二，即求分裂点 mid = (low + high)/2;
    ② 求解 -- 递归地对两个子区间a[low...mid] 和 a[mid+1...high]进行归并排序。递归的终结条件是子区间长度为1。
    ③ 合并 -- 将已排序的两个子区间a[low...mid]和 a[mid+1...high]归并为一个有序的区间a[low...high]。

![img](https://images0.cnblogs.com/i/497634/201403/151853346211212.jpg)



**注意**

1）归并排序 排序过程中需要一个记录的辅助空间





3.代码实现

代码如下所示

```
public class Main {
    public void mergeSort(int [] a,int start,int end){
        if(start<end){//当子序列中只有一个元素时结束递归
            int mid=(start+end)/2;//划分子序列
            mergeSort(a, start, mid);//对左侧子序列进行递归排序
            mergeSort(a, mid+1, end);//对右侧子序列进行递归排序
            merge(a, start, mid, end);//合并
        }
    }
    
    //两路归并算法，两个排好序的子序列合并为一个子序列
    public void merge(int []a,int left,int mid,int right){
        int []tmp=new int[a.length];//辅助数组
        int p1=left,p2=mid+1,k=left;//p1、p2是检测指针，k是存放指针

        while(p1<=mid && p2<=right){
            if(a[p1]<=a[p2])
                tmp[k++]=a[p1++];
            else
                tmp[k++]=a[p2++];
        }

        while(p1<=mid) tmp[k++]=a[p1++];//如果第一个序列未检测完，直接将后面所有元素加到合并的序列中
        while(p2<=right) tmp[k++]=a[p2++];//同上

        //复制回原素组
        for (int i = left; i <=right; i++) 
            a[i]=tmp[i];
    }
}
```



Signal-Modulation-Identification-Project











### 基于桶排序

### 计数排序



1.基本思想

- 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

2.排序过程

- ![image](https://upload-images.jianshu.io/upload_images/4432347-7ba86937c7510963.gif?imageMogr2/auto-orient/strip)



3.代码实现

- 代码如下所示

  ```
  public int[] sort(int[] sourceArray) throws Exception {
      // 对 arr 进行拷贝，不改变参数内容
      int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
  
      int maxValue = getMaxValue(arr);
  
      return countingSort(arr, maxValue);
  }
  
  private int[] countingSort(int[] arr, int maxValue) {
      int bucketLen = maxValue + 1;
      int[] bucket = new int[bucketLen];
  
      for (int value : arr) {
          bucket[value]++;
      }
  
      int sortedIndex = 0;
      for (int j = 0; j < bucketLen; j++) {
          while (bucket[j] > 0) {
              arr[sortedIndex++] = j;
              bucket[j]--;
          }
      }
      return arr;
  }
  
  private int getMaxValue(int[] arr) {
      int maxValue = arr[0];
      for (int value : arr) {
          if (maxValue < value) {
              maxValue = value;
          }
      }
      return maxValue;
  }
  ```

4.如何优化

- 可以直接看桶排序





### 桶排序

1.基本思想

- 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。



2.排序过程

- 为了使桶排序更加高效，我们需要做到这两点：
  - 在额外空间充足的情况下，尽量增大桶的数量
  - 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中
- 同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。



3.代码实现

- 代码如下所示

  ```
  private static final InsertSort insertSort = new InsertSort();
  
  @Override
  public int[] sort(int[] sourceArray) throws Exception {
      // 对 arr 进行拷贝，不改变参数内容
      int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
      return bucketSort(arr, 5);
  }
  
  private int[] bucketSort(int[] arr, int bucketSize) throws Exception {
      if (arr.length == 0) {
          return arr;
      }
  
      int minValue = arr[0];
      int maxValue = arr[0];
      for (int value : arr) {
          if (value < minValue) {
              minValue = value;
          } else if (value > maxValue) {
              maxValue = value;
          }
      }
  
      int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1;
      int[][] buckets = new int[bucketCount][0];
  
      // 利用映射函数将数据分配到各个桶中
      for (int i = 0; i < arr.length; i++) {
          int index = (int) Math.floor((arr[i] - minValue) / bucketSize);
          buckets[index] = arrAppend(buckets[index], arr[i]);
      }
  
      int arrIndex = 0;
      for (int[] bucket : buckets) {
          if (bucket.length <= 0) {
              continue;
          }
          // 对每个桶进行排序，这里使用了插入排序
          bucket = insertSort.sort(bucket);
          for (int value : bucket) {
              arr[arrIndex++] = value;
          }
      }
  
      return arr;
  }
  
  /**
   * 自动扩容，并保存数据
   *
   * @param arr
   * @param value
   */
  private int[] arrAppend(int[] arr, int value) {
      arr = Arrays.copyOf(arr, arr.length + 1);
      arr[arr.length - 1] = value;
      return arr;
  }
  
  
  public interface IArraySort {
      /**
       * 对数组进行排序，并返回排序后的数组
       *
       * @param sourceArray
       * @return
       * @throws Exception
       */
      int[] sort(int[] sourceArray) throws Exception;
  
  }
  
  
  public class InsertSort implements IArraySort {
  
      @Override
      public int[] sort(int[] sourceArray) throws Exception {
          // 对 arr 进行拷贝，不改变参数内容
          int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
  
          // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的
          for (int i = 1; i < arr.length; i++) {
  
              // 记录要插入的数据
              int tmp = arr[i];
  
              // 从已经排序的序列最右边的开始比较，找到比其小的数
              int j = i;
              while (j > 0 && tmp < arr[j - 1]) {
                  arr[j] = arr[j - 1];
                  j--;
              }
  
              // 存在比其小的数，插入
              if (j != i) {
                  arr[j] = tmp;
              }
  
          }
          return arr;
      }
  }
  ```

4.如何优化

- 1.什么时候最快
  - 当输入的数据可以均匀的分配到每一个桶中。
- 2.什么时候最慢
  - 当输入的数据被分配到了同一个桶中。



5.复杂度

6.使用场景













### 基数排序

1.基本思想

- 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。

记忆技巧：先按个位排一次，再按十位排一次就得到结果了。

2.排序过程

- 基数排序 vs 计数排序 vs 桶排序
- 基数排序有两种方法：这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：
  - 基数排序：根据键值的**每位**数字来分配桶；
  - 计数排序：每个桶只存储单一键值；
  - 桶排序：每个桶存储一定范围的数值；
- ![image](https://upload-images.jianshu.io/upload_images/4432347-32c1f17de49aa02f.gif?imageMogr2/auto-orient/strip)



3.代码实现

- 代码如下所示

  ```
  public class RadixSort implements IArraySort {
  
      @Override
      public int[] sort(int[] sourceArray) throws Exception {
          // 对 arr 进行拷贝，不改变参数内容
          int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
  
          int maxDigit = getMaxDigit(arr);
          return radixSort(arr, maxDigit);
      }
  
      /**
       * 获取最高位数
       */
      private int getMaxDigit(int[] arr) {
          int maxValue = getMaxValue(arr);
          return getNumLenght(maxValue);
      }
  
      private int getMaxValue(int[] arr) {
          int maxValue = arr[0];
          for (int value : arr) {
              if (maxValue < value) {
                  maxValue = value;
              }
          }
          return maxValue;
      }
  
      protected int getNumLenght(long num) {
          if (num == 0) {
              return 1;
          }
          int lenght = 0;
          for (long temp = num; temp != 0; temp /= 10) {
              lenght++;
          }
          return lenght;
      }
  
      private int[] radixSort(int[] arr, int maxDigit) {
          int mod = 10;
          int dev = 1;
  
          for (int i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {
              // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)
              int[][] counter = new int[mod * 2][0];
  
              for (int j = 0; j < arr.length; j++) {
                  int bucket = ((arr[j] % mod) / dev) + mod;
                  counter[bucket] = arrayAppend(counter[bucket], arr[j]);
              }
  
              int pos = 0;
              for (int[] bucket : counter) {
                  for (int value : bucket) {
                      arr[pos++] = value;
                  }
              }
          }
  
          return arr;
      }
  
      /**
       * 自动扩容，并保存数据
       *
       * @param arr
       * @param value
       */
      private int[] arrayAppend(int[] arr, int value) {
          arr = Arrays.copyOf(arr, arr.length + 1);
          arr[arr.length - 1] = value;
          return arr;
      }
  }
  
  public interface IArraySort {
      /**
       * 对数组进行排序，并返回排序后的数组
       *
       * @param sourceArray
       * @return
       * @throws Exception
       */
      int[] sort(int[] sourceArray) throws Exception;
  
  }
  ```

























## 算法案例

#### 剑指 Offer- 把数组排成最小的数

输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

```
输入: [3,30,34,5,9]
输出: "3033459"
```



**解题思路**

本题的重点有两个

一个是搞明白字符串排序判断规则

另一个是写对快排，写其他排序没法体现实力



![image-20200720220907458](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200720220907458.png)

![image-20200720220926885](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200720220926885.png)



解题实现

1）新建存数字符串数组

2）遍历数组，将数组的每一个转字符串再放入字符串数组

3）快速排序

4）StringBuilder类型返回值

5）遍历字符串数组，将其组合入返回值

6）再次转换 ，返回String类型返回值



```java
class Solution {
    public String minNumber(int[] nums) {
        String[] strs = new String[nums.length];
        //数字数组转为字符串数组
        for(int i = 0; i < nums.length; i++)
            strs[i] = String.valueOf(nums[i]);
        //对字符串数组调用快速排序
        fastSort(strs, 0, strs.length - 1);
        //排序后直接拼接即可
        StringBuilder res = new StringBuilder();
        for(String s : strs)
            res.append(s);
        return res.toString();
    }
    
    //注意快排写法
    void fastSort(String[] strs, int l, int r) {
        if(l >= r) return;
        int i = l, j = r;
        String tmp = strs[i];
        while(i < j) {
            //难点，改写快排，使用compareTo进行比较 	
            while((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) >= 0 && i < j) j--;
            while((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) <= 0 && i < j) i++;
            tmp = strs[i];
            strs[i] = strs[j];
            strs[j] = tmp;
        }
        strs[i] = strs[l];
        strs[l] = tmp;
        fastSort(strs, l, i - 1);
        fastSort(strs, i + 1, r);
    }
}

```









#### 根据数字二进制下 1 的数目排序

给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。

如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。

请你返回排序后的数组。

```
输入：arr = [0,1,2,3,4,5,6,7,8]
输出：[0,1,2,4,8,3,5,6,7]
解释：[0] 是唯一一个有 0 个 1 的数。
[1,2,4,8] 都有 1 个 1 。
[3,5,6] 有 2 个 1 。
[7] 有 3 个 1 。
按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]
```



解题思路

![image-20200702205529988](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200702205529988.png)



bitCount（）方法的使用，统计二进制中1的个数

将计算的二进制结果乘1000000再加上元素，在排序时便可以以二进制结果为主，原元素为辅

解题实现

1）新建返回数组，统计每个数的处理结果

```
int[] res=new int[arr.length];
for(int i=0;i<arr.length;i++){
	arr[i]=Integer.bitCount(arr[i])*1000000+arr[i];
}
```

2）对返回数组排序

3）重新赋值返回数组再返回





### map辅助数组排序

map数组即元素出现次数数组



#### 上升下降字符串

给你一个字符串 s ，请你根据下面的算法重新构造字符串：

从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。
从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。
重复步骤 2 ，直到你没法从 s 中选择字符。
从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。
从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。
重复步骤 5 ，直到你没法从 s 中选择字符。
重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。

```
输入：s = "aaaabbbbcccc"
输出："abccbaabccba"
解释：第一轮的步骤 1，2，3 后，结果字符串为 result = "abc"
第一轮的步骤 4，5，6 后，结果字符串为 result = "abccba"
第一轮结束，现在 s = "aabbcc" ，我们再次回到步骤 1
第二轮的步骤 1，2，3 后，结果字符串为 result = "abccbaabc"
第二轮的步骤 4，5，6 后，结果字符串为 result = "abccbaabccba"
```



解题思路

![image-20200702202618552](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200702202618552.png)



用一个数组统计字符出现的次数，分别从小到大再从大到小遍历数组统计数组

解题实现

1）以一个26位的数组保存字符出现的次数

```
int[] map=new int[26];
char[] chars=s.toCharArray();
for(char c:chars){
	map[c-'a']+=1;
}
```

2）while循环，当返回值串长度不等于s的长度

​		从前往后遍历，再从后往前遍历，将字符加入返回值

```
for(int i=0;i<26;i++){
	if(map[i]==0){
		continue;
	}
	res.append((char)(i+'a'));
	map[i]-=1;
}
for(int i=25;i>=0;i--){
	if(map[i]==0){
		continue;
	}
	res.append((char)(i+'a'));
	map[i]-=1;
}
```

3）返回



#### 数组的相对排序

给你两个数组，arr1 和 arr2，

arr2 中的元素各不相同
arr2 中的每个元素都出现在 arr1 中
对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。

```
输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
输出：[2,2,2,1,4,3,3,9,6,7,19]
```



解题思路

创建一个map记录arr1中的值的次数，再遍历arr2，将其中的对应在map的元素放入返回数组，最后将未出现的数放入返回数组

解题实现

1）新建map数组，返回数组，将arr1存入map数组

```
for(int i=0;i<arr1.length;i++){
	map[arr1[i]]++;
}
```

2）遍历arr2，借助map数组，存入返回数组

```
int index=0;
for(int i=0;i<arr2.length;i++){
	while(map[arr2[i]]>0){
		res[index++]=arr2[i];
		map[arr2[i]]--;
	}
}
```

3）将未出现的数放入返回数组

```
for(int i=0;i<1001;i++){
	while(map[i]>0){
		res[index++]=i;
		map[i]--;
	}
}
```











不考虑内存 和 磁盘的限制

解题思路

基于双指针

解题实现

```java
	public int[] intersect(int[] nums1, int[] nums2) {
        List<Integer> res = new ArrayList<>();
        //先排序
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        for(int i = 0, j = 0; i < nums1.length && j < nums2.length; ){
        	//较小的那方移动，直到相等，存入返回值中
            if(nums1[i] > nums2[j]) j++;
            else if(nums1[i] < nums2[j]) i++;
            else {
                res.add(nums1[i]);
                i++;
                j++;
            }
        }
        return res.stream().mapToInt(Integer::valueOf).toArray();
    }
```





考虑内存与磁盘限制

解题思路

![image-20200702215326849](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200702215326849.png)

```
public int[] intersect2(int[] nums1, int[] nums2) {
        Map<Integer, Integer> map1 = new HashMap<>((int)(nums1.length / 0.75F + 1.0F));
        Map<Integer, Integer> map2 = new HashMap<>((int)(nums1.length / 0.75F + 1.0F));
        for(int i : nums1)
            map1.put(i, map1.getOrDefault(i, 0) + 1);
        for(int i : nums2)
            map2.put(i, map2.getOrDefault(i, 0) + 1);
        List<Integer> temp = new ArrayList<>();
        for(int key : map1.keySet()){
            if(map2.containsKey(key)){
                for(int i = 0; i < Math.min(map1.get(key), map2.get(key)); i++)
                    temp.add(key);
            }
        }
        int[] res = new int[temp.size()];
        for(int i = 0; i < res.length; i++)
            res[i] = temp.get(i);
        return res;
    }
```















### 逆序对

逆序对的定义

```
设有一个序列{a_1, a_2, a_3,...a_{n-1}, a_n},对于序列中任意两个元素ai,aj，若i<j,ai>aj，则说明ai和aj是一对逆序对。
```



#### 数组中的逆序对

困难

归并排序

```java
public class Solution {
    //统计逆序对的个数
    int cnt;
    public int InversePairs(int [] array) {
        if(array.length != 0){
            divide(array,0,array.length-1);
        }
        return cnt;
    }
 
    //归并排序的分治---分
    private void divide(int[] arr,int start,int end){
        //递归的终止条件
        if(start >= end)
            return;
        //计算中间值，注意溢出
        int mid = start + (end - start)/2;
 
        //递归 分
        divide(arr,start,mid);
        divide(arr,mid+1,end);
 
        //治
        merge(arr,start,mid,end);
    }
 
    private void merge(int[] arr,int start,int mid,int end){
        int[] temp = new int[end-start+1];
 
        //存一下变量
        int i=start,j=mid+1,k=0;
        //下面就开始两两进行比较，若前面的数大于后面的数，就构成逆序对
        while(i<=mid && j<=end){
            //若前面小于后面，直接存进去，并且移动前面数所在的数组的指针即可
            if(arr[i] <= arr[j]){
                temp[k++] = arr[i++];
            }else{
                temp[k++] = arr[j++];
                //a[i]>a[j]了，那么这一次，从a[i]开始到a[mid]必定都是大于这个a[j]的，因为此时分治的两边已经是各自有序了
                cnt = (cnt+mid-i+1)%1000000007;
            }
        }
        //各自还有剩余的没比完，直接赋值即可
        while(i<=mid)
            temp[k++] = arr[i++];
        while(j<=end)
            temp[k++] = arr[j++];
        //覆盖原数组
        for (k = 0; k < temp.length; k++)
            arr[start + k] = temp[k];
    }
}
```































































