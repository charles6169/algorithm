# 	位运算

## 概述

### 十/二进制换算

正整数转二进制

要点：除二取余，倒序排列，高位补零。

方法：将正的十进制数除以二，得到的商再除以二，依次类推直至商为0或1时为止，然后在旁边标出各步的余数，最后倒着写出来，高位补零。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200616225322719.png" alt="image-20200616225322719" style="zoom:80%;" />





### 逻辑运算

与（&）

两个操作数中位都为1，结果才为1，否则结果为0





非（~）





或（|）



异或（^）











## 实战技巧



### 位运算技巧



两个数字是否相同

`a^a==0`

```
int a = 10;
int b = 10;
if ((a ^ b) == 0) {
	System.out.println(true);
}
```



取出一个数最右端为1的那一位

`a &=-a`

```
public class Test {
    public static void main(String[] args) {
        int a=10010;
        a&=-a;
        System.out.println(a);
    }
}

```

其中`-a`是在计算机中就是`a`的补码表示，因为补码等于原码的反码+1，所以`a&-a`就是`a最右边一位为1，其他位为0的数`。



（3）判断 是否是2的n次方：x&x-1 ==0 

​		把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。

```
public class Test {
    public static void main(String[] args) {
        int a=128;
        if((a&a-1)==0){
            System.out.println(true);
        }
    }
}
```



（4）最低位二进制数，可以用来判断奇偶：(a&1)与0和1比较，如果等于0，那么为偶数，如果等于1那么为奇数。

```
public class Test {
    public static void main(String[] args) {
        int a=128;
        if((a&1)==0){
            System.out.println(true);
        }
    }
}
```



（5）一个数字除以2 ：a>>1

```
public class Test {
    public static void main(String[] args) {
        int a=128;
        a>>=1;
        System.out.println(a);
    }
}
```



（6）利用逻辑与`&&`的短路原理，可以实现类似`if`判断的功能

例如：实现1+2+3+……+n

```
//1.需利用逻辑与的短路特性实现递归终止。 2.当n==0时，(n>0)&&((sum+=Sum_Solution(n-1))>0)只执行前面的判断，为false，然后直接返回0；
//3.当n>0时，执行sum+=Sum_Solution(n-1)，实现递归计算Sum_Solution(n)。
    public int Sum_Solution(int n) {
        int sum = n;
        boolean ans = (n>0)&&((sum+=Sum_Solution(n-1))>0);
        return sum;
    }
```



（7）利用`&`和`^`实现加法

```
public int Add(int num1,int num2) {
        while(num2!=0){
            int tmp=num1^num2;
            num2=(num1&num2)<<1;//进位
            num1=tmp;
        }
        return num1;
    }
```



（8）由于一个数异或他本身等于0，那么将这个数组中的数依次异或，最终就可以得到那个只出现一次的数。

```
int xor=nums[0];
for(int i=1;i<nums.length;i++){
	xor^=nums[i];
}
```

（9）n&(-n)求的是一个二进制数的最低位的1对应的数，如10，转二进制为1010，其最低位数就是10，也就是2



回文数字判断

注意也可以用来判断伪回文数





​		不使用新的变量，交换两个变量的值。比如有两个变量a、b，希望交换它们的值。有两种不同的操作：
 * 1. 基于加减法 -- a = a + b; b = a - b; a = a - b;
 * 2. 基于位运算 -- a = a ^ b; b = a ^ b; a = a ^ b;









## 算法案例

#### 剑指 Offer-二进制中1的个数

请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```



解题思路

逐位判断 

![image-20200721222420873](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200721222420873.png)



 n \& (n - 1)

![image-20200721222933237](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200721222933237.png)



复杂度分析

![image-20200721222451438](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200721222451438.png)

算法实现

1）初始化返回值

2）对其按位判断，累积1的个数

3）返回

```java
public class Solution {
    public int hammingWeight(int n) {
        int res = 0;
        while(n != 0) {
            res += n & 1;
            //三目运算符
            n >>>= 1;
        }
        return res;
    }
}
```



方法二

```java
public class Solution {
    public int hammingWeight(int n) {
        int res = 0;
        while(n != 0) {
            res++;
            n &= n - 1;
        }
        return res;
    }
}
```



#### 剑指offer-不用加减乘除做加法

写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。





解题思路

![image-20200714222506713](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200714222506713.png)

异或^可以模拟 无进位和

&可以模拟进位





解题实现

1）分别定义无进位和进位值

2）当b不为0时循环

​		3）异或计算无进位和

​		4）与 和 左移1位 计算进位

​		5）a赋予无进位和，a赋予进位

6）返回a

```java
int add(int a, int b){
	int sum,carry;
    //当b不为0时循环
	while(b!=0){
		sum=a^b;
		carry=(a&b)<<1;
		a=sum;
		b=carry;
	}
	return a;
}
```





####  剑指 Offer -数组中只出现一次的数字

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

解题思路

利用额外空间可以有多种解法，但是如果不使用额外空间，只能用位运算

![image-20200709220026481](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200709220026481.png)

![image-20200709220039895](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200709220039895.png)





解题实现

```java
class Solution {
    public int singleNumber(int[] nums) {
        int single = 0;
        for (int num : nums) {
            //挨个与运算，最后得到那个数字就是出现一次的数字
            single ^= num;
        }
        return single;
    }
}
```



#### 剑指 Offer-只出现一次的数字 II

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

解题思路

本题可以用哈希表、位运算和有限状态自动机，位运算只能靠硬背了，写不来就用哈希表法

使用[位运算符](https://leetcode-cn.com/problems/single-number-ii/solution/zhi-chu-xian-yi-ci-de-shu-zi-ii-by-leetcode/[https://wiki.python.org/moin/BitwiseOperators)可以实现 \mathcal{O}(1)O(1) 的空间复杂度。

![image-20200709220322193](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200709220322193.png)

解题实现

位运算法

```java
class Solution {
  public int singleNumber(int[] nums) {
    int Once = 0, Twice = 0;

    for (int num : nums) {
      //死记硬背：交替运算，非+与+异或  
      Once = ~Twice & (Once ^ num);
      Twice = ~Once & (Twice ^ num);
    }
	//返回Once
    return Once;
  }
}
```





哈希表法

```java
public int singleNumber(int[] nums) {
        HashMap<Integer,Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i],map.getOrDefault(nums[i],0)+1);
        }
        for(Map.Entry<Integer,Integer> d:map.entrySet()){
            if(d.getValue() == 1) return d.getKey();
        }
         return -1;
    }
```































