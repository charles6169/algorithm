# 贪心算法

## 概念介绍

https://www.jianshu.com/p/ab89df9759c8

定义

​		贪心算法，又名贪婪法，是寻找最优解问题的常用方法，这种方法模式一般将求解过程分成若干个步骤，但每个步骤都应用贪心原则，选取当前状态下最好/最优的选择（局部最有利的选择），并以此希望最后堆叠出的结果也是最好/最优的解。{看着这个名字，贪心，贪婪这两字的内在含义最为关键。这就好像一个贪婪的人，他事事都想要眼前看到最好的那个，看不到长远的东西，也不为最终的结果和将来着想，贪图眼前局部的利益最大化，有点走一步看一步的感觉。}

基本思路



贪心与动态规划之间关系

动规是贪心的泛化，贪心是动规的特例

## 算法研究



### 解决问题的基本步骤

1.建立数学模型来描述问题。

2.把求解的问题分成若干个子问题。

3.对每一子问题求解，得到子问题的局部最优解。

4.把子问题的解局部最优解合成原来解问题的一个解。





### 贪心策略的选择

贪心策略的前提是：局部最优策略能导致产生全局最优解。

​		实际上，贪心算法使用的情况比较少，一般对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析可以做出判断。

​		用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此一定要注意判断问题是否适合采用贪心算法策略，找到解是否一定是问题的最优解。

### 实现模板

从问题的某一初始解出发：

while （能朝给定总目标前进一步）

{ 利用可行的决策，求出可行解的一个解元素；}

由**所有解元素组合**成问题的一个可行解。





## 经典案例

#### 分发饼干

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

![image-20200519122429962](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200519122429962.png)



解题思路

![image-20200519122835327](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200519122835327.png)



解题实现

1）对两个数组判空，对两个数组排序，初始化饼干和小孩的下标指针均为0

```
if(g==null||s==null){
	return 0;
}
Arrays.sort(g);
Arrays.sort(s);
int gi=0; //小孩
int si=0; //饼干
```

2）while循环，当两个数组的下标均不越界时循环

​		3）判断：当小孩的胃口小于饼干大小时，小孩下标++

​		4）饼干下标++

```
while(gi<g.length&&si<s.length){
	if(g[gi]<=s[si]){
		gi++;
	}
	si++;
}
```

5）返回gi



#### 分割平衡字符串

在一个「平衡字符串」中，'L' 和 'R' 字符的数量是相同的。

给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。

返回可以通过分割得到的平衡字符串的最大数量。

![image-20200519124702873](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200519124702873.png)

解题思路

![image-20200519124733219](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200519124733219.png)

解题实现

```
class Solution {
    public int balancedStringSplit(String s) {
        int R = 0;
        int L = 0;
        int res = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == 'R') {
                R++;
            } else {
                L++;
            }
            if (R == L) {
                res++;
                R = 0;
                L = 0;
            }
        }
        return res;
    }
}
```



#### 删列造序

给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。

你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的，然后请你返回 D.length 的最小可能值。

删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，形式上，第 n 列为 [A[0][n], A[1][n], ..., A[A.length-1][n]]）。

![image-20200519130116759](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200519130116759.png)



解题实现

对于每一列，我们检查它是否是有序的。如果它有序，则将答案增加 1，否则它必须被删除。

```
class Solution {
    public int minDeletionSize(String[] A) {
        int ans = 0;
        for (int c = 0; c < A[0].length(); ++c)
            for (int r = 0; r < A.length - 1; ++r)
                if (A[r].charAt(c) > A[r+1].charAt(c)) {
                    ans++;
                    break;
                }

        return ans;
    }
}
```





#### 玩筹码

数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。

你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）：

将第 i 个筹码向左或者右移动 2 个单位，代价为 0。
将第 i 个筹码向左或者右移动 1 个单位，代价为 1。
最开始的时候，同一位置上也可能放着两个或者更多的筹码。

返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。

![image-20200519133801730](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200519133801730.png)

解题思路

![image-20200519131055996](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200519131055996.png)

解题实现

统计筹码数组的奇偶数个数中较小那个

```
class Solution {
    public int minCostToMoveChips(int[] chips) {
        int odd = 0,even = 0;
        for(int data : chips)
            if(data % 2 == 1)
                odd++;
            else
                even++;
        
        return Math.min(odd,even);
    }
}
```





#### 两地调度

公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。

返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。

![image-20200519132727099](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200519132727099.png)

解题思路

![image-20200519132749446](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200519132749446.png)



解题实现

1）重载Arrays.sort的compare方法，按照 `price_A - price_B` 从小到大排序

```
Arrays.sort(costs,new Compara<int[]>(){
	@Override
	public int compare(int[] o1,int[] o2){
		return o1[0]-o1[1]-(o2[0]-o2[1]);
	}
}
```

2）初始化返回值，计算N为数组长度的一半

3）遍历数组，i 从 0 到 N （**注意只计算一半**） 前一半人去A地，后一半人去B地

```
res+=costs[i][0]+costs[i+n][1];
```

4）返回









解题思路

每排一次序，进行一次操作，操作窗口只是最后两个数组元素

解题实现

1）先获取到数组最后位置下标

2）遍历 i 从 0到数组倒数第二位

​	3）数组排序

​	4）计算最后一位为最后一位减前一位

​	5）倒数第二位置为0

```
Arrays.sort(stones);
stones[index]-=stones[index-1];
stones[index-1]=0;
```

6）返回数组最后一位









