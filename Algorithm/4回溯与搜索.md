# 回溯与搜索

## 概述

定义：回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。



Backtracking就是简单粗暴的试错方法！

```
back反向
trace轨迹
沿轨迹反向行进
就是从哪来的回哪去
```

​		回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法。适用于求解组合数较大的问题。


注意：

```
1.当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

2.扩大当前候选解的规模并继续试探的过程叫做向前试探。

3.用回溯法求解问题时常常使用递归方法进行试探，或使用栈帮助向前试探和回溯。
```

​	



**基本概念介绍**

1.约束函数：约束函数是根据题意定出的。通过描述合法解的一般特征用于去除不合法的解（即使这个解并不是完整的解），从而避免继续搜索出这个不合法解的剩余部分，起到了剪值函数的作用。因此，约束函数是对于解空间树上的任何节点都有效、等价的。

2.状态空间树：状态空间树是一个对所有解的图形描述。

3.扩展节点：当前正求出它的子节点的节点，在DFS中，只允许有一个扩展节点。

4.活节点：通过与约束函数对照，节点本身和其父节点均满足约束函数要求的节点。

5.死节点: 与活节点正好相反，死节点是在与约束函数对照中，不满足约束函数的节点。那么就不需要求该节点的子节点情况了。





### 算法思想

​		回溯题的第一步都是先画图，画图是非常重要的，只有画图才能帮助我们想清楚递归结构，想清楚如何剪枝。就拿题目中的示例，想一想人手动操作是怎么做的，一般这样下来，这棵递归树都不难画出。而回溯的具体实现方法是基于递归

即在画图的过程中思考清楚：

```
1、分支如何产生；

2、题目需要的解在哪里？是在叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？

3、哪些搜索是会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？
```

![image.png](https://pic.leetcode-cn.com/6a464ba95a7ad1c247aa39610535984c241e6b95148f8bc36b02908a190b1d54-image.png)



## 算法模板

#### 通用模板1

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200526055437889.png" alt="image-20200526055437889" style="zoom:80%;" />

回溯的四个步骤

![image-20200526055539763](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200526055539763.png)

```
1 非法判断
2 递归结束判断
3 遍历并递归
4 递归后回溯
```





#### 通用模板2

```
for 选择 in 选择列表:
    # 做选择
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表)
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表
```

**我们只要在递归之前做出选择，在递归之后撤销刚才的选择**，就能正确得到每个节点的选择列表和路径。





#### 代码模板

一般会有两种情况，分别是可重复和不可重复两种

可重复全排列

主方法部分

```java
public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res=new ArrayList<>();
        Deque<Integer> path=new ArrayDeque<>();
        Set<Integer> memory=new HashSet<>();
        int len=nums.length;
        if(len==0){
            return res;
        }
        dfs(nums,len,0,memory,path,res);
        return res;
    }
```

回溯部分

```java
public void dfs(int[] nums,int len,int depth,Set<Integer> memory,Deque<Integer> path,List<List<Integer>> res){
        if(len==depth){
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i=0;i<len;i++){
            if(!memory.contains(i)){
                memory.add(i);
                path.addLast(nums[i]);
                dfs(nums,len,depth+1,memory,path,res);
                path.removeLast();
                memory.remove(i);
            }
        }

    }
```



不可重复全排列

主方法部分

```java
public static List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Deque<Integer> path = new ArrayDeque<>();
        Set<Integer> memory = new HashSet<>();
    	//不可重复全排列需要对数组排序
        Arrays.sort(nums);
        int len = nums.length;
        if (len == 0) {
            return res;
        }
        dfs(nums, len, 0, memory, path, res);
        return res;
    }
```

回溯部分

```java
public static void dfs(int[] nums, int len, int depth, Set<Integer> memory, Deque<Integer> path
            , List<List<Integer>> res) {
        if (len == depth) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < len; i++) {
            if (!memory.contains(i)) {
                if (i > 0 && nums[i] == nums[i - 1]&&!memory.contains(i-1)) {
                    continue;
                }
                memory.add(i);
                path.addLast(nums[i]);
                dfs(nums, len, depth + 1, memory, path, res);
                path.removeLast();
                memory.remove(i);
            }
        }
    }
```

增加候选数组排序

```
Arrays.sort(nums);
```

增加重复元素判断

```
if (i > 0 && nums[i] == nums[i - 1]&&!memory.contains(i-1)) {
    continue;
}
```



#### 回溯的两大利器

##### 排序大法

​		可能包含重复元素的整数数组，求解集不能包含重复的子集，需要进行排序，否则，如果相等的元素不连续就无法通过测试

```
 Arrays.sort(nums);
```



##### 记忆化策略



1）使用一个集合Set或一个Map保存已搜索过的数据，达到记忆化的效果。

元素不能重复使用自己时，把已使用的数据存放到记忆化集合中

```
if (!memory.contains(i)) {
    memory.add(i);
    path.addLast(i);
    dfs(n, k, i,depth + 1, memory,path, res);
    path.removeLast();
    memory.remove(i);
}
```



当候选数组中元素可能重复时，比较前后数据剪枝，参考子集II

```
if (i > 0 && nums[i] == nums[i - 1]&&!memory.contains(i-1)) {
    continue;
}
```



2）用一个布尔数组表示某个位置上的元素是否可以访问

```

boolean[] visited=new boolean[len];


if(!visited[i]){
	...
	visited[i]=true;
	...
	visited[i]=false;
}
```



##### 标记搜索入口

各组合元素不能重复，而且个组合之间的元素也不能一样，且元素不能重复使用自己，就需要标记上次已回溯到了的位置，见组合总和III

```
	for (int i = begin; i <= n; i++) {
            if (!memory.contains(i)) {
                memory.add(i);
                path.addLast(i);
                dfs(n, k, i,depth + 1, memory,
                        path, res);
                path.removeLast();
                memory.remove(i);
            }
        }
```

​	i 从 begin 开始，且传入下一级为 i ，即回溯不会回溯到最前面，而是回溯到上次搜索的入口。





#### 剪枝策略

 		剪枝策略就是在搜索过程中利用过滤条件来剪去完全不用考虑（已经判断这条路走下去得不到最优解）的搜索路径，从而避免了一些不必要的搜索，大大优化了算法求解速度，还保证了结果的正确性。

应用到回溯算法中，我们就可以提前判断当前路径是否能产生结果集，如果否，就可以提前回溯。而这也叫做可行性剪枝(本文重点讨论)。

另外还有一种叫做最优性剪枝，每次记录当前得到的最优值，如果当前结点已经无法产生比当前最优解更优的解时，可以提前回溯，eg：分支限界算法。


​		想通过剪枝优化来提高算法高效性，又要保证结果正确性，还要保证剪枝的准确性。是非常难得的。而这也是这个**剪枝优化算法的好坏评判标准**。往往剪得不当，就会事而其反，得不偿失.......







#### 解题经验

1）回溯的 一般都是深度搜索，输入参数一般比较多

2）结果集的两种类型，可重复和不可重复，分别考虑



## 深度优先搜索

深度优先遍历有点像**二叉树的前序遍历**过程

![image-20200220232324052](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200220232324052.png)



**深度优先搜索的步骤分为 1.递归下去 2.回溯上来。顾名思义，深度优先，则是以深度为准则，先一条路走到底，直到达到目标。这里称之为递归下去。否则既没有达到目标又无路可走了，那么则退回到上一步的状态，走其他路。这便是回溯上来。**

*DFS问题可理解为递归和回溯的结合增强体*，*DFS的重要点在于状态回溯*

**具体步骤**

```
（1）设置初始化的方案（给变量赋初值，读入已知数据等）；

（2）选择所到深度层（k）中其中的一个节点进行试探，如果k层的节点已经全部都试探完毕，则进入（7）；

（3）如果试探不成功（不满足约束条件），则转入（2）；

（4）如果试探成功，则进入下一个深度层进行试探。

（5）如果正确解还没找到，则进入（2）；

（6）如果找到了正解，如果问题只求其中的一个解，那么可以退出程序了，如果是求一组解，那么将该种解存储；

（7）退回上一步的状态（深度为k-1时，变量的状态），如果没有退到头，则进入（2）；

（8）已退到头则结束或打印无解。
```





## 广度优先搜索

​	"广度优先搜索"是一种通过逐层遍历所有访问对象，从而找到通过最短节点数到达目标的算法。	

广度优先遍历就类似于**树的层序遍历**



### 算法研究

#### 方向判定

首先判断一道题是否应该使用搜索算法

​		寻找所有可能的子集（所有可能的方案），90%以上使用搜索算法





#### 如何去重

错误的去重：找到所有的结果再去重





### 解题经验

**解决一个回溯问题，实际上就是一个决策树的遍历过程，而其主体便是递归，相当于一个增强版的递归问题**

 ![image-20200219224504268](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200219224504268.png)

**回溯的几个要素**

```
**遍历递归参数**
​	一般为索引，回溯问题通常为二维问题，往往涉及到两层的遍历
**终止条件**
​	返回true或者false，当触发终止条件时结束回溯
**递推检查体**
​	如果是迷宫搜索，需要确定搜索模式，如*上下左右*，一般和终止条件配合
**单级功能**
​	单次递归所实现的功能
**回溯返回值**
​	代表是否搜索到目标 ，结束一次回溯
```

**解题步骤**

（1）明确问题的解空间树内容，比如，在求组合问题时，最后有效解中元素是否可重复的，元素个数是否是固定的等。且保证问题的解空间中应至少包含问题的一个解。

（2）确定结点的扩展搜索规则，在回溯法中，就是深度优先遍历规则。扩展节点就是当前正在求出它的子节点的节点，在DFS中，只允许有一个扩展节点。

（3）构造约束条件。作为剪枝函数，避免无效搜索。

​		回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，某种程度上说，动态规划的暴力求解阶段就是回溯算法

 ![image-20200219231132505](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200219231132505.png)



## 算法案例

回溯精讲合集

https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/



#### 剑指offer-机器人的运动范围

地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？



解题思路

题目中有一个计算横纵坐标数位之和的操作，这不是题目的关键点，将这个计算数位之和的方法封装起来不要干扰主要的解题逻辑。



利用DFS解决本题

![image-20200715212402289](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200715212402289.png)



解题实现

1）新建全局变量 m,n,k，新建visited数组（注意定义为全局变量）

2）调用深度搜索函数

```java
int m,n,k;
public int movingCount(int m, int n, int k) {
    this.m=m;
    this.n=n;
    this.k=k;
    //标记访问过的位置
    boolean[][] visited=new boolean[m][n];
    return dfs(0,0,0,visited);
}
```

深度搜索函数，传入参数为当前位置（i，j）和当前位的数位和

1）如果 坐标越界 或者 数位和大于k 或者 已经访问过，则停止当前方向的深搜 return 0

2）标记已访问

3）向下或者向右深搜（注意，只向下和向右）

```java
private int dfs(int i, int j, int sum, boolean[][] visited) {
    //如果 坐标越界 或者 数位和大于k 或者 已经访问过，则停止当前方向的深搜
    if (i==m||j==n||sum>k||visited[i][j])return 0;
    //标记为已访问
    visited[i][j]=true;
    //向下或者向右深搜
    return 1+dfs(i+1,j,sums(i+1,j),visited)+dfs(i,j+1,sums(i,j+1),visited);
}
```



计算数位和函数

```java
public int sums(int x,int y){
    int ans=0;
    while (x != 0) {
        ans+=x%10;
        x/=10;
    }
    while (y != 0) {
        ans+=y%10;
        y/=10;
    }
    return ans;
}
```



### 排列问题

三种全排列问题

```
全排列

下一个排列

第 k 个排列
```



#### 全排列

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

![image-20200528054814684](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200528054814684.png)

解题思路

回溯树形图

![image-20200528045245778](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200528045245778.png)



从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。我们不妨把这棵树称为回溯算法的「决策树」。

为啥说这是决策树呢，因为你在每个节点上其实都在做决策。比如说你站在下图的红色节点上：

![img](https://pic.leetcode-cn.com/ad452f4728a137f627d37054e3232fcf46d4b00359d14c08c287f66d01a45ecd-file_1575263193043)

你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。

现在可以解答开头的几个名词：[2] 就是「路径」，记录你已经做过的选择；[1,3] 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候。

如果明白了这几个名词，可以把「路径」和「选择」列表作为决策树上每个节点的属性，比如下图列出了几个节点的属性：

![img](https://pic.leetcode-cn.com/2ab7361d49071c4a9da0fefb5f7a36fbc9e11a8055f14bef6e6f1201f7b84410-file_1575263193064)

我们定义的 backtrack 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列。

复杂度分析

![image-20200528050505431](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200528050505431.png)





解题实现

1）新建返回值列表，对数组空值判定

2）新建记忆集合，存放使用过的数字，新建路径双向队列

3）调用深度搜索函数，输入数组，数组长度，深度，记忆集合，路径，返回值

​		4）当深度等于数组长度时，队列加入返回值列表，返回

​		5）遍历，i从0到数组长度，判断i是否已经被使用，如果没有被使用，执行回溯模块

​		6）记忆集合加入i，路径队列加入数组[i]，调用递归，路径队列移除数组[i]，记忆集合移除i

```
for(int i=0;i<len;i++){
	if(!memory.contains(i)){
		memory.add(i);
		path.addLast(nums[i]);
		dfs(nums,len,depth+1,memory,path,res);
		path.removeLast();
		memory.remove(i);
	}
}
```

7）返回





#### 全排列 II

给定一个可包含重复数字的序列，返回所有不重复的全排列。

![image-20200528064002757](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200528064002757.png)



解题思路

![image-20200528064038346](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200528064038346.png)

解题实现

其他部分和上一题一致

增加候选数组排序

```
Arrays.sort(nums);
```

增加重复元素判断

```
if (i > 0 && nums[i] == nums[i - 1]&&!memory.contains(i-1)) {
    continue;
}
```





#### 活字印刷

你有一套活字字模 `tiles`，其中每个字模上都刻有一个字母 `tiles[i]`。返回你可以印出的非空字母序列的数目。

**注意：**本题中，每个活字字模只能使用一次。

```
输入："AAB"
输出：8
解释：可能的序列为 "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA"。
```





解题思路

相当于全排列 II 的进阶版

全排列 II 计算的是整个字符串的排列组合，这里计算的是任意个元素的排列组合

我们只需要边递归边计算组合数即可，新添加一个元素都是一种新的组合数 （代码与 全排列 II 差别不大）



注意visited的用法，表示某一位上元素是否可以访问



解题实现

1）新建返回值为0，字符串数组化，获取数组长度，访问布尔数组，对字符数组排序

2）调用搜索函数  传入字符数组，索引，数组长度，访问布尔数组



深度搜索函数

1）当n等于len时，表示全部添加，直接返回

2）遍历 i 从0到 len-1

​	3）首先判断访问布尔数组

​			4）如果 i 大于0，且字符数组前后位置值相同，且访问布尔数组 i - 1位存在，直接继续

​			5）返回值自增

​			6）设置访问布尔数组为真

​			7）回溯，传入索引+1

​			8）设置访问布尔数组为假

```
for(int i=0;i<len;i++){
	if(!visited[i]){
		if(i>0&&chars[i]==chars[i-1]&&!visited[i-1]){
			res++;
			visited[i]=true;
			dfs(chars,index+1,visited);
			visited[i]=false;
		}
	}
}
```





#### 括号生成

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

![image-20200528071129906](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200528071129906.png)

解题思路

![image-20200528070622522](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200528070622522.png)

![image-20200528070654186](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200528070654186.png)



解题实现

1）新建返回值列表，路径字串，n的零值判定

```
List<String> res=new ArrayList<>();
if(n==0){
	return res;
}
```

2）调用深度搜索 传入路径字符串，左剩余值，右剩余值，返回值列表

​		3）回溯完成条件：左右均为零时，加入返回值列表，返回

​		4）当左剩余大于右剩余时，直接返回

```
if(left>right){
	return;
}
```

​		5）当左剩余和右剩余大于零时，分别对左右递归

```
if(left>0){
	dfs(path+"(",left-1,right,res);
}
if(right>0){
	dfs(path+")",left,right-1,res);
}
```



#### 	 电话号码的字母组合

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt="img" style="zoom:80%;" />

```
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```

解题思路

![image-20200529035400326](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200529035400326.png)

时间复杂度

- O(2^len(n))*O*(2*len(*n))；
- 这是个指数级的算法，很慢，家用计算机最多处理 `len(n) = 20` 的量级；

解题实现

1）新建手机号Map

2）新建返回值，空值判定，调用深度搜索  传入参数：字符串，索引值，路径，返回值



深度搜索函数

​		3）回溯结束条件：索引值等于数字长度，路径加入返回值列表，返回

​		4）获取当前字符，通过当前字符获取对应手机号字符串

​		5）遍历手机号字符串，回溯，索引自增，路径增加字符

```
if(index==digits.length()){
	res.add(path);
	return;
}
char c=digits.charAt(index);
String letter=phoneMap[c-'0'];
for(int i=0;i<letter.length();i++){
	dfs(digits,index+1,path+letter.charAt(i),res);
}
```

6）返回



#### 划分为k个相等的子集

给定一个整数数组 `nums` 和一个正整数 `k`，找出是否有可能把这个数组分成 `k` 个非空子集，其总和都相等。

```
输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4
输出： True
说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。

```



解题思路

![image-20200614215857112](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200614215857112.png)



解题实现

1）新建总和和最大元素，计算总和并找到最大元素，当数组无法以k划分或者划分后均值小于数组最大元素时，认为无法实现，直接返回false

```
for(int i=0;i<nums.length;i++){
	sum+=nums[i];
	if(maxNum<nums[i]) maxNum=nums[i];
}
```

2）新建记忆化数组

3）调用回溯函数  传入参数：数组，k，目标值，累积值，起始索引，记忆化数组

```
dfs(nums,k,sum/k,0,0,memory);
```



回溯函数 	

1）判断，如果k等于0，返回真

2）如果当前值已达到均值，构建下一次集合，k-1

```
if(cur==target){
	dfs(nums,k-1,target,0,0,memory);
}
```

3）遍历数组，如果记忆化数组中不存在，且当前值＋数组值小于等于目标值

​		4）记忆化操作，置true

​		5）调用回溯，如果为真，返回true

​		6）记忆化操作，置false

```
for(int i=0;i<nums.length;i++){
	if(!memory[i]&&cur+nums[i]<=target){
		memory[i]=true;
		if(dfs(nums,k,target,cur+nums[i],i+1,memory)) return true;
		momory[i]=false;
	}
}
```

7）返回false







#### 组合总和

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200526061000220.png" alt="image-20200526061000220" style="zoom:80%;" />

解题思想

![image-20200526061045222](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200526061045222.png)

说明：

蓝色结点表示：尝试找到组合之和为该数的所有组合，怎么找呢？逐个减掉候选数组中的元素即可；
以 target = 7 为根结点，每一个分支做减法；
减到 0 或者负数的时候，到了叶子结点；
减到 0 的时候结算，这里 “结算” 的意思是添加到结果集；
从根结点到叶子结点（必须为 0）的路径，就是题目要我们找的一个组合。



直接搜索会得到许多重复的结果，必须做去重

![image-20200526061108178](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200526061108178.png)

​		画出图以后，我看了一下，我这张图画出的结果有 44 个 00，对应的路径是 [[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]，而示例中的解集只有 [ [7], [2, 2, 3] ]，很显然，重复的原因是在较深层的结点值考虑了之前考虑过的元素，因此我们需要设置“下一轮搜索的起点”即可（这里可能没有说清楚，已经尽力了）。



**去重复**
在搜索的时候，需要设置搜索起点的下标 begin ，由于一个数可以使用多次，下一层的结点从这个搜索起点开始搜索；
在搜索起点 begin 之前的数因为以前的分支搜索过了，所以一定会产生重复。

**剪枝提速**
如果一个数位搜索起点都不能搜索到结果，那么比它还大的数肯定搜索不到结果，基于这个想法，我们可以对输入数组进行排序，以减少搜索的分支；

排序是为了提高搜索速度，非必要；

搜索问题一般复杂度较高，能剪枝就尽量需要剪枝。把候选数组排个序，遇到一个较大的数，如果以这个数为起点都搜索不到结果，后面的数就更搜索不到结果了。

解题实现

1）新建返回值列表，获取候选数组长度，对候选数组排序，调用深度搜索函数

传入参数：

```
 candidates 数组输入
 len        输入数组的长度，冗余变量 
 residue    剩余数值
 begin      本轮搜索的起点下标
 path       从根结点到任意结点的路径队列
 res        结果集变量
```

```
 private void dfs(int[] candidates,
                     int len,
                     int residue,
                     int begin,
                     Deque<Integer> path,
                     List<List<Integer>> res) {
```



深度搜索函数		

3）如果剩余数值等于0，那么说明到达叶子节点，将path加入res，返回

```
if(residue==0){
	res.add(new ArrayList<>(path));
}
```

​		4）遍历 i 从 begin 下标到len-1

​				5）判断剩余数值如果小于当前数，直接退出（在数组有序的前提下，剪枝）

​				6）路径队列尾插当前数

​				7）调用深度搜索，剩余数值改变为相减后的值

​				8）回溯，路径队列尾删

```
if(residue<candidates[i]){
	break;
}
path.addLast(candidates[i]);
dfs(candidates,len,residue-candidates[i],i,path,res);
path.removeLast();
```



9）返回







####  组合总和 II

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明：

所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200527041521637.png" alt="image-20200527041521637" style="zoom:80%;" />

解题实现

​		由于`candidates` 中的每个数字在每个组合中只能使用一次。因此需要增加一条判断，即candidates[i]==candidates[i-1]时需要触发剪枝，注意这里剪枝的手段是直接跳过当次循环

```
if(i>begin&&candidates[i]==candidates[i-1]){
	continue;
}
```



#### 组合总和 III

​		找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

所有数字都是正整数。
解集不能包含重复的组合。 

![image-20200528034516023](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200528034516023.png)

解题思路

![image-20200528034600276](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200528034600276.png)





解题实现

1）新建返回值列表  路径列表   记忆化集合

2）调用深度搜索函数   传入参数： k n 1 路径双向队列  返回值列表



深度搜索函数

​		3）回溯终止条件：当**k小于0或n小于0**时直接返回

```
if(k<0||n<0){
	return;
}
```

​		4）当k等于0且n等于0时，判断如果路径队列不为空时，直接加入返回值列表，返回

```
if(k==0 && n==0){
	if(!path.isEmpty()){
		res.add(new ArrayList<>(path));
	}
	return;
}
```

​		5）遍历 i 从begin到9

​			6）回溯入口，路径队列加入i

​			7）递归，k-1，n-i，begin自增

​			8）回溯出口，弹出

```
for(int i=begin;i<10;i++){
	if(!memory.contains(i)){
	    memory.add(i);
        path.addLast(i);
        dfs(k-1,n-i,++begin,set,path,res);
        path.removeLast();
        memory.remove(i);
	}
	
}
```





#### 矩阵中的路径

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

[["a","b","c","e"],
["s","f","c","s"],
["a","d","e","e"]]

但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```



解题思路

![image-20200608233743288](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200608233743288.png)

![image-20200608233843626](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200608233843626.png)

复杂度分析

![image-20200608233914328](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200608233914328.png)

本题为回溯解决

解题实现

1）单词转换为字符数组

2）双层遍历：i,j遍历board数组

3）调用返回深度搜索函数，传入参数：board，words，i，j，0



深度搜索函数

1）对越界和单词不相等时，返回false

```
if(i>board.length||i<0||j>board[0].length||j<0||board[i][j]!=word[k]){
	return false;
}
```

2）如果k等于word.length - 1时，回溯结束，返回true

3）回溯入口，保存board[i] [j]到temp，并设置board[i] [j]为'/'，防止重复访问

```
char temp=board[i][j];
board[i][j]='/';
```

4）分别对四个方向进行回溯， i + 1, j， i - 1, j，i, j + 1，i , j - 1，结果保存res

```
boolean res=dfs(board,word,i+1,j,k+1)||
		   dfs(board,word,i-1,j,k+1)||
		   dfs(board,word,i,j+1,k+1)||
		   dfs(board,word,i,j-1,k+1);
```

5）回溯，board[i] [j]重新赋值temp

```
board[i][j]=temp;
```

6）返回结果







#### 分割回文串

给定一个字符串 *s*，将 *s* 分割成一些子串，使每个子串都是回文串。

返回 *s* 所有可能的分割方案。

```
输入: "aab"
输出:
[
  ["aa","b"],
  ["a","a","b"]
]
```



解题思路

![image-20200604035911001](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200604035911001.png)

![image-20200604035949936](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200604035949936.png)



解题实现

1）获取数组长度，新建返回值列表，若数组长度为0，直接返回返回值列表，新建路径队列

2）调用深度搜索函数，传入参数：字符串，起始字符的索引， 字符串 s 的长度，路径队列，返回值列表

```
dfs(s,0,len,path,res);
```

深度搜索函数		

​		3）如果索引等于数组长度，返回值列表加入路径队列，返回

​		4）遍历i从start到数组长度

​			5）判断子串是否回文串，如果不是，直接继续continue

​			6）路径队列加入字串（start --> i+1)，回溯调用函数，注意起始索引 i+1，路径队列移除字串

```
for(int i=start;i<len;i++){
	if(!check(s,start,i)){
		continue;
	}
	path.addLast(s.substring(start,i+1));
	dfs(s,i+1,len,path,res);
	path.removeLast();
}
```

7）返回



回文串判断函数，传入参数：字串，始终索引

1）while循环，当left小于right时

​		2）判断左右字符是否相等，如果不等，直接返回false

​		3）left自增，right自减

```
while(left<right){
	if(s.charAt(left)!=s.charAt(right)){
		return false;
	}
	left++;
	right--;
}
```

4）返回true













#### 组合

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

```
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```



解题实现

和组合总和III基本一致

```
class Solution {
    public static List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new ArrayList<>();
        Deque<Integer> path = new ArrayDeque<>();
        Set<Integer> memory = new HashSet<>();
        if (n == 0) {
            return res;
        }
        dfs(n, k, 1,0, memory,
                path, res);
        return res;
    }

    public static void dfs(int n, int k, int begin,int depth, Set<Integer> memory, Deque<Integer> path, List<List<Integer>> res) {
        if (depth == k) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = begin; i <= n; i++) {
            if (!memory.contains(i)) {
                memory.add(i);
                path.addLast(i);
                dfs(n, k, i,depth + 1, memory,
                        path, res);
                path.removeLast();
                memory.remove(i);
            }
        }
    }
}
```





#### 子集

给定一组**不含重复元素**的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

```
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

```

解题思路

![image-20200529054029280](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200529054029280.png)

解题实现

1）新建返回值列表，路径列表，记忆集合

2）调用深度搜索函数



深度搜索函数

​	3）**直接将空的路径列表加入返回值**

​	4）遍历，i 从 begin 到数组长度-1

​	5）判断记忆集合是否已有i，路径列表加入树组[ j ]，操作记忆集合

​	6）调用搜索，j 自增

​	7）路径列表移除，操作记忆集合

```
		if (!memory.contains(i)) {
                memory.add(i);
                path.addLast(nums[i]);
                dfs(nums, begin + 1, memory, path, res);
                path.removeLast();
                memory.remove(i);
            }
```





#### 子集 II

给定一个可能包含重复元素的整数数组 ***nums***，返回该数组所有可能的子集（幂集）。

**说明：**解集不能包含重复的子集。

```
输入: [1,2,2]
输出:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
```

解题实现

```
public class SubsetsWithDup {
    public static List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Deque<Integer> path = new ArrayDeque<>();
        Set<Integer> memory = new HashSet<>();
        dfs(nums, 0, memory, path, res);
        return res;
    }

    public static void dfs(int[] nums, int begin, Set<Integer> memory, Deque<Integer> path, List<List<Integer>> res) {
        res.add(new ArrayList<>(path));
        for (int i = begin; i < nums.length; i++) {
            if (i > 0 && nums[i] == nums[i - 1] && !memory.contains(i - 1)) {
                continue;
            }
            if (!memory.contains(i)) {
                memory.add(i);
                path.addLast(nums[i]);
                dfs(nums, begin + 1, memory, path, res);
                path.removeLast();
                memory.remove(i);
            }

        }

    }
}
```



总结：

子集1为标准的回溯问题，返回值列表，路径列表，记忆集合三连，其特点是候选数组中没有重复元素，而子集2中就比子集1多了一个候选数组元素重复，因此需要用前一位元素进行判断

```
if (i > 0 && nums[i] == nums[i - 1] && !memory.contains(i - 1)) {
      continue;
}
```





#### 字母大小写全排列

给定一个字符串`S`，通过将字符串`S`中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

```
示例:
输入: S = "a1b2"
输出: ["a1b2", "a1B2", "A1b2", "A1B2"]

输入: S = "3z4"
输出: ["3z4", "3Z4"]

输入: S = "12345"
输出: ["12345"]

```



解题思路

![image-20200529070549540](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200529070549540.png)

![image-20200529070601718](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200529070601718.png)

注意特殊的双递归，第一个递归使得先进入到最底层，第二个递归实现分支的展开



解题实现

1）获取字符串长度，新建返回值列表，空值判定，新建路径数组

2）调用深度搜索

深度搜索函数

​		3）回溯条件：如果索引等于数组长度，回溯结束

​		4）路径数组获取字符串索引位

​		5）直接进行一次回溯 （先回溯到最底部）

```
path[index]=S.charAt(index);
dfs(S,index+1,len,path,res);
```

​		6）判断索引位是否字母

​				7）如果是，执行大小写操作

​				8）回溯

```
if(Character.isLetter(S.charAt(index))){
	path[index]=(char)(S.charAt(index)^(1<<5));
	dfs(S,index+1,len,path,res);
}
```







迷宫问题

迷宫问题(MazePath)的求解——利用回溯法(backtracking)

https://blog.csdn.net/cainv89/article/details/51477947

可视化参考：

http://123.207.238.149:8889/mg.html

Java代码：

 

#### 麻将游戏

总共有36张牌，每张牌是1~9。每个数字4张牌。
你手里有其中的14张牌，如果这14张牌满足如下条件，即算作和牌
14张牌中有2张相同数字的牌，称为雀头。
除去上述2张牌，剩下12张牌可以组成4个顺子或刻子。顺子的意思是递增的连续3个数字牌（例如234,567等），刻子的意思是相同数字的3个数字牌（例如111,777）

```

例如：
1 1 1 2 2 2 6 6 6 7 7 7 9 9 可以组成1,2,6,7的4个刻子和9的雀头，可以和牌
1 1 1 1 2 2 3 3 5 6 7 7 8 9 用1做雀头，组123,123,567,789的四个顺子，可以和牌
1 1 1 2 2 2 3 3 3 5 6 7 7 9 无论用1 2 3 7哪个做雀头，都无法组成和牌的条件。
```



解题思路

本题考查的是回溯法，由于数据的规模非常小(n<=9)，所以递归不会很深。 

  思路： 已有13张牌，我们从剩余的牌中依次从1到9选择一张牌作为第14张牌，然后判断是否已经构成胡牌。 

  判断胡牌思路：从1到9中选择一个数字作为雀头，然后判断剩余的数字是否包含4个三张牌

```java
public class Main {
 
 
    private static int[] arr = new int[13];
    private static int[] count;
 
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
 
 
        count = new int[9];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = scanner.nextInt();
            ++count[arr[i]-1];
        }
 
 
        int winCount = 0;
        // 选择1到9中的一个作为第14张牌，然后判断是否胡牌
        for (int i = 1 ; i <= 9; i++) {
            if(count[i-1]<4){
                回溯入口
                ++count[i-1];
                if(win()){
                    ++winCount;
                    System.out.print(i);
                    System.out.print(" ");
                }
                回溯出口
                --count[i-1];
            }
        }
        if(winCount==0){
            System.out.println(0);
        }
    }
    public static boolean win(){
        // 从1到9 中选择一个作为雀头, 然后判断剩余的牌是否构成4对
        for (int i = 1; i <= 9; i++) {
            if(count[i-1]<2){
                continue;
            }
            count[i-1]-=2;
            if(hasTriples(4)){
                count[i-1]+=2;
                return true;
            }
            count[i-1]+=2;
        }
        return false;
    }
 
    public static boolean hasTriples(int n){
        if(n==0){
            return true;
        }
        // 1到9，每一张牌尝试三张或顺子
        for (int i = 1; i <= 9; i++) {
            if(count[i-1]>=3){
                count[i-1]-=3;
                boolean subHashTriples = hasTriples(n-1);
                count[i-1]+=3;
                if(subHashTriples){
                    return true;
                }
            }
            if(i<=7  && count[i-1]>0 && count[i] > 0 && count[i+1]>0){
                --count[i-1];
                --count[i];
                --count[i+1];
                boolean subHasTriples = hasTriples(n-1);
 
                ++count[i-1];
                ++count[i];
                ++count[i+1];
                if(subHasTriples){
                    return true;
                }
            }
        }
        return false;
    }
}
```





#### N皇后

*n* 皇后问题研究的是如何将 *n* 个皇后放置在 *n*×*n* 的棋盘上，并且使皇后彼此之间不能相互攻击。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/8-queens.png)

给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。

每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

![image-20200528064316202](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200528064316202.png)



解题思路



解题实现

```
class Solution {
    private List<List<String>> output = new ArrayList<>();

    // 用于标记是否被列方向的皇后被攻击
    int[] rows;
    // 用于标记是否被主对角线方向的皇后攻击
    int[] mains;
    // 用于标记是否被次对角线方向的皇后攻击
    int[] secondary;
    // 用于存储皇后放置的位置
    int[] queens;

    int n;

    public List<List<String>> solveNQueens(int n) {
        // 初始化
        rows = new int[n];
        mains = new int[2 * n - 1];
        secondary = new int[2 * n - 1];
        queens = new int[n];
        this.n = n;

        // 从第一行开始回溯求解 N 皇后
        backtrack(0);

        return output;    
    }

    // 在一行中放置一个皇后
    private void backtrack(int row) {
        if (row >= n) return;
        // 分别尝试在 row 行中的每一列中放置皇后
        for (int col = 0; col < n; col++) {
            // 判断当前放置的皇后不被其他皇后的攻击
            if (isNotUnderAttack(row, col)) {
                // 选择，在当前的位置上放置皇后
                placeQueen(row, col);
                // 当当前行是最后一行，则找到了一个解决方案
                if (row == n - 1) addSolution();
                // 在下一行中放置皇后
                backtrack(row + 1);
                // 撤销，回溯，即将当前位置的皇后去掉
                removeQueen(row, col);
            }
        }
    }

    // 判断 row 行，col 列这个位置有没有被其他方向的皇后攻击
    private boolean isNotUnderAttack(int row, int col) {
        // 判断的逻辑是：
        //      1. 当前位置的这一列方向没有皇后攻击
        //      2. 当前位置的主对角线方向没有皇后攻击
        //      3. 当前位置的次对角线方向没有皇后攻击
        int res = rows[col] + mains[row - col + n - 1] + secondary[row + col];
        // 如果三个方向都没有攻击的话，则 res = 0，即当前位置不被任何的皇后攻击
        return res == 0;
    }

    // 在指定的位置上放置皇后
    private void placeQueen(int row, int col) {
        // 在 row 行，col 列 放置皇后
        queens[row] = col;
        // 当前位置的列方向已经有皇后了
        rows[col] = 1;
        // 当前位置的主对角线方向已经有皇后了
        mains[row - col + n - 1] = 1;
        // 当前位置的次对角线方向已经有皇后了
        secondary[row + col] = 1;
    }

    // 移除指定位置上的皇后
    private void removeQueen(int row, int col) {
        // 移除 row 行上的皇后
        queens[row] = 0;
        // 当前位置的列方向没有皇后了
        rows[col] = 0;
        // 当前位置的主对角线方向没有皇后了
        mains[row - col + n - 1] = 0;
        // 当前位置的次对角线方向没有皇后了
        secondary[row + col] = 0;
    }

    /**
     * 将满足条件的皇后位置放入output中
     */
    public void addSolution() {
        List<String> solution = new ArrayList<String>();
        for (int i = 0; i < n; ++i) {
            int col = queens[i];
            StringBuilder sb = new StringBuilder();
            for(int j = 0; j < col; ++j) sb.append(".");
            sb.append("Q");
            for(int j = 0; j < n - col - 1; ++j) sb.append(".");
            solution.add(sb.toString());
        }
        output.add(solution);
    }
}
```











