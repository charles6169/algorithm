## 查找





### 笔试题

1）折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。

2）使查找成功时的平均查找长度达到最小

​	所以将经常需要查找（查找概率大）的数据放在顺序表中较前的位置

类似于哈夫曼编码的思想，让概率大的查找次数少就可以保证总的查找次数最小，所以对序列依照查找概率排序，概率最大的找的次数最小



### 概述

难点：**思路很简单，细节是魔鬼**

不同数据结构的操作比较

![img](https://uploadfiles.nowcoder.com/images/20160817/872256_1471417718241_235CD8164042032013BAC62C1EEB9C0C)

#### 顺序查找

​	    基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。

#### 二分查找

1.基本思想

- 有序的序列，每次都是以序列的中间位置的数来与待查找的关键字进行比较，每次缩小一半的查找范围，直到匹配成功。
- 注意如果是无需数组，则首先要排序成有序数组，二分查找只能对有序序列。

2.排序过程

- ① 首先确定整个查找区间的中间位置 mid = （ left + right ）/ 2
- ② 用待查关键字值与中间位置的关键字值进行比较；
  - 若相等，则查找成功
  - 若大于，则在后（右）半个区域继续进行折半查找
  - 若小于，则在前（左）半个区域继续进行折半查找
- ③ 对确定的缩小区域再按折半公式，重复上述步骤。
  - 最后，得到结果：要么查找成功， 要么查找失败。



4.如何优化

- 优点：每经过一次比较,查找范围就缩小一半。经log2n次计较就可以完成查找过程。
- 缺点：因要求有序，所以要求查找数列必须有序，而对所有数据元素按大小排序是非常费时的操作。另外，顺序存储结构的插入、删除操作不便利。

5.复杂度

- 时间复杂度
  - 采用的是分治策略
  - 最坏的情况下两种方式时间复杂度一样：O(log2 N)
  - 最好情况下为O（1）
- 空间复杂度
  - 算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数
  - 非递归方式：
    - 由于辅助空间是常数级别的所以：
    - 空间复杂度是O(1);
  - 递归方式：
    - 递归的次数和深度都是log2 N,每次所需要的辅助空间都是常数级别的：
    - 空间复杂度：O(log2N )

6.使用场景



**注意**

1）二分查找如果是偶数数组，中间值为左边一位。

2）折半查找最坏的情况下查找log(n)+1次，而二叉查找树最坏的情况是查找n次。

3）折半查找中关键字比较序列必须满足：前一个元素要么大于后面每一个元素要么小于后面每一个元素

4）二分查找首先要求数据是有序的,同时要求能随机访问数据元素, 有序数组可以, 链表不行

5）二分查找因为每次都是从中间点开始查找，所以最坏情况是目标元素存在于最边缘的情况。最坏为O（LogN）

6）二分查找的数据类型不可以是字符型





#### 插值查找

![image-20200220145247833](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200220145247833.png)

基本版本

```java
public class InsertValueSearch {
    public static void main(String[] args) {
        int arr[] = {1, 8, 10, 89, 1000, 1000, 1234};
        int index = insertValueSearch(arr, 0, arr.length - 1, 89);
        System.out.println("index = " + index);
    }
 
    /**
     * @param arr     数组
     * @param left    左边索引
     * @param right   右边索引
     * @param findVal 查找值
     * @return 如果找到，就返回对应的下标，如果没有找到，返回-1
     */
    public static int insertValueSearch(int[] arr, int left, int right, int findVal) {
        
        //注意:findVal < arr[0] 和 findVal > arr[arr.length - 1] 必须需要
        // 否则我们得到的 mid 可能越界
        if (left > right || findVal < arr[0] || findVal > arr[arr.length - 1]) {
            return -1;
        }
 
        // 求出 mid, 自适应
        int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);
        int midVal = arr[mid];
 
        if (findVal > midVal) { // 说明应该向右边递归
            return insertValueSearch(arr, mid + 1, right, findVal);
        } else if (findVal < midVal) { // 说明向左递归查找
            return insertValueSearch(arr, left, mid - 1, findVal);
        } else {
            return mid;
        }
    }
}
```



#### 斐波那契查找

![image-20200220152918691](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200220152918691.png)





数表查找

分块查找

哈希查找





### 算法研究

#### 三个境界

![image-20200513133048423](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200513133048423.png)

技巧：看到题目给出了排序数组，一般就要想到二分法，同时二分法经常和双指针联用





#### 常见痛点

![image-20200513144230462](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200513144230462.png)

1）死循环

2）递归的终止条件如何写

3）指针如何移动以解决问题



#### 二分模板

**基于循环**

**模板一**

默认返回第一个找到的元素

实现思路

2）初始化头指针和尾指针

3）循环，当start+1小于end时

​		4）计算mid为头指针和尾指针的中间值

​		5）判断，mid位置值和目标值的三种情况，等于，大于，小于

​		6）等于和大于都移动end，小于则移动start

```
int mid=(end-start)/2+start;
if(arr[mid]==tar){
	end=mid;
}else if(arr[mid]>tar){
	end=mid;
}else{
	start=mid;
}
```

7）最终判定，目标值是在start还是end上

8）都不在则返回-1



```java
// 二分查找
public static int binSearch(int arr[], int tar) {
    int left=0;int right=arr.length-1;
    while(left+1<end){
        int mid=(right-left)/2+start;
        if(arr[mid]==tar){
            // 相关逻辑
        }else if(arr[mid]<tar){
            left=mid;
        }else{
            right=mid;
        }
    }
    if(arr[left]==tar){
        return left;
    }
    if(arr[right]==tar){
        return right;
    }
    return -1;
}
```





**模板二**

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1; // 注意
        while(left <= right) { // 注意取等
            int mid = (left + right) / 2; // 注意
            if(nums[mid] == target) { // 注意
                // 相关逻辑
            } else if(nums[mid] < target) {
                left = mid + 1; // 注意 单加1减1
            } else {
                right = mid - 1; // 注意
            }
        }
        // 相关返回值
        return 0;
    }
}
```



**模板三**

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length; // 注意
        while(left < right) { // 注意不相等
            int mid = (left + right) / 2; // 注意
            if(nums[mid] == target) {
                // 相关逻辑
            } else if(nums[mid] < target) {
                left = mid + 1; // 注意
            } else {
                right = mid; // 注意 右边不减1
            }
        }
        // 相关返回值
        return 0;
    }
}

```

口诀：取等都加减，不等右不动





#### 三种问法

![image-20200513135038572](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200513135038572.png)

查找数组中目标元素的任意一个、第一个或者最后一个



**四处灵活变动**

**循环结束条件中 left 和 right 的关系，更新 left 和 right 位置时要不要加 1 减 1**。

1）终止条件

```
while(start+1<end)

	• start <= end
    • start < end
    • start + 1 < end
```





2）中间值赋值

```
mid=(end-start)/2+start
```

3）中间值与目标值的三种关系，及其赋值

```
arr[mid] target  < > == 
```

   左边界附近都是>
   右边界附近都>=



4）指针变换

```
 	• start = mid
    • start = mid + 1
    • start = mid - 1
```



5）返回值是首值还是尾值，返回left，还是返回right

```

arr[start]    arr[end]
```

 因为我们知道最后跳出while (left + 1< right)循环条件是left+ 1 == right。
     最后left 和right一定是卡在"边界值"的左右两边
     以数组{1, 2, 3, 3, 4,5}为例，
     如果需要查找第一个等于或者小于3的元素下标，我们比较的key值是3，则最后left和right需要满足以下条件：
     left——>2, right ——>3
     我们比较的key值是3，所以此时我们需要返回right 。

所以，最后只需要判断left或right是否等于target即可。







弄不好就死循环，弄不好边界就失误**





模板比较

```java
   while(left+1<right){
        int mid=(right-left)/2+left;
        if(arr[mid]==tar){
            // 相关逻辑
        }else if(arr[mid]<tar){
            left=mid;
        }else{
            right=mid;
        }
    }
```



```java
	while(left < right) { // 注意
            int mid = (left + right) / 2; // 注意
            if(nums[mid] == target) {
                // 相关逻辑
            } else if(nums[mid] < target) {
                left = mid + 1; // 注意只是left需要多移一位
            } else {
                right = mid; // 注意
            }
        }
```

方法一和方法二的 left+1<right 和 left < right 两种终止条件其实是一个意思，两边边界不会取到等，当left与right的最近距离是相邻一位。

实验比较发现，方法二相比方法一而言，left更快的趋向right（时间复杂度更低）

对于方法一，把left+1放到了终止比较中，而方法二放到了移位操作上。

```java
	while(left <= right) { // 注意
            int mid = (left + right) / 2; // 注意
            if(nums[mid] == target) { // 注意
                // 相关逻辑
            } else if(nums[mid] < target) {
                left = mid + 1; // 注意
            } else {
                right = mid - 1; // 注意
            }
        }
```

第三种方法两边的边界会取到等，因此这种模板，在两边取等时还会再执行一次，执行完了之后，其left(左值)就是假如原数组中没有这个元素，而需要插入这个数时的位置。（考点）



#### 两个边界

以 4，3，1，0，0，0，-2，-4的 0 边界为例

**寻找左边界**

```java
	while (left < right) {
            int mid = (right - left) / 2 + left;
            if (nums[mid] <= target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return right;
```

此时找到第2位，即 1

**寻找右边界**

```java
	while (left < right) {
            int mid = (right - left) / 2 + left;
            if (nums[mid] >= target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
```

此时找到第6位，即 -2

​		两种边界的根本思想是当找到指定元素时的操作移动左指针还是右指针，移动右指针则是找左边界，移动左指针则是找右边界

​		**移左找右，移右找左**。





### lower_bound&upper_bound

```
upper_bound来说，返回的是被查序列中第一个 大于 查找值的指针，也就是返回指向被查值>查找值的最小指针，lower_bound则是返回的是被查序列中第一个 大于等于 查找值的指针，也就是返回指向被查值>=查找值的最小指针。 
```











### 算法案例



#### 剑指 Offer-在排序数组中查找数字 I

统计一个数字在排序数组中出现的次数。

![image-20200514153747773](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200514153747773.png)

解题思路

![image-20200514153823998](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200514153823998.png)

target-1存在或不存在都不会影响题目的解答

解题实现

1）调用二分查找函数（封装），注意输入分别为target和target-1，两者相减即可

​		2）二分查找模板程序

​		3）终止条件带等号

​		4）小于等于，移动left，大于，移动right (核心)

​		5）返回值为左值。



```java
class Solution {
    public int search(int[] nums, int target) {
        return binSearch(nums,target)-binSearch(nums,target-1);
        //找到的是某一个数的右边界
    }

    public static int binSearch(int[] nums,int target){
        int left=0;
        int right=nums.length-1;
        while(left<=right){
            int mid=(right-left)/2+left;
            //难点在于二分法的具体实现上
            if(nums[mid]<=target){
                left=mid+1;
            }else{
                right=mid-1;
            }
        }
        //返回左值
        return left;
    }
}
```









解题思路

本题不能用HashMap 和暴力解，其时间空间复杂度均为O(N），应该使用双指针+二分法，空间复杂度仅为O(1）



![image-20200716221749018](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200716221749018.png)

![image-20200716221809167](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200716221809167.png)



复杂度

![image-20200716221822134](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200716221822134.png)



解题实现

1）新建左右指针

2）以二分法相向遍历

3）如果找到直接返回

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int i = 0, j = nums.length - 1;
        while(i < j) {
            int s = nums[i] + nums[j];
            if(s < target) i++;
            else if(s > target) j--;
            else return new int[] { nums[i], nums[j] };
        }
        return new int[0];
    }
}
```















#### 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

![image-20200514133330330](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200514133330330.png)



解题实现

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left=0;
        int right=nums.length-1;
        while(left<=right){
            int mid=(right-left)/2+left;
            if(nums[mid]==target){
                return mid;
            }else if(nums[mid]>target){
                right=mid-1;
            }else{
                left=mid+1;
            }
        }
        return left;
    }
}
```

标准模板未搜索到指定元素时，会返回它将会被按顺序插入的位置





#### 两个数组的交集

给定两个数组，编写一个函数来计算它们的交集。

![image-20200514144321949](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200514144321949.png)

解题答案

```java
class Solution {
    
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set = new HashSet<>();
        List<Integer> res = new ArrayList<>();
        Arrays.sort(nums2);
        for (int num : nums1) {
            if (binSearch(nums2, num) && !set.contains(num)) {
                set.add(num);
            }
        }
        Iterator var = set.iterator();
        while (var.hasNext()) {
            res.add((Integer) var.next());
        }
        return res.stream().mapToInt(Integer::valueOf).toArray();
    }

    public static boolean binSearch(int[] nums,int target){
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = (right - left) / 2 + left;
            if (nums[mid] == target) {
                return true;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return false;
    }

}
```



#### 搜索二维矩阵

编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

每行中的整数从左到右按升序排列。
每行的第一个整数大于前一行的最后一个整数。

```
输入:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
输出: true

输入:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 13
输出: false

```



解题思路

从右上角开始，大于target将列数减一，小于target将行数加一。

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix==null||matrix.length==0||matrix[0].length==0){
            return false;
        }

        int m = matrix.length;
        int n = matrix[0].length;
        int r = 0;
        int c = n;
        while (r < m && c > 0) {
            int temp = matrix[r][c-1];
            if (temp == target) {
                return true;
            } else if (temp > target) {
                c--;
            } else {
                r++;
            }
        }
        return false;
    }
}
```





#### 招商银行信用卡中心2019秋招IT笔试-爱吃喵粮的小招喵

小招喵喜欢吃喵粮。这里有 N 堆喵粮，第 i 堆中有 p[i] 粒喵粮。喵主人离开了，将在 H 小时后回来。

小招喵可以决定她吃喵粮的速度 K （单位：粒/小时）。每个小时，她将会选择一堆喵粮，从中吃掉 K 粒。如果这堆喵粮少于 K 粒，她将吃掉这堆的所有喵粮，然后这一小时内不会再吃更多的喵粮。 

小招喵喜欢慢慢吃，但仍然想在喵主人回来前吃掉所有的喵粮。

返回她可以在 H 小时内吃掉所有喵粮的最小速度 K（K 为整数）。

```
in
第一行输入为喵粮数组，以空格分隔的N个整数

第二行输入为H小时数
3 6 7 11
8

out
最小速度K
4
```



解题思路

![image-20200708215118209](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200708215118209.png)



解题实现

```java
	public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String[] str = sc.nextLine().split(" ");
        int h = Integer.parseInt(sc.nextLine());
        int[] data = new int[str.length];
        int maxSpeed = Integer.MIN_VALUE;  //最大速度，初始为最大数组元素
        for (int i = 0; i < str.length; i++) {
            data[i] = Integer.parseInt(str[i]);
            maxSpeed = Math.max(maxSpeed, data[i]);
        }
        int mid = 0;
        int minSpeed = 1;  ////最小速度，初始为1
        while (minSpeed <= maxSpeed) {
            //二分查找
            mid = minSpeed + ((maxSpeed - minSpeed) >> 1);
            //以当前速度吃完猫粮作为二分的逻辑判断,主人返回时间为分界点
            if (getTime(data, mid) <= h) {
                maxSpeed = mid - 1;
            } else {
                minSpeed = mid + 1;
            }
        }
        System.out.println(minSpeed);
    }

    public static int getTime(int[] data, int k) {
        int sum = 0;
        for (int i = 0; i < data.length; i++) {
            //判断是否整除，决定直接加上或者多加1小时
            sum += data[i] % k == 0 ? data[i] / k : data[i] / k + 1;
        }
        return sum;
    }
```





















