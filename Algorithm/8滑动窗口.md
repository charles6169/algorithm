# 滑动窗口

## 概述

滑动窗口法，也叫尺取法（可能也不一定相等，大概就是这样 =。=），可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。往往类似于“请找到满足xx的最x的区间（子串、子数组）的xx”这类问题都可以使用该方法进行解决。



## 算法模板

​		滑动窗口的难点在于细节，如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果







### 通用模板

#### 模板1

1.准备工作

长度，判空，频次数组，核心参数初始化

2.第一层循环
从右边界切入分析，关键点把握频次数组和编辑距离

```
while (第一循环条件){  第一循环条件一般是指右指针不能超过右边界
	char charRight=S[right];
	
	
	
	winFreq[charRight]++;
	right++;
}
```

3.第二层循环
更新最小字串位置，从左边界切入分析，关键点把握频次数组和编辑距离

```
while(第一循环条件){
	char charLeft=S[left];
	winFreq[charLeft]--;
	left++;

}
```

4.目标找到策略





5.返回



#### winFreq和tFreq的思考

```
tFreq为静态，反映的是目标串的字符频次，为固定数组
winFreq为动态，当右边界往右扩张时增加，当左边界往左缩小时减小，为动态数组
```

几乎一切的判断都是基于这两个频次数组进行



#### 两个while的思考

```
第一个while执行的是右边界右移
第二个while执行的是左边界左移
难点在于如何找到两个循环的条件
```



#### 目标达到策略

```
一般与长度有关
```





## 解题案例





#### 剑指 Offer- 和为s的连续正数序列

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

```
输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
```



解题思路

本题有三种解决方案：滑动窗口法 -> 求根法 -> 间隔法

![image-20200720211334283](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200720211334283.png)

![image-20200720211402288](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200720211402288.png)



![image-20200720211447850](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200720211447850.png)

![image-20200720211505686](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200720211505686.png)

![image-20200720211519380](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200720211519380.png)







解题实现

1）新建左右指针，累积和，两层返回值列表

2）while循环，当i小于等于 target/2时循环

3）如果总和小于target，移动右边界，总和大于target，移动左边界，如果取等，保存数组 并 左边界右移一位

4）列表数组转换，返回

```java
public int[][] findContinuousSequence(int target) {
    int i = 1; // 滑动窗口的左边界
    int j = 1; // 滑动窗口的右边界  新建的指针都指向 1
    int sum = 0; // 滑动窗口中数字的和
    List<int[]> res = new ArrayList<>(); // 注意返回值列表形式

    while (i <= target / 2) {
        if (sum < target) {
            // 右边界向右移动
            sum += j;
            j++;
        } else if (sum > target) {
            // 左边界向右移动
            sum -= i;
            i++;
        } else {
            // 记录结果
            int[] arr = new int[j-i];
            for (int k = i; k < j; k++) {
                arr[k-i] = k;
            }
            res.add(arr);
            // 左边界向右移动
            sum -= i;
            i++;
        }
    }

    return res.toArray(new int[res.size()][]);
}
```



















#### 最小覆盖子串

给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。

```
输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"
```







解题实现

1，准备工作

1）获取数组长度，空值判定，字符串数组化

2）新建窗口和 t 串的频次数组，数组大小初始化为128长度，初始化 t 串的频次数组

3）初始化几个重要参数：编辑距离，最小长度，最小串起始坐标，左右指针

```java
int sLen=s.length();
int tLen=t.length();
if(sLen==0||tLen==0||sLen<tLen){
	return "";
}
int[] S=s.toCharArray();
int[] T=t.toCharArray();
int[] winFreq=new int[128];
int[] tFreq=new int[128];
for(char c:T){
	tFreq[c]++;
}
int distace=0;
int minLen=sLen+1;
int begin=0;
int left=0;
int right=0;

```



2，第一层while循环，当right小于left

1）获取右边界字符

2）若tFreq中无此字符，直接右移指针，continue

3）如果winFreq中频次小于tFreq的频次，distance++

4）winFreq的此字符频次增1，并且右指针右移

```java
while(right<sLen){
	char charRight=S[right];
    if(tFreq[charRight]==0){
        right++;
        continue;
    }
    if(winFreq[charRight]<tFreq[charRight]){
        distance++;
    }
    winFreq[charRight]++;
    right++;
}
```



3，第二层while循环，当distance等于tLen

1）如果区间长度小于minLen，替换minLen，并且修改begin

2）取出左边界字符

3）若tFreq该字符频次为0，左边界直接左移，continue（与上对称）

4）如果winFreq中频次等于tFreq的频次，distance--

5）winFreq的此字符频次减1，并且左指针左移

```java
while(distance==tLen){
	if(right-left<minLen){
		minLen=right-left;
		begin=left;
	}
	char charLeft=S[left];
	if(tFreq[charLeft]==0){
		left++;
		continue;
	}
	if(winFreq[charLeft]==tFreq[charLeft]){
		distance--;
	}
	winFreq[charLeft]--;
	left++;
}
```



4，最终判断与返回

1）如果minLen的长度还是等于sLen-1，说明没有找到，直接返回空

2）否则返回找到的字串

```java
if(minLen==sLen-1){
	return "";
}
return s.substring(begin,begin+minLen);
```









#### 找到字符串中所有字母异位词

给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。

字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。

说明：

字母异位词指字母相同，但排列不同的字符串。
不考虑答案输出的顺序。

```
输入:
s: "cbaebabacd" p: "abc"

输出:
[0, 6]

解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。

```



解题思路

![image-20200618222200422](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200618222200422.png)



解题实现

1）获取数组长度，空值判定，初始化频次数组，初始化左右指针

2）第一层循环 当right < sLen

​	3）右指针右移，改变winFreq，无需做判断

​	4）第二层循环 当 winFreq[charRight] > pFreq[charRight] 特别注意是大于，不是等于

​			5）左指针左移，改变winFreq，无需做判断

​	6）当区间长度等于pLen时，找到目标

```
while(right<sLen){
	char charRight=S[right];
	winFreq[charRight]++;
	right++;
	while(winFreq[charRight]>tFreq[charRight]){
		char charLeft=S[left];
		winFreq[charLeft]--;
		left++;
	}
	if(right-left==tLen){
		res.add(left);
	}
}
```

7）返回







#### 抓捕问题

字节跳动2019春招

\1. 我们在字节跳动大街的N个建筑中选定3个埋伏地点。

\2. 为了相互照应，我们决定相距最远的两名特工间的距离不超过D。

```
输入
5 19
1 10 20 30 50
输出
1
```



解题思路

原问题等价于，有序的正整数中去三个，最大最小差值小于等于D 

 假设三个张最大的为max，依次遍历max值取a[i](i>=2)的可能性与可能情况数目。 

  在遍历的过程中，在a[i]的左半径D范围内的所有整数取两个(组合问题），因此关键在于求出左边界。



解题实现

```java
    public static long solve(int D, int[] dist) {
        long mod = 99997867;
        long ans = 0;
        for (int i = 0, j = 0; i < dist.length; i++) {
            while (i >= 2 && (dist[i] - dist[j]) > D) {
                j++;
            }
            ans += cal(i - j);
        }
        return ans % mod;

    }

    public static long cal(int n) {
        return n * (n - 1) / 2;
    }
```

