## 递归

### 概述

#### 定义

​		　 在数学与计算机科学中，递归(Recursion)是指在函数的定义中使用函数自身的方法。实际上，递归，顾名思义，其包含了两个意思：递 和 归，这正是递归思想的精华所在。

#### 递归思想的内涵

​		递归就是有去（递去）有回（归来），如下图所示。

​		“有去”是指：递归问题必须可以分解为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决，

​		“有回”是指 : 这些问题的演化过程是一个从大到小，由近及远的过程，并且会有一个明确的终点(临界点)，一旦到达了这个临界点，就不用再往更小、更远的地方走下去。最后，从这个临界点开始，原路返回到原点，原问题解决。

<img src="https://img-blog.csdn.net/20170531153126570?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" style="zoom:67%;" />





### 算法挖掘

#### 算法思想

![image-20200525045344217](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200525045344217.png)

​		自顶向下算法思想，难点在于不断调用自身，产生多个返回值，理不清其返回值的具体顺序，以及最终的返回值到底是哪一个





**基线条件与递归条件**

​		编写递归函数时，必须告诉它何时停止递归。正因为如此，每个递归函数都有两部分：**基线条件（base case）和递归条件（recursive case）**。递归条件指的是函数调用自己，而基线条件则 指的是函数不再调用自己，从而避免形成无限循环。 

 涉及 *多少种可能性* 的题目一般都有 **递推性质** 

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200508124237138.png" alt="image-20200508124237138" style="zoom:67%;" />

单个递归情况下，只能有一个递归函数处于激活状态。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200508124406298.png" alt="image-20200508124406298" style="zoom:80%;" />

  

举例用递归来算阶乘 f(n)的具体过程

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200219212015245.png" alt="image-20200219212015245" style="zoom:67%;" />

递归过的单元会存入栈中，先进后出，释放的顺序与存入的顺序相反

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200508124906194.png" alt="image-20200508124906194" style="zoom:80%;" />



**递归的分类**

​		直接递归和间接递归。

直接递归：

```java
main(){
	a();
}
a(){
	a();
}
```

间接递归

```java
b(){
	c();
}
c(){
	b();
}
```

​		递归的使用前提：当使用方法的时候，方法的主体不变，每次调用方法的参数不同，则可以使用递归。





#### 算法模板

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200226161912491.png" alt="image-20200226161912491"  />

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200226161943128.png" alt="image-20200226161943128" style="zoom:80%;" />

![image-20200226162021400](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200226162021400.png)



#### 算法模板





输入：递归的传入参数

终止条件：边界情况，对树而言一般是树节点为空

递归入口：调用递归函数，进入下一层

递归出口：承接下一层返回的结果，关注递归的返回值

输出：递归的返回值

注意：

1）建议一次性进入到最底层，分析终止条件，再依层返回到顶层

2）递归体的变量在每一层均不一致，需要厘清

3）递归体的输入和输出在每一层均有着相同的格式，但是具体值的含义不同



##### 递归逻辑表

![image-20200526050802164](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200526050802164.png)





##### 通用模板1

```
自顶向下思考一个递归问题

终止条件：
	分两种，非法判断和结束情况

递归工作：完成单次递归的功能，使问题缩小

返回值：整合返回结果
```



![image-20200525050057139](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200525050057139.png)

**终止条件**

​		就是会在函数内部代码中，调用这个函数本身，所以，我们必须要找出递归合理的结束条件，**不然的话，会一直调用自己，进入无底洞**。也就是说，我们需要找出当参数为啥时，递归结束，之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。





**递归工作**

​		对于递归，我觉得很重要的一个事就是，这个函数的功能是什么，他要完成什么样的一件事，而这个，是完全由你自己来定义的。也就是说，我们先不管函数里面的代码什么，而是要先明白，你这个函数是要用来干什么。

 **返回值**

​		找出函数的等价关系式就是，我们要不断缩小参数的范围，缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。

​		有时递归的返回值就是等价关系

总结：终止条件-单级功能-等价关系

口诀：终止  递归  返回值



**递归的两种返回方式**

1）返回一个具体的值

2）返回控制权给主线程（递归已执行相关功能）



**理解注意**

1）实际做题时还需要判断一下是否需要把递归函数作为辅助函数

2）所有的循环都可以转递归，而递归不一定可以转循环

3）无论递归的深度有多深，最终的出口还是最初发出递归的那个位置





#### 树形图法

针对二叉树的递归问题

​		对相对不太复杂的递归问题绘制树形图，手动执行递归代码，树形图的叶节点即为递归的终止条件，树形图的根节点即为最终的返回值。树形图的所有节点个数即为递归程序得到最终返回值的总体运行次数，可以借此计算时间复杂度

<img src="https://img2018.cnblogs.com/blog/927750/201910/927750-20191027194605476-1977102465.png" alt="img" style="zoom: 50%;" />





#### 按步剖析法

针对数组，字符串，链表等递归问题

 		以简单的例子分析剖析，明确每次递归的区间， 以及每个区间内对应变量的值

​		明确递归体的输入，输出，递归口，以及递归工作









#### 记忆化递归

​		记忆化操作就是把之前递归求解得到的返回值保存到一个全局变量中，后面遇到对应的参数值，先判断当前全局变量中是否包含其解，如果包含则直接返回具体解，否则进行递归求解。

​		一般可以用一个映射保存临时结果，下次再次计算时，先判断映射中是否已经有了

直接举例  斐波拉契数列

原代码

```java
public class Fibonacci {
    public static int fibonacci1(int n) {
//        终止
        if (n < 2) {
            return 1;
        }
//        单级＋等价
        return fibonacci1(n - 1) + fibonacci1(n - 2);
    }
}
```

记忆化递归 改进后

```java
class Solution {
    private Map<Integer, Integer> map = new HashMap<>();
    public int fib(int N) {
        if(N <= 1)
            return N;
        if(map.containsKey(N))
            return map.get(N);      

        int result = fib(N - 1) + fib(N - 2);
        map.put(N, result);
       
        return result;
    }
}
```





#### 尾递归

​		尾递归是指在返回时，直接返回递归函数调用的值，不做额外的运算。比如，第一节中斐波那契数列的递归是返回: return fib(N-1) + fib(N-2);。返回时，需要做加法运算，这样的递归调用就不属于尾递归。

尾递归的好处是，它可以避免递归调用期间栈空间开销的累积，因为系统可以为每个递归调用重用栈中的固定空间。

在尾递归的情况下，一旦从递归调用返回，我们也会立即返回，因此我们可以跳过整个递归调用返回链，直接返回到原始调用方。这意味着我们根本不需要所有递归调用的调用栈，这为我们节省了空间。

尾递归的优势可以通俗的理解为：降低算法的空间复杂度，由原来应用栈存储中间状态，变换为不断直接返回最终值。



#### 递归剪枝

​		剪枝操作是指在递归调用过程中，通过添加相关判断条件，减少不必要的递归操作，从而提高算法的运行速度。一般来说，良好的剪枝操作能够降低算法的时间复杂度，提高程序的健壮性。



#### 时间复杂度分析

​		递归的时间复杂度为每次执行都会缩少一个倍数，一般是缩小1倍，因此时间复杂度往往除以2



**迭代法**

```
首先分析得到T(n)关系式，然后不断将n-1,n-2,n-3代入关系式
然后对算完后的  T(n) 求 O(n)
```

![image-20200525052113863](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200525052113863.png)

迭代法的局限性非常大，适用于较为简单的算法

**公式法**

![image-20200525052424897](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200525052424897.png)

三种情况

![image-20200525052449921](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200525052449921.png)

第二种情况表示最复杂的情况发生在递归完成之后的操作。







### 运用案例

#### 斐波拉契数列

递归法

```java
public class Fibonacci {
    public static int fibonacci1(int n) {
//        终止
        if (n < 2) {
            return 1;
        }
//        单级＋等价
        return fibonacci1(n - 1) + fibonacci1(n - 2);
    }
}
```



#### 青蛙跳台阶

```java
public static int frogJumpStep1(int n) {
        if (n <= 2) {
            return n;
        }
        return frogJumpStep1(n - 1) + frogJumpStep1(n - 2);
 }

```



#### 汉诺塔问题

在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。

请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200525053831245.png" alt="image-20200525053831245" style="zoom:80%;" />

解题思路

![image-20200525053903256](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200525053903256.png)

解题实现

1）调用递归函数，初始盘子量为n，递归参数 列表 A B C 分别代表当前递归盘子所在柱，辅助柱和目标柱

​	2）如果n等于1，直接把A的盘子放到C

​	3）递归，盘子数-1，A借C移到B

​	4）把A的盘子放到C

​	5）递归，盘子数-1，B借A移到C

```
recur(n-1,A,C,B);
moveTo(A,C);
recur(n-1,B,A,C);
```



移动函数

将一个链表的最后一位移到另一个链表

```
l1.add(l2.remove(l2.size()-1));
```



#### 各位相加

反复将各个位上的数字相加，直到结果为一位数

![image-20200508141956013](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200508141956013.png)

解题实现

1）终止条件：当数字小于10时，直接返回数

2）初始化返回值为 0

3）单级任务：当数不为0时，循环

​		4）返回值加上数字对10取模，数字除10

```
while(num!=0){
	res+=num%10;
	num/=10;
}
```

5）递归关系：对返回值递归

```
recur(res);
```









#### 第K个语法符号

在第一行我们写上一个 `0`。接下来的每一行，将前一行中的`0`替换为`01`，`1`替换为`10`。

给定行数 `N` 和序数 `K`，返回第 `N` 行中第 `K`个字符。（`K`从1开始）

![image-20200508144736222](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200508144736222.png)

解题思路

![image-20200508150120903](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200508150120903.png)

解题实现

1）终止条件：当N等于1时，直接返回0

2）取出上一行对应位置的父节点，关系式为 [N-1，（K+1)/2]

```
int i=kthGrammar(N-1,(K+1)/2);
```

3）判断父节点是0还是1

​		4）为0时，转换后为01，判断K为偶输出1，奇输出0

​		5）为1时，转换后为10，判断K为偶输出0，奇输出1

```
if(i==0){
	return (K&1)==0?1:0;
}else{
	return (K&1)==0?0:1;
}
```





#### 有效的井字游戏

用字符串数组作为井字游戏的游戏板 board。当且仅当在井字游戏过程中，玩家有可能将字符放置成游戏板所显示的状态时，才返回 true。

该游戏板是一个 3 x 3 数组，由字符 " "，"X" 和 "O" 组成。字符 " " 代表一个空位。

以下是井字游戏的规则：

玩家轮流将字符放入空位（" "）中。
第一个玩家总是放字符 “X”，且第二个玩家总是放字符 “O”。
“X” 和 “O” 只允许放置在空位中，不允许对已放有字符的位置进行填充。
当有 3 个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。
当所有位置非空时，也算为游戏结束。
如果游戏结束，玩家不允许再放置字符。

![image-20200508151506458](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200508151506458.png)













经验：

对二叉树问题而言，大部分的递归终止条件都是节点值为null时终止。

二叉树的递归一般是先逐步递到叶子结点，再反过来归到根节点。

第一次执行单级功能是在主递归体执行完第一次后才执行的。

将递归的等价关系和返回值一起放到return语句中是一种常见的手法

在构思递归时，可以想着对左右节点干一样的事情，就知道如何写等价关系了

















### 参考资料

https://lyl0724.github.io/2020/01/25/1/