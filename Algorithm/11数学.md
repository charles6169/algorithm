# 数学

ACM-数论完全总结（知识点+模板）（待看）

https://blog.csdn.net/weixin_43093481/article/details/82229718



## 概述

### 素数(质数)

定义：一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。

### 孪生素数

孪生素数指的是间隔为 2 的相邻素数。



### 倍数、约数

数a能被数b整除，a就叫做b的倍数，b就叫做a的约数。约数和倍数都表示一个整数与另一个整数的关系，不能单独存在。





### 基数

也就是集合中不重复的元素最大集合，比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。





 基数估计就是在误差可接受的范围内，快速计算基数。



### 公因子

### （公约数）

公因数，亦称“[公约数](https://baike.baidu.com/item/公约数/1063409)”。它是一个能同时整除若干整数的整数 。如果一个整数同时是几个整数的[因数](https://baike.baidu.com/item/因数/9539111)，称这个整数为它们的“公因数”；公因数中最大的称为最大公因数。



### 因式分解

把一个[多项式](https://baike.baidu.com/item/多项式/10660961)在一个范围(如[实数](https://baike.baidu.com/item/实数/296419)范围内分解，即所有项均为实数)化为几个[整式](https://baike.baidu.com/item/整式/5961855)的积的形式，这种式子变形叫做这个多项式的**因式分解**，也叫作把这个多项式分解因式。

**分解公式**

![image-20200611220312156](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200611220312156.png)





### 最大公因式 

### （最大公约数）

### （最大公约数）

最大公因式有两个含义：第一，首先是公因式；第二，又是所有公因式的倍式，即体现“最大性”。

两个或多个[整数](https://baike.baidu.com/item/整数/1293937)公有的倍数叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。

理解：2个整数所有共同的最小约数的乘积。

举例：

```
150=5*5*3*2
105=7*5*3
有1个5，1个3相同。
所以150和105的最大公约数=5*3=15
```





举例

```
如：4和6
4的倍数：4.8.12.16.20……
6的倍数：6.12.18.24.30……
4和6的最小公倍数是12。
```









### 卡特兰数

卡特兰数是组合数学中一个常出现在各种计数问题中出现的数列。

```
公式为 :c(n)=c(2)*c(n-1)+c(3)*c(n-2)+...c(n-1)*c(2)。
```



卡特兰数的应用实质上都是递归等式的应用，前几项为：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862





## Java数学Api







### 除法运算理解







## 数学算法

更相减损术和辗转相除法用于求最大公约数

### 更相减损术

具体操作

- 任意给定两个正整数；判断它们是否都是偶数。若是，则用2约简；若不是则执行第二步。
- 以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。

实现

```
while(1)
    {
        if((a.nu[1]%2==0)&&(b.nu[1]%2==0)){a.div2();b.div2();num++;}
        else if((a.nu[1]%2==0)) a.div2();
        else if((b.nu[1]%2==0)) b.div2();
        if(a>b){a=a-b; if(a.z()){while(num--)b.mul2();b.out();break;}}
        else {b=b-a; if(b.z()){while(num--)a.mul2();a.out();break;}}
    }
```







### 辗转相除法

辗转相除法又称欧几里德算法，用于计算两个正整数a，b的最大公约数

计算公式gcd(a,b) = gcd(b,a mod b)。

实现

```
int gcd(int m,int n)
{   
	if(n == 0){
        return m; 
    }
    int r = m%n;
    return gcd(n,r)
}
```





## 算法实战



#### 剑指 Offer 64. 求1+2+…+n

求 `1+2+...+n` ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

```
输入: n = 3
输出: 6
```



解题思路

递归+逻辑判断符

由于不能使用各类关键字，因此利用了逻辑判断符的短路效应

![image-20200715223426713](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200715223426713.png)



解题实现

```java
class Solution {
    public int sumNums(int n) {
        boolean flag = n > 0 && (n += sumNums(n - 1)) > 0;
        return n;
    }
}
```



复杂度

![image-20200715223608838](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200715223608838.png)







#### 剑指 Offer-孩子们的游戏(圆圈中最后剩下的数)

每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)

如果没有小朋友，请返回-1

解题思路

本题本质上是 约瑟夫问题

可以有模拟链表解法和数学+递归解法，其中模拟链表解法复杂度为O(n2)，数学+递归解法复杂度为O(n)

![image-20200716211630710](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200716211630710.png)

![image-20200716211653945](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200716211653945.png)

![约瑟夫环2.png](https://pic.leetcode-cn.com/68509352d82d4a19678ed67a5bde338f86c7d0da730e3a69546f6fa61fb0063c-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF2.png)

```
因此我们可以推出递推公式f(8,3) = [f(7, 3) + 3] % 8
进行推广泛化，即f(n,m) = [f(n-1, m) + m] % n
其中n为当前有n个人，m表示每次杀第几个人
```

牢记递推公式

![image-20200716211845869](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200716211845869.png)



解题实现

1）初始化活下来那个人位置为0

2）从2开始递归到n，调用递推公式

3）返回

```java
   public int lastRemaining(int n, int m) {
        int res = 0; // 最终活下来那个人的初始位置
        for(int i = 2; i <= n; i++){
            res = (res + m) % i;  // 每次循环右移
        }
        return res;
    }
```







#### 剑指 Offer - 打印从1到最大的n位数



解题思路

简单解法

![image-20200724174918678](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200724174918678.png)

解决如下：

```java
class Solution {
    public int[] printNumbers(int n) {
        int end = (int)Math.pow(10, n) - 1;
        int[] res = new int[end];
        for(int i = 0; i < end; i++)
            res[i] = i + 1;
        return res;
    }
}
```



但是不考虑大数就没有意义

（暂时不做，后面做)









#### 求最大公约数

正整数A和正整数B 的最小公倍数是指 能被A和B整除的最小的正整数值，设计一个算法，求输入A和B的最小公倍数。

```
输入
5 7
输出
35
```



解题思路

![image-20200611222136055](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200611222136055.png)



解题实现

递归实现

1）判断两数是否相等，如果相等，返回任意一数

2）判断两数何大，计算差，对较小数与差进行递归

```
if(a>b){
	int diff=a-b;
	recur(b,diff);
}else{
	int diff=b-a;
	recur(a,diff);
}
```













#### 旋转数字/好数

我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。

如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。

现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？

```
输入: 10
输出: 4
解释: 
在[1, 10]中有四个好数： 2, 5, 6, 9。
注意 1 和 10 不是好数, 因为他们在旋转之后不变。
```

解题思路

![image-20200709214148462](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200709214148462.png)



解题实现

1）遍历N，统计判断是否好数

```
int ans = 0;
for (int n = 1; n <= N; ++n)
	if (good(n, false)) ans++;
return ans;
```

好数判断函数

```
public boolean good(int n, boolean flag)
```

1）递归终止：n==0

```
if (n == 0) return flag;
```

2）对n的最后一位进行好数逻辑判断

```
int d = n % 10;
if (d == 3 || d == 4 || d == 7) return false;
if (d == 0 || d == 1 || d == 8) return good(n / 10, flag);
```

3）递归

```
return good(n / 10, true);
```







#### 2的幂

给定一个整数，编写一个函数来判断它是否是 2 的幂次方。



解题实现

1）当n等于0时，直接返回false

2）循环，当n余2等于0时，用2对数进行缩小

```
while(n%2==0){
	n=n/2;
}
```

3）返回判断n是否等于1









#### 机器人跳跃问题

字节跳动2019春招













#### 可被 K 整除的最小整数







### 线性筛法

线性筛法求素数





### 扩展欧几里得算法









### 莫比乌斯反演



































































