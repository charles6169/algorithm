# 动态规划

优秀回答：

https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/

博主

https://www.cnblogs.com/yinbiao/category/1232974.html

## 算法挖掘

![image-20200601061929071](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200601061929071.png)

### 算法思想

![image-20200311210953979](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200311210953979.png)

![image-20200601060437725](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200601060437725.png)



**阶段：**对于一个完整的问题过程，适当的切分为若干个相互联系的子问题，每次在求解一个子问题，则对应一个阶段，整个问题的求解转化为按照阶段次序去求解。

**状态：**状态表示每个阶段开始时所处的客观条件，即在求解子问题时的已知条件。状态描述了研究的问题过程中的状况。

**决策：**决策表示当求解过程处于某一阶段的某一状态时，可以根据当前条件作出不同的选择，从而确定下一个阶段的状态，这种选择称为决策。

**策略：**由所有阶段的决策组成的决策序列称为全过程策略，简称策略。

**最优策略：**在所有的策略中，找到代价最小，性能最优的策略，此策略称为最优策略。

**状态转移方程：**状态转移方程是确定两个相邻阶段状态的演变过程，描述了状态之间是如何演变的。





### DP模板

#### 判定问题

首先需要明确一道题是否可以用动态规划求解，动态规划题型的三大方向：

![image-20200429151647960](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200429151647960.png)

```
how many times  、  max,min  、  if exist
```





#### 三大特征

```
无后效性：“未来与过去无关”，这就是无后效性。

最优子结构：　大问题的最优解可以由小问题的最优解推出，这个性质叫做“最优子结构性质”。

重叠子问题：重叠子问题是一个递归解决方案里包含的子问题虽然很多，但不同子问题很少。少量的子问题被重复解决很多次。
```





#### 四大难点  DTBC

```
Dp数据结构：采用什么数据结构保存怎样的计算结果
TP转移方程：如何利用保存的结果计算状态转移方程
Base基线条件：初始条件和边界情况
Cal:计算顺序：遍历计算的方向
```



状态

![image-20200601060616773](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200601060616773.png)

状态转移方程

![image-20200601060642923](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200601060642923.png)



初始条件

![image-20200601060731069](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200601060731069.png)



计算顺序

由左至右，或由右至左





#### 全局通用模板

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200506151449809.png" alt="image-20200506151449809" style="zoom:80%;" />

硬币兑换和不同路径为通用解题模板的应用实战







##### 





















#### 动态规划优化

![image-20200601060826646](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200601060826646.png)





#### 动态规划打印路径

**注意**

回溯，DFS，BFS都是基于递归来解决问题的，动态规划是基于迭代解决问题，程序中是不会出现递归的











# 算法案例





## 线性规划

线性规划

![image-20200601044419614](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200601044419614.png)

结果存在于线性结构中，如一维数组，二维数组，哈希表







### 序列型

#### 丑数

编写一个程序判断给定的数是否为丑数。

丑数就是只包含质因数 `2, 3, 5` 的**正整数**。

```
输入: 6
输出: true
解释: 6 = 2 × 3

输入: 8
输出: true
解释: 8 = 2 × 2 × 2
```



解题思路

![image-20200611231947978](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200611231947978.png)



解题实现

1）判断是否小于0

2）while循环，当数可以被2,3,5任一个 整除时循环，对数尝试以2,3,5,缩小

```
while(num%2==0||num%3==0||num%5==0){
	if(num%2==0) num=num/2;
	if(num%3==0) num=num/3;
	if(num%5==0) num=num/5;
}

```

3）输出判断是否等于1





#### 剑指offer-丑数 II

​	我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数，1为第一个丑数。

![image-20200427134603111](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200427134603111.png)

首先理解因子：m为n的因子，即能被m整除，n%m=0

解题思路

​		可用暴力穷举法 小根堆 和 动态规划，推荐使用动态规划

![image-20200720215852463](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200720215852463.png)

![image-20200720215932557](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200720215932557.png)

![image-20200720215946928](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200720215946928.png)





解题实现

1）初始化，2，3，5的标识a，b，c为0

2）新建dp数组长度为n，dp数组第一位赋值1

3）循环i从 1 到n

​	  4）求得待比较数n2为dp数组a位乘2、n3为dp数组b位乘3、n5为dp数组c位乘5

​	  5）比较得n2，n3，n5的最小值，并赋值于dp的第i位

​	  6）三次判断，将dp的第i位分别与n2，n3，n5比较，如果true，对应标识自增

7）返回dp数组的最后一位，n-1位

```java
class Solution {
    public int nthUglyNumber(int n) {
        //a,b,c初始化为0
        int a = 0, b = 0, c = 0;
        //动态数组长度为n，初始化0位为1 
        int[] dp = new int[n];
        dp[0] = 1;
        for(int i = 1; i < n; i++) { //遍历右端不取等
            //注意，用a,b,c；来计算n2,n3,n5
            int n2 = dp[a] * 2, n3 = dp[b] * 3, n5 = dp[c] * 5;
            //找到所最小的质数
            dp[i] = Math.min(Math.min(n2, n3), n5);
            if(dp[i] == n2) a++;
            if(dp[i] == n3) b++;
            if(dp[i] == n5) c++;
        }
        return dp[n - 1];
    }
}
```



复杂度

![image-20200720220019244](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200720220019244.png)







#### 最长上升子序列

给定一个无序的整数数组，找到其中最长上升子序列的长度。

![image-20200507151224245](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200507151224245.png)



解题思路

![image-20200507152450737](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200507152450737.png)

解题实现

1）获取数组长度n，如果长度为0，直接返回0

2）新建动态数组，并初始第一位为 1，返回值为 1

3）遍历 i 从1 到 n-1

​		最大临时值maxval为0

​		4）遍历j 从 0 到 i-1，

​				状态转移方程

​				更新 返回值为返回值和dp第i位的较大值

```
for(int i=1;i<n;i++){
	int max=0;
	for(int j=0;j<i;j++){
		if(nums[i]>nums[j]){
			max=Math.max(max,dp[j]);
		}
	}
	dp[i]=max+1;
	res=Math.max(res,dp[i]);
}
```

5）返回

答案

```java
public class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int maxans = 1;
        for (int i = 1; i < dp.length; i++) {
            int maxval = 0;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    maxval = Math.max(maxval, dp[j]);
                }
            }
            dp[i] = maxval + 1;
            maxans = Math.max(maxans, dp[i]);
        }
        return maxans;
    }
}
```



#### 最大子序和

解题思路

![image-20200609212917378](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200609212917378.png)

解题实现

1）初始化res为nums[0]，dp值为0

2）遍历数组，如果dp大于0，dp加上num，否则dp等于num

		3）更新res为最大值

```
for(int num:nums){
	if(dp>0){
		dp+=num;
	}else{
		dp=num;
	}
	res=Math.max(dp,res);
}
```

4）返回res





#### 乘积最大子数组

给你一个整数数组 `nums` ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。

![image-20200506151815439](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200506151815439.png)

解题思路

![image-20200506152712209](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200506152712209.png)

![image-20200506152729045](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200506152729045.png)



这一道题咋一看比较复杂，实际上技巧性很强，可以直接套用规则求出

解题实现

1）获取数组长度，如果长度为0直接返回0

2）新建当前位最大数组和当前位最小数组，并且两个数组的首位和初始化保留最大值均赋值为原生数组的第一位

3）遍历 i 从 1 到 n-1

​	 4）最大值数组的当前值取值为：最小值数组前一位 * 当前数组值、最大值数组的前一位 * 当前值、当前数组值 三者的最大值

​		   最小值数组的当前值取值为：最小值数组前一位 * 当前数组值、最大值数组的前一位 * 当前值、当前数组值 三者的最小值

```
dpMax[i]=Math.max(dpMin[i-1]*nums[i],Math.max(dpMax[i-1]*nums[i],nums[i]));
dpMin[i]=Math.min(dpMin[i-1]*nums[i],Math.min(dpMin[i-1]*nums[i],nums[i]));
```

（仅仅是取向不同，其他一致）

​		5）保留最大值取（之前）保留最大值、最大值数组的当前值两者较大的那个

```
max=Math.max(max,dpMax[i]);
```

6）返回保留最大值







#### 双串

#### 最长公共子序列

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace"，它的长度为 3。

输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。
```

解题思路

序列题型

状态：字符串 `s1` 和 `s2`，一般来说都要构造一个这样的 DP table，一个二维数组

dp [ i ] [ j ]:表示在字符串s[0...i]中和字符串s[0...j]中最长公共子序列的长度为dp[i][j]。

<img src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2F-M3U3aNXgGJVkKZ-TldN%2F-LrtQbQlLmpmk9MnzKMc%2Fdp.png?alt=media" alt="img" style="zoom: 50%;" />

转移方程：

这个问题，是求 `s1` 和 `s2` 的最长公共子序列，不妨称这个子序列为 `lcs`。那么对于 `s1` 和 `s2` 中的每个字符，有什么选择？很简单，两种选择，要么在 `lcs` 中，要么不在。

这个「在」和「不在」就是选择，关键是，应该如何选择呢？这个需要动点脑筋：如果某个字符应该在 `lcs` 中，那么这个字符肯定同时存在于 `s1` 和 `s2` 中，因为 `lcs` 是最长**公共**子序列嘛。

![image-20200603064547466](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200603064547466.png)

(有乱码)

三值：

初始值与边界值：让索引为 0 的行和列表示空串，`dp[0][..]` 和 `dp[..][0]` 都应该初始化为 0，这就是 base case。

遍历方向，从左往右，从上往下



解题实现

1）获取字符串长度，新建二维数组，将边界初始化为0

2）从左往右，从上往下，双层遍历

​		3）状态转移方程

```
if text1.charAt(i-1) == text2.charAt(j-1)
true: dp[i][j] = dp[i - 1][j - 1] + 1;
false: dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
```

4）返回右下角元素











### 坐标型

模板

```
dp数组：二维数组

转移方程：

边界情况：

初始值：（0,0）

需要分析具体情况
```







#### 不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

![image-20200506132153238](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200506132153238.png)

解题思路

![image-20200430142522015](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200430142522015.png)

剖析子问题

![image-20200430142710888](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200430142710888.png)

得到转移方程

![image-20200430142743790](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200430142743790.png)

初始条件和边界情况

![image-20200430142845929](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200430142845929.png)

对于二维问题，边界情况一般是i=0或j=0时，其转移方程是不一样的

计算顺序

![image-20200430143100272](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200430143100272.png)

时间复杂度为O(MN)，即数组横纵轴之积



解题实现

1）初始化二维动态数组，大小为m*n，0，0位上元素初始为0

2）双层遍历，i从0到m-1，j从0到n-1

​	3）当为边界情况时，dp[ i ] [ j ]=1，否则 状态转移

```
if(i==0||j==0){
	dp[i][j]=1;
}else{
	dp[i][j]=dp[i-1][j]+dp[i][j-1];
}
```

4）返回右下角的那一项





#### 不同路径 II

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

![image-20200506133208849](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200506133208849.png)

解题思路

​		机器人只可以向下和向右移动，因此第一行的格子只能从左边的格子移动到，第一列的格子只能从上方的格子移动到。对于剩下的格子，可以从左边或者上方的格子移动到。

![image-20200506135118030](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200506135118030.png)

解题实现

1）获取障碍数组的行列值

2）若障碍数组的0,0值为1，直接返回0

3）初始化障碍数组的0,0值为1

4）对第一行进行遍历，判断如果当前项为0且前一项为1，将当前项赋值为1，否则赋值为0

```
for(int i=1;i<R;i++){
	obstracleGrid[i][0]=(obstracleGrid[i][0]==0&&obstracleGrid[i-1][0]==1)?1:0;
}
```

5）对第一列进行遍历，判断如果当前项为0，前一项为1，将当前项赋值为1，否则赋值为0

```
for(int j=1;j<C;j++){
	obstracleGrid[0][j]=(obstracleGrid[0][j]==0&&obstracleGrid[0][j-1]==1)?1:0;
}
```

6）从1，1开始分析，双层遍历 i 从 1 到 R-1，j 从 1 到 C-1

​		7）如果当前为元素为0，i,j位上的元素为i-1,j和i,j-1两个元素之和，否则i,j位元素赋值为0

```
if(obstracleGrid[i][j]==0){
	obstracleGrid[i][j]=obstracleGrid[i-1][j]+obstracleGrid[i][j-1];
}else{
	obstracleGrid[i][j]=0;
}
```

8）返回右下角值



#### 不同路径 III

在二维网格 grid 上，有 4 种类型的方格：

1 表示起始方格。且只有一个起始方格。
2 表示结束方格，且只有一个结束方格。
0 表示我们可以走过的空方格。
-1 表示我们无法跨越的障碍。
返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。









#### 三角形最小路径和

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：

![image-20200507140503283](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200507140503283.png)

解题思路

首先是换角度

![image-20200507142239538](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200507142239538.png)

![image-20200507142250968](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200507142250968.png)



解题实现

1）判断三角形是否为空，如果为空直接返回0

2）获取三角形的两条直角边

3）新建二维动态数组，初始化0,0值为三角形的0,0值，初始化返回值为MAX_VALUE

4）双层遍历 i从 1 到 row-1，j 从 0 到 i

​		5）如果j为0，处理最左端的情况，如果j==i，处理最右端的情况，否则一般转移方程，当前值仅由正上方、正上方的值中较小的那个与当前值相加

```
if(j==0){
	dp[i][j]=dp[i-1][j]+triangle.get(i).get(j);
}else if(i==j){
	dp[i][j]=dp[i-1][j-1]+triangle.get(i).get(j);
}else{
	dp[i][j]=Math.min(dp[i-1][j],dp[i-1][j-1])+triangle.get(i).get(j);
}
```

6）遍历最后一行，找出最小的那个（最小路径，如果求最大路径就找最大的那个

```
for(int i=0;i<col;i++){
	res=Math.min(res,dp[row-1][i]);
}
```

7）返回



#### 金字塔金币

(三角形最小路径和变体)

​		小招在玩一款游戏：在一个N层高的金字塔上，以金字塔顶为第一层，第i层有i个落点，每个落点有若干枚金币，在落点可以跳向左斜向下或向右斜向下的落点。若知道金字塔的层数N及每层的金币数量分布，请计算小招在本次游戏中可以获得的最多金币数量。（招银真题）

输入共有N + 1行(N ≤ 1024)，第一行为高度N，第二行至N + 1行 ，为该金字塔的金币数量分布。

![image-20200429123509096](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200429123509096.png)

**解题思路**

当前位置的总金币数等于 当前位置的金币数 + 左上或右上最多的总金币数



**解题实现**

1）初始化动态规划矩阵，大小为N*N+1，初始值为金字塔顶端值

2）遍历矩阵，i从1 到 N-1，j从0 到 i （金字塔）

3）当 j 为0时，位于最左边，执行转移矩阵一（正上+当前），否则执行转移矩阵二（左上和正上中较大的那个和当前值的和）

```
if(j==0){
	dp[i][j]=dp[i-1][j]+data[i][j];
}else{
	dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-1])+data[i][j];
}
```

4）对动态规划矩阵的最后一行进行分析，求得最大值便是返回结果

```
int max=dp[N-1][0];
for(int i=0;i<N+1;i++){
	if(dp[N-1][i]>max){
		max=dp[N-1][i];
	}
}
```





#### 网易2020校招笔试-乘积

![image-20200707215357265](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200707215357265.png)

```
in
5 12
1 3 9 2 6
out
10
```



解题思路

dp[i][j] 表示前i个数的乘积等于j时所需要进行的变换的最小代价。

![image-20200707215454196](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200707215454196.png)

解题实现

```java
public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int target = scanner.nextInt();

        int[] h = new int[n];
        for(int i = 0; i < n; i++) {
            h[i] = scanner.nextInt();
        }

        //dp[i][j] 表示前i个数字 使得为j 所需要的代价
        Integer[][] dp = new Integer[n+1][target + 1];

        int sum = 0;
        //前i个的值为1的dp值  作边界值
        for(int i = 1; i <= n; i++) {
            sum += h[i-1] - 1;
            dp[i][1] = sum;
        }

        //第1个数到target的dp值  作边界值
        for (int j = 1; j <= target; j++) {
            dp[1][j] = Math.abs(j - h[0]);
        }


        int result = doCheck(dp, n, target, h);

        System.out.println(result);

    }

    private static int doCheck(Integer[][] dp, int n, int target, int[] h) {
        //如果n,target已填，直接退出
        if (dp[n][target] != null) {
            return  dp[n][target];
        }

        //初始化min为极小值
        int min = Integer.MAX_VALUE;
        for (int i = 1; i <= target; i++) {
            // 找到target的因子i
            if (target % i != 0) {
                continue;
            }
            //计算余数
            int j = target / i;
            //递归计算
            min = Math.min(min, doCheck(dp, n-1, j, h) + Math.abs(h[n-1] - i));
        }

        return dp[n][target] = min;
    }
```









#### 最大的以 1 为边界的正方形

给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。

```
输入：grid = [[1,1,1],[1,0,1],[1,1,1]]
输出：9
```


解题思路

dp是三维数组

dp [i] [j] [0] 表示(i, j)处往左延伸最多有多少个1
dp [i] [j] [1] 表示(i, j)处往上延伸最多有多少个1

![image-20200622205420526](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200622205420526.png)

先找到单条线上的最大Size，然后看最左边的顶点往上延伸的最多能有的1的个数是不是大于当前size，同时看最上边的顶点往左延伸的最多能有的1的个数是不是大于当前size



状态转移方程

```
//注意：0表示向左，1表示向上
dp[i][j][0] = 1 + dp[i][j-1][0];
dp[i][j][1] = 1 + dp[i-1][j][1];
int size = Math.min(dp[i][j][0], dp[i][j][1]);
//特别注意，这里反过来了，向左的要向上走，向上的要向左走
while (dp[i][j-size+1][1] < size || dp[i-size+1][j][0] < size) {
	size--;
}
```



难点在于 dp数组的确定，转移方程

解题实现

1）获取数组长宽，新建三维Dp数组

2）初始化返回值

3）双层遍历

​		4）如果i-1,j-1位为1，执行状态转移方程

```
dp[i][j][0]=dp[i][j-1][0]+1;
dp[i][j][1]=dp[i-1][j][1]+1;
int size=Math.min(dp[i][j][0],dp[i][j][1]);
while(dp[i][j-size+1][1]<size||dp[i-size+1][j][0]<size){
	size--;
}
```

​		5）更新res

6）返回res 







### 打家劫舍

#### 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

解题实现

1）当数组长度为0时，直接返回0，当数组长度为1时，返回数组第1位

2）新建动态数组，对0，1位进行赋值

3）i从2到n-1遍历，按照转移方程求解

```
for(int i=2;i<n;i++){
	dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]);
}
```

4）返回





#### 打家劫舍 II

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200520132406969.png" alt="image-20200520132406969" style="zoom:80%;" />

解题思路

![image-20200520132436866](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200520132436866.png)

解题实现

1）分别对数组长度为0和1的情况进行分析

2）将数组分成两种情况，1：和：n-1两种分别运用动态规划，得到结果取其较大的那个





#### 按摩师

一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200520125508665.png" alt="image-20200520125508665" style="zoom:80%;" />

按摩师的解法和打家劫舍差不多

解题思路

转移方程：`dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])`

解题实现

1）分别对数组长度为0和1两种情况进行讨论

2）新建动态数组，初始化数组0,1值

3）i从2到n-1遍历

​		4)转移方程`dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]`

5）返回



#### 删除与获得点数

给定一个整数数组 nums ，你可以对它进行一些操作。

每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

```
输入: nums = [3, 4, 2]
输出: 6
解释: 
删除 4 来获得 4 个点数，因此 3 也被删除。
之后，删除 2 来获得 2 个点数。总共获得 6 个点数。

输入: nums = [2, 2, 3, 3, 3, 4]
输出: 9
解释: 
删除 3 来获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
```



解题思路

![image-20200628195728430](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200628195728430.png)

本题的难点在于建立数值坐标数组all

然后用all数组找到状态转移方程



解题实现

1）空值和1值判断

2）构造all数组，获取长度，找到最大值

3）新建动态数组

4）初始化1和2位，注意2位的初始

```
dp[1]=all[1]*1;
dp[2]=Math.max(dp[1],all[2]*2);
```

5）遍历 i 从2到max，状态转移方程

```
for(int i=2;i<=max;i++){
	dp[i]=Math.max(dp[i-1],dp[i-2]+i*all[i]);
}
```

6）返回



### 股票系列

明确状态

**问题的「状态」有三个**，第一个是天数，第二个是**允许交易的最大次数**(k)，第三个是当前的持有状态，比如说 dp[3] [2] [1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2] [3] [0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。

状态转移框架

<img src="https://pic.leetcode-cn.com/c4eb5f0aa4daf7bef4b3b8af95129bb7394ec58e1ba7b191d9104bbd8ff1ccb3-40198bf2f6894018328b250b772b4a17724a983f99ba359b798a289733bffcbc-file_1559885188422-1.png" alt="40198bf2f6894018328b250b772b4a17724a983f99ba359b798a289733bffcbc-file_1559885188422-1.png" style="zoom: 67%;" />

根据这个图，我们来写一下状态转移方程

```
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
              max(   选择 rest  ,           选择 sell      )

解释：今天我没有持有股票，有两种可能：
要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。

dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
              max(   选择 rest  ,           选择 buy         )

解释：今天我持有着股票，有两种可能：
要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。

```

这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。

定义 base case

```
dp[-1][k][0] = 0
解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。
dp[-1][k][1] = -infinity
解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。
dp[i][0][0] = 0
解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。
dp[i][0][1] = -infinity
解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。
```



祖宗公式总结（记住）

```java
初始化 base case：
dp[-1][k][0]  = 0
dp[-1][k][1]  = -infinity

    
状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
    核心部分是：dp[i-1][k-1][0]
```

问题的改变主要是k与约束的改变，因此主要对k分析



#### 买卖股票的最佳时机（k=1)

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你**最多只允许完成一笔交易**（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```



解题思路

```
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) 
            = max(dp[i-1][1][1], -prices[i])
解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。

现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。
可以进行进一步化简去掉所有 k：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], -prices[i])
```

同时对第0位和第1位初始化处理



解题实现

1）获取价格数组长度，动态数组抽象缺省为单变量，初始化i,0和i,1分别为0和MIN_VALUE

```
int dp_i_0=0;
int dp_i_1=Integer.MINVALUE;
```

2）遍历 i 从 0 到 n - 1

​		3）状态转移方程

```
dp_i_0=Math.max(dp_i_0,dp_i_1+prices[i]);
dp_i_1=Math.max(dp_i_1,-prices[i]);
```

4）返回dp_i_0；







#### 招商银行信用卡中心2019秋招IT笔试-比特币最佳买卖时机

```java
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String[] s1 = sc.nextLine().split(" ");
        int[] nums = new int[s1.length];
        for (int i = 0; i < s1.length; i++) {
            nums[i] = Integer.parseInt(s1[i]);
        }


        int dp_i_0 = 0;
        int dp_i_1 = Integer.MIN_VALUE;
        for (int i = 0; i < nums.length; i++) {
            dp_i_0 = Math.max(dp_i_0, dp_i_1 + nums[i]);
            dp_i_1 = Math.max(dp_i_1, -nums[i]);
        }
        System.out.println(dp_i_0);
    }
}
```



#### 买卖股票的最佳时机 II(k=+inf)

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以**尽可能地完成更多的交易**（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 
```

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```





解题思路

如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架

```
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])

认为：dp[i-1][k-1][0]等同于dp[i-1][k][0]

我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
```



解题实现

1）获取价格数组长度，动态数组抽象缺省为单变量，初始化i,0和i,1分别为0和MIN_VALUE

```
int dp_i_0=0;
int dp_i_1=-Integer.MINVALUE;
```

2）遍历 i 从 0 到 n - 1

​		3）先保存dp_i_0状态，状态转移方程

```
int temp=dp_i_0;
dp_i_0=Math.max(dp_i_0,dp_i_1+prices[i]);
dp_i_1=Math.max(dp_i_1,temp-prices[i]);
```

4）返回dp_i_0；



#### 买卖股票的最佳时机含手续费(k=+inf,fee)

给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；**非负整数 fee 代表了交易股票的手续费用**。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

```
输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.

```



解题思路

每次交易要支付手续费，只要把手续费从利润中减去即可。

```
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)
解释：相当于买入股票的价格升高了。
在第一个式子里减也是一样的，相当于卖出股票的价格减小了。
```



解题实现

1）获取价格数组长度，动态数组抽象缺省为单变量，初始化i,0和i,1分别为0和MIN_VALUE

```
int dp_i_0=0;
int dp_i_1=-Integer.MINVALUE;
```

2）遍历 i 从 0 到 n - 1

​		3）先保存dp_i_0状态到temp，状态转移方程，只是在买的时候加上手续费即可

```
int temp=dp_i_0;
dp_i_0=Math.max(dp_i_0,dp_i_1+prices[i]);
dp_i_1=Math.max(dp_i_1,temp-prices[i]-fee);
```

4）返回dp_i_0；





#### 最佳买卖股票时机含冷冻期(k=+inf,freeze)

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

```
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```



解题思路

每次 sell 之后要等一天才能继续交易，因此是在买的时候，转移的状态是两天前的

```
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])
解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。
```



解题实现

1）获取价格数组长度，动态数组抽象缺省为单变量，初始化i,0和i,1分别为0和MIN_VALUE，初始化 dp_i_2 为 0

```
int dp_i_0=0;
int dp_i_1=Integer.MINVALUE;
```

2）遍历 i 从 0 到 n - 1

​		3）先保存dp_i_0状态到temp，状态转移方程，在保存temp状态到dp_i_2，就是把上一个dp_i_0状态给dp_i_2

```
int temp=dp_i_0;
dp_i_0=Math.max(dp_i_0,dp_i_1+prices[i]);
dp_i_1=Math.max(dp_i_1,dp_i_2-prices[i]);
dp_i_2=tmep;
```

4）返回dp_i_0；









#### 买卖股票的最佳时机 III（k=2);

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你**最多可以完成 两笔 交易**。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```
输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 
```

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```



解题思路

​		k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。

这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。

```
原始的动态转移方程，没有可化简的地方
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```

之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举

```
dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])
dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
dp[i][1][1] = max(dp[i-1][1][1], -prices[i])
```



解题实现

1）因为只有四个状态，因此可以穷举初始化dp_i10，dp_i11，dp_i20，dp_i21

分别为0，MIN_VALUE，0，MIN_VALUE

```
int dp_i10=0,dp_i11=Integer.MINVALUE;
int dp_i20=0,dp_i21=Integer.MINVALUE;
```

2）比较特殊，遍历价格，状态转移方程，先写k为2再写k为1

```
dp_i20=Math.max(dp_i20,dp_i21+price);
dp_i21=Math.max(dp_i21,dp_i10-price);
dp_i10=Math.max(dp_i10,dp_i11+price);
dp_i11=Math.max(dp_i11,-price);
```

3）返回dp_i20



#### 买卖股票的最佳时机 IV(k=any)

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```
输入: [2,4,1], k = 2
输出: 2
解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。

输入: [3,2,6,5,0,3], k = 2
输出: 7
解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```



解题思路

​		有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？

​		一次交易由买入和卖出构成，至少需要两天。所以说**有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了**，相当于 k = +infinity。这种情况是之前解决过的。如果 k 小于 n/2，就和上一题逻辑一样，需要对k进行枚举



解题实现

1）获取价格数组长度，判断max_k是否大于n/2，如果是，直接等同k为+inf的情况，否则继续

2）初始化三维数组，尺寸为n,max_k+1,2

```
int[][][] dp=new int[n][max_k+1][2];
```

3）双层遍历i从0到n-1，k从max_k到1

​		4）判断，如果i==0，初始化 i,k,0 和 i,k,1 分别为 0 和-prices[i]，继续

​		5）执行状态转移方程

```
for(int i=0;i<n;i++){
	for(int k=max_k;k>=1;k--){
		if(i==0){
			dp[i][k][0]=0;
			dp[i][k][1]=-prices[i];(易错)
			continue;(易错)
		}
		dp[i][k][0]=Math.max(dp[i-1][k][0],dp[i-1][k][1]+prices[i]);
		dp[i][k][1]=Math.max(dp[i-1][k][1],dp[i-1][k-1][0]-prices[i]):
		
	}
}
```

6）返回动态数组 n-1,max_k,0 位



### 字符串匹配

#### 编辑距离

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

```
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```





解题思路

对题目的操作进行分析

参考：https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-by-leetcode-solution/

![image-20200604055131663](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200604055131663.png)

![image-20200604055202080](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200604055202080.png)

递归也可以解决，但是会复杂度超时，应该使用动态规划解决

分析得到状态和转移方程

![image-20200604055323317](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200604055323317.png)

![image-20200604055338138](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200604055338138.png)





解题实现

1）首先获取两个字串的长度，新建二维动态数组，大小为[len1 + 1] [len2 + 1]

2）初始值：初始第一行和第一列，原则是后一项为前一项+1

3）双层遍历 i 从 1 到 len1，j 从 1 到 len2

​		4）状态转移方程

```
if word1.charAt(i-1)==word2.charAt(j-1)
true:
	dp[i][j]=dp[i-1][j-1];
false:
	1+min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])
```

```
for(int i=1;i<=len1;i++){
	for(int j=1;j<len2;j++){
		if(word1.charAt(i-1)==word2.charAt(j-1)){
			dp[i][j]=dp[i-1][j-1];
		}else{
			dp[i][j]=1+Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1]));
		}
	}
}
```

5）返回数组[len1] [len2]位



#### 通配符匹配

























#### 区域和检索 - 数组不可变

给定一个整数数组  *nums*，求出数组从索引 *i* 到 *j* (*i* ≤ *j*) 范围内元素的总和，包含 *i, j* 两点。

```
给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3
```



解题思路

暴力求解会超时，应当用一个dp数组先将数据相加起来，再直接用dp数组获取结果

转移方程：

```
dp[i]=dp[i-1]+nums[i];
```



解题实现

```
class NumArray {
    int[] dp;
    public NumArray(int[] nums) {
        dp=new int[nums.length];
        if(nums.length>0){
            dp[0]=nums[0];
            for(int i=1;i<nums.length;i++){
                dp[i]=dp[i-1]+nums[i];
            }
        }
    }
    
    public int sumRange(int i, int j) {
        if(dp.length==0){
            return 0;
        }
        if(i==0){
            return dp[j];
        }
        return dp[j]-dp[i-1];
    }
}
```













#### 最长连续递增序列

给定一个未经排序的整数数组，找到最长且连续的的递增序列，并返回该序列的长度。

输入: [1,3,5,4,7]
输出: 3
解释: 最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。

```
输入: [1,3,5,4,7]
输出: 3
解释: 最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 

```

解题实现

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        if(nums.length==0){
            return 0;
        }
        int len=nums.length;
        int[] dp=new int[len];
        dp[0]=1;
        int max=dp[0];
        for(int i=1;i<len;i++){
            if(nums[i]>nums[i-1]){
                dp[i]=dp[i-1]+1;
            }else{
                dp[i]=1;
            }
            max=Math.max(dp[i],max);
        }
        return max;
    }
}
```













#### 等差数列划分

如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。

数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0<=P<Q<N 。

如果满足以下条件，则称子数组(P, Q)为等差数组：

元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 < Q 。

函数要返回数组 A 中所有为等差数组的子数组个数。

```
A = [1, 2, 3, 4]

返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。
```

解题思路

![image-20200609225330262](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200609225330262.png)

状态：dp[ i ] 表示以A[i]为结尾的等差数列的个数

转移方程：

```
dp[i]={
dp[i-1]+1  ...if A[i]+A[i-2]==A[i-1]+A[i-1];
	0      ...else
}			
```

状态定义的逻辑：**以当前元素结尾的XXX**

等差数列判断关系：

```
A[i]+A[i-2]==A[i-1]+A[i-1]
```

解题实现

1）获取数组长度len,如果数组长度小于3直接返回0

2）直接判断数组长度等于3时的情况

```
if(len==3){
	return A[2]+A[0]==A[1]+A[1]?1:0;
}
```

3） 初始化dp数组，长度为len

4）利用等差关系初始化dp数组第2位，初始化返回值res等于dp数组第2位

```
int[] dp=new int[len];
dp[2]=A[2]+A[0]==A[1]+A[1]?1:0;
int res=dp[2];
```

5）遍历，从左至右i从3到len-1

​		6）如果满足等差关系，状态转移，并累积返回值res

```
for(int i=3;i<len;i++){
	if(A[i]+A[i-2]==A[i-1]+A[i-1]){
		dp[i]=dp[i-1]+1;
		res+=dp[i];
	}else{
		dp[i]=0;
	}
}
```

7）返回res





####  等差数列划分 II - 子序列







#### 最长重复子数组

给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。

```
输入:
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出: 3
解释: 
长度最长的公共子数组是 [3, 2, 1]。
```









#### 不同的二叉搜索树

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```



解题思路

直觉

本问题可以用动态规划求解。

给定一个有序序列 1 ... n，为了根据序列构建一棵二叉搜索树。我们可以遍历每个数字 i，将该数字作为树根，1 ... (i-1) 序列将成为左子树，(i+1) ... n 序列将成为右子树。于是，我们可以递归地从子序列构建子树。
在上述方法中，由于根各自不同，每棵二叉树都保证是独特的。

可见，问题可以分解成规模较小的子问题。因此，我们可以存储并复用子问题的解，而不是递归的（也重复的）解决这些子问题，这就是动态规划法。



本题的难点在于从数学和递归的角度分析出状态转移方程

![image-20200628194226345](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200628194226345.png)

![image-20200628194246175](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200628194246175.png)

递归表达公式便是动态规划的转移方程

```
G[i]=Sum(G[j-1]*G[i=j]);
```

并且注意明确初始值G[0] 和G[1] 均为 1



解题实现

1）初始化动态数组

2）base基准值

3）双层遍历，状态转移方程  ，注意 j 可以取到 i

```
for(int i=2;i<=n;i++){
	for(int j=1;j<=i;j++){
		dp[i]+=dp[i-1]*dp[i-j];
	}
}
```

4）返回dp[n]

















#### 连续数列

给定一个整数数组，找出总和最大的连续数列，并返回总和。

![image-20200520121643404](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200520121643404.png)



解題思路

![image-20200520121709489](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200520121709489.png)

解题实现

1）初始化temp为数组第一个元素，返回值res等于temp

2）i 遍历数组

​		3）当temp小于0时，令temp等于数组当前位，否则temp加上数组当前位

​		4）如果temp大于返回值，更新返回值等于temp

```
if(temp<0){
	temp=nums[i];
}else{
	temp+=nums[i];
}
if(temp>res){
	res=temp;
}

```

5）返回



































### 划分型动态规划

给一串字符串，划分成若干段，使满足一个性质

####  完全平方数

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

```
输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.

输入: n = 13
输出: 2
解释: 13 = 4 + 9.
```



解题思路

![image-20200602041249332](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200602041249332.png)

![image-20200602041306106](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200602041306106.png)



解题实现

1）新建动态数组长度为n-1，初始化0位为0，数组填充为Integer极大值

2）计算最大平方数，新建并初始化完全平方数列表

3）双层遍历 i 从 1 到 n ，j从1到 最大平方数-1 

​		4）判断，如果i小于完全平方数，直接跳过

​		5）否则，执行状态转移方程

```
for(int i=1;i<=n;i++){
	for(int j=1;j<max_square;j++){
		if(i<square_num[j]){
			break;
		}else{
			dp[i]=Math.min(dp[i],dp[i-square_num[j]]+1);
		}
		
	}
}
```

6）返回动态数组n位



#### 整数拆分

给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

解题思路

![image-20200602053854091](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200602053854091.png)

解题实现

1）新建动态数组长度为n+1，填充为1

2）双层遍历  i 从 3 到 n ，j 从 1 到 i - 1

​		3）状态转移方程：i，j * (i-j) ，j * dp[ i - j ] 的最大值

```
dp[i]=max(dp[i],j*(i-j),j*dp[i-j]);
```

4）返回第n位





#### 解码方法

一条包含字母 `A-Z` 的消息通过以下方式进行了编码

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

给定一个只包含数字的**非空**字符串，请计算解码方法的总数。

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200525060237688.png" alt="image-20200525060237688" style="zoom:80%;" />



解题思路

本题的关键在于分析到五种状态转移方程（六种可能）

![image-20200525060334101](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200525060334101.png)

第二种情况，只由y位进行解码，一定只有一种，因此i位的dp值与i-1位的dp值相等

第三种情况，当y等于0，分两种情况，如果xy小于26，则可以解码，但是解码后必然只有一种情况，因此i位的dp值与i-2位dp值相等，否则直接返回0

第四种情况，如果xy小于等于26，首先肯定可以单独放在abcx的每次情况之后，且如果x单独结尾，则可以合并xy作结尾，那么i位的dp值为 i-1 和 i-2 之和

第五种情况，如果xy大于26，所以y只能单独放在x后，那么i位的dp值就和i-1位一致



本题本质上还是线性规划，只是转移方程比较复杂

解题实现

1）将字符串转为字符数组，新建动态数组长度为数组长度+1

2）初始化动态数组0位为1，如果字符数组第一位为 '0’时初始化为0否则初始化为1

3）判断如果字符数组长度小于等于1，直接返回动态数组第一位

4）遍历i从2到字符数组长度

​		5）计算i-1位和i-2位（x,y) 解码之和保存为n

​		6）五种情况判断：

​				7）如果i-1位和i-2位均为0，直接返回0

​				8）如果i-2（x）等于0，只由y位进行解码，一定只有一种，因此i位的dp值与i-1位的dp值相等

​				9）当y等于0，分两种情况，如果xy小于26，则可以解码，但是解码后必然只有一种情况，因此i位的dp值与i-2位dp值相等，否则直接返回0

​				10）如果xy小于26，首先肯定可以单独放在abcx的每次情况之后，且如果x单独结尾，则可以合并xy作结尾，那么i位的dp值为 i-1 和 i-2 之和

​				11）如果xy小于等于26，首先肯定可以单独放在abcx的每次情况之后，且如果x单独结尾，则可以合并xy作结尾，那么i位的dp值为 i-1 和 i-2 之和

​				12）如果xy大于26，所以y只能单独放在x后，那么i位的dp值就和i-1位一致

```
for(int i=2;i<=s.length();i++){
	int n=(arr[i-1]-'0')*10+(arr[i-1]-'0');
	if(arr[i-1]=='0'&&arr[i-2]=='0'){
		return 0;
	}else if(arr[i-2]=='0'){
		dp[i]=dp[i-1];
	}else if(arr[i-1]=='0'){
		if(n>26) return 0;
		dp[i]=dp[i-2];
	}else if(n<=26){
		dp[i]=dp[i-1]+dp[i-2];
	}else{
		dp[i]=dp[i-1];
	}
}
```

13）返回动态数组最后一位















#### 分割数组的最大值





















## 区间规划

区间型动态规划：连续的一段，有开始有结束

![image-20200601045942817](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200601045942817.png)



​		枚举所有的区间和区间内的点，**区间内的点**和**区间左右端点**将整个区间又划分为两个`已知的子区间`



模板

```
int[][] dp=new int[n][n];

//初始dp数组
for(int len=2;len<=n;len++){
    //枚举区间长度
    for(int i=1;i<n;++i){//枚举区间的起点
        int j=i+len-1;//根据起点和长度得出终点
        if(j>n) break;//符合条件的终点
        for(int k=i;k<=j;++k)//枚举最优分割点
            dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+w[i][j]);//状态转移方程
        }
}
```







解题思路

当绳子长度n>3时，最后一段绳子长度只有2，3两种情况(证明参考高赞精选贴)，因此可得转移方程

```
dp[i]=max(2*dp[i-2],3*dp[i-3]);
```



解题实现

1）边界情况：n小于等于3返回n-1

```
if(n<=3){
	return n-1;
}
```

2）Dp数组与初始值

```
int[] dp=new int[n+1];
dp[2]=2;dp[3]=3;
```

3）遍历，TF方程

```
for(int i=4;i<=n;i++){
	dp[i]=Math.max(2*dp[i-2],3*dp[i-3]);
}
```

4）返回

```
return dp[n];
```



#### 回文子串

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。

```
输入: "abc"
输出: 3
解释: 三个回文子串: "a", "b", "c".

输入: "aaa"
输出: 6
说明: 6个回文子串: "a", "a", "a", "aa", "aa", "aaa".
```



解题思路

![image-20200609221406155](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200609221406155.png)

![image-20200609221432806](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200609221432806.png)

初始值

![image-20200609221449993](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200609221449993.png)

遍历方向：右下角开始遍历。蓝色线

```
for(int i=len-1;i>=0;i--){
	for(int j=i+1;j<len;j++){
		
	}
}
```



特殊情况

![image-20200609221513281](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200609221513281.png)

需要对这种相邻情况特别考虑



由于返回回文串个数，因此直接统计即可



解题实现

1）空值和“” 情况判定

2）获取数组长度，创建二维dp数组，新建返回值为数组长度（因为至少单个字母都回文）

3）初始值：dp数组，对角线初始化为true

4）从右下角到左上角 双层遍历 i 从len-1到0，j从i+1到len-1

​		5）判断，如果字符串 i，j位相等，

​				6）判断i，j是否相邻，相邻时dp 为true，否则状态转移

​		7）否则 dp 为false

​		8）判断dp，统计res

```java
for(int i=len-1;i>=0;i--){
	for(int j=i+1;j<len;j++){
		if(s.charAt(i)==s.charAt(j)){
			if(j-i==1){
				dp[i][j]=true;
			}else{
				dp[i][j]=dp[i+1][j-1];
			}
		}else{
			dp[i][j]=false;
		}
		if(dp[i][j]){
			res++;
		}
	}
}
```

9）返回res







#### 最长回文子串

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。

输入: "cbbd"
输出: "bb"
```

解题思路

![image-20200601060048907](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200601060048907.png)

![image-20200601060101804](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200601060101804.png)



解题实现

1）获取字符串长度，如果长度小于2，直接返回字符串

2）初始化回文串最大长度和回文起始坐标分别为1和0

3）新建二维动态数组，将字符串转字符数组，初始化动态数组对角线为true

4）双层遍历 j 从1到 len-1，i 从0到 j-1

​		5）如果字符数组，i,j位不同，直接返回false

​		6）否则判断如果 j - i 小于3直接返回真

​		7）否则转移方程 i，j值等于i+1，j-1的值

​		8）确定回文串最大长度和回文起始坐标，判断i,j为真且j - i+1大于之前回文串最大长度时

​				9）回文串最大长度等于j - i+1

​				10）回文起始坐标等于 i

```
for(int j=1;j<len;j++){
	for(int i=0;i<j,i++){
		if(charArray[i]!=charArray[j]){
			dp[i][j]=false;
		}else{
			if(j-i<3){
				dp[i][j]=true;
			}else{
				dp[i][j]=dp[i+1][j-1];
			}
		}
		if(dp[i][j]&&j-i+1>maxVal){
			maxVal=j-i+1;
			begin=i;
		}
	}
}
```

11）返回回文串

```
return s.substring(begin, begin + maxLen);
```





#### 多边形三角剖分的最低得分

给定 N，想象一个凸 N 边多边形，其顶点按顺时针顺序依次标记为 A[0], A[i], ..., A[N-1]。

假设您将多边形剖分为 N-2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 N-2 个三角形的值之和。

返回多边形进行三角剖分后可以得到的最低分。

![image-20200701195800175](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200701195800175.png)



```
输入：[3,7,4,5]
输出：144
解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。
```





解题思路

本题的一个难点在于构建dp数组，定义状态，dp[ i ] [ j ]  表示i到j序列的最低分

![image-20200701195830253](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200701195830253.png)

```
dp[i][j]=min(dp[i][m]+A[i]*A[j]*A[m]+dp[m][j]);

注意累积上dp[i][m]和dp[m][j]
```



计算顺序：

1，对 j 枚举，从 2 到 size -1

2，对 i 枚举，从 j - 2 到 0

3，对 m 枚举，从 i+1 到 j -1

这三个变量的枚举计算顺序是一个难点

<img src="C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200701200807096.png" alt="image-20200701200807096" style="zoom:67%;" />



解题实现









#### 





## 约束规划

### 背包型

背包九讲

https://www.bilibili.com/video/BV1qt411Z7nE

1. 01 背包问题
2. 完全背包问题
3. 多重背包问题
4. 混合背包问题
5. 二维费用背包问题
6. 分组背包问题
7. 背包问题求方案数
8. 求背包问题的方案
9. 有依赖的背包问题

首先，这些问题具有一个共同的前提：

有 n 个物品和容量为 V 的背包，第 i 件物品的体积为 c[i]，价值为 w[i]。现在的目标是确定要将哪些物体放入背包，以保证在体积 不超过背包容量 的前提下，背包内的 总价值最高？

![img](https://pic.leetcode-cn.com/c4874b45f3bf5bb90c555489832117ba6a193b984a5fc3490012552c627720d3.png)

背包问题的求解模板

```
1.分析是否为背包问题。
2.是以上三种背包问题中的哪一种。
3.是0-1背包问题还是完全背包问题。也就是题目给的nums数组中的元素是否可以重复使用。
4.如果是组合问题，是否需要考虑元素之间的顺序。需要考虑顺序有顺序的解法，不需要考虑顺序又有对应的解法。

```

背包问题的判定

​		背包问题具备的特征：给定一个target，target可以是数字也可以是字符串，再给定一个数组nums，nums中装的可能是数字，也可能是字符串，问：能否使用nums中的元素做各种排列组合得到target。

背包问题技巧

1.如果是0-1背包，即数组中的元素不可重复使用，nums放在外循环，target在内循环，且内循环倒序；

```
for num in nums:
    for i in range(target, nums-1, -1):
```


2.如果是完全背包，即数组中的元素可重复使用，nums放在外循环，target在内循环。且内循环正序。

```
for num in nums:
    for i in range(nums, target+1):
```


3.如果组合问题需考虑元素之间的顺序，需将target放在外循环，将nums放在内循环。

```
for i in range(1, target+1):
    for num in nums:
```









01 背包问题

约束条件：每种物品数量为 1，可以选择放或不放

01背包和完全背包的区别

- 01背包——每种物品只能选0件或者1件
- 完全背包——每种物品可以选0至多件，没有限制

```
0—1背包：dp[ i+1 ][ j ] = max ( dp[ i ][ j ], dp[ i ][ j - ci ] + wi )；
完全背包：dp[ i+1 ][ j ] = max ( dp[ i ][ j ], dp[ i +1 ][ j - ci ] + wi )；
```



常见题型分类

```
分割等和子集 (01背包-要求恰好取到背包容量)
目标和 (01背包-求方案数)
零钱兑换 (完全背包)
零钱兑换 II (完全背包-求方案数)
一和零 (二维费用背包)
```





#### 分割等和子集

给定一个**只包含正整数**的**非空**数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

```
输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].
```

```
输入: [1, 2, 3, 5]

输出: false

解释: 数组不能分割成两个元素和相等的子集.
```



解题思路

![image-20200601071420017](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200601071420017.png)

![image-20200601071431374](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200601071431374.png)



行为数组坐标，列为求和值坐标

解题实现

1）获取数组长度，如果数组长度为0直接返回false，初始化总和为0，计算总和，判断如果总和是奇数直接返回false，计算半数值

2）初始化数组0，nums[0]为true

3）双层遍历 i 从1到 len - 1，j 从 0 到 target

​		直接从上一行先把结果抄下来，然后再修正

​		4）当nums[ i ] 等于 j 时，直接返回true，continue

​		5）当nums[ i ] 小于 j 时，i , j 等于 i - 1,j 或 i-1,j -  nums[ i ]

```
		for (int i = 1; i < len; i++) {
            for (int j = 0; j <= target; j++) {
                // 直接从上一行先把结果抄下来，然后再修正
                dp[i][j] = dp[i - 1][j];

                if (nums[i] == j) {
                    dp[i][j] = true;
                    continue;
                }
                if (nums[i] < j) {
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];
                }
            }
        }
```

6）返回 len-1 , target 位











#### 目标和 











#### 硬币兑换

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

![image-20200429152152786](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200429152152786.png)

解题思路

四大步骤

确定状态

![image-20200429152310965](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200429152310965.png)

最后一步

![image-20200429152544436](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200429152544436.png)

其中蕴含了两个关键思想

![image-20200429152756674](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200429152756674.png)

（所谓最优子结构也就是指的是哪怕去掉最后一个硬币ak，前K-1枚硬币组成27-ak的方式也是最优结构）

那么就引出了“子问题”这个概念（所谓的大事化小）

![image-20200429153148355](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200429153148355.png)

通过上述分析得知，问题转换为求子问题最优化，那么就可以得到状态转移方程

![image-20200430122532053](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200430122532053.png)

其中有一个问题，动态规划和递归有什么关系，硬币题用递归求解如下：

![image-20200430122725356](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200430122725356.png)

递归所存在的问题

![image-20200430123052732](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200430123052732.png)

太多重复的步骤，会导致时间复杂度过大，用递归的求解一定不是最优解。

（二）最后得到转移方程，搞清楚子问题与最后一步得到转移方程就会容易很多

![image-20200430123810276](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200430123810276.png)



（三）初始条件和边界情况

边界情况可以理解为，执行到那个位置停下来，越界

初始条件可以理解为，转移方程算不出来，需要手动定义



（四）计算顺序

一维问题，一般是从小到大，少数问题是从大到小

二维问题，一般是从上到下，从左到右

原则：如果转移方程右边的值已知，那么就是从小到大来计算



复杂度分析

与递归相比，没有任何重复计算，其时间复杂度就是n*m（凑齐n块钱，一共m种硬币）



动态规划求解的四个步骤：

![image-20200430125047068](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200430125047068.png)



零钱兑换属于完全背包问题

解题实现

1）新建dp数组大小为amount+1，max=amount+1，各位初始为max

首位初始为0，

```
int max=amount+1;
int[] dp=new int[max];
Arrays.fill(dp,max);
dp[0]=0;
```

3）双层遍历 i 从1 到 amount，j从0 到 coins.length-1

​      4）判断，硬币面值是否**小于等于** i。成立时，dp[i] 赋值为 dp[i] 与子问题 dp[i-coins[j]]+1 的更小值

```
for(int i=1;i<=amount;i++){
	for(int j=0;j<nums.length;j++){
		if(i>=nums[j]){
			dp[i]=Math.min(dp[i],dp[i-nums[j]]+1);
		}
	}
}
```

6）返回时做一个判断，判断动态规划是否生效

```
return dp[N]>N?-1:dp[n];
```







#### 完全背包问题

约束条件：每种物品的数量为无限个，你可以选择任意数量的物品。	



#### 硬币兑换 II

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

![image-20200430135630092](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200430135630092.png)

解题实现：

1）新建dp数组，长度为amount+1，初始首值为1

2）双层遍历，遍历硬币，遍历 i 从 coin 到 amount  特别注意先遍历coins

​	3）转移方程，当前状态等于子问题与当前状态之和（累加）

```
for(coin:coins){
	for(int i=coin;i<amount+1;i++){
		dp[i]+=dp[i-coin];
	}
}
```

4）返回dp数组末尾值



硬币兑换I和II之间的区别为，前者是求最小，后者是求所有可能，都是用动态规划做。





#### 硬币

硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)

注意：无限硬币，完全背包

```
输入: n = 5
 输出：2
 解释: 有两种方式可以凑成总金额:
5=5
5=1+1+1+1+1

 输入: n = 10
 输出：4
 解释: 有四种方式可以凑成总金额:
10=10
10=5+5
10=5+1+1+1+1+1
10=1+1+1+1+1+1+1+1+1+1
```



解题思路

本题为完全背包问题，但是有个很大的陷阱，要考虑硬币顺序带来的影响，因此需要先遍历coins数组，保证在考虑一枚硬币的情况时，没有较大的硬币影响，这样，我们最终每种组合情况，都是以硬币的面额大小非递减组合。保证了同样的情况，调换顺序后重复计算的情况。



错误的答案：

```java
class Solution {
    public int waysToChange(int n) {
        
        int[] dp = new int[n + 1];
        
        int[] coins = new int[]{1,5,10,25};
        
        
        //刚好可以用一个硬币凑成的情况，是一种情况
        // while i == coin :
        //dp[i] = dp[i - coin] => dp[0]
        dp[0] = 1;
        
        /**
        * dp方程：dp[i] += dp[i - coin];
        */
      	//错误点
        for(int i = 1; i <= n; i++) {
            for(int coin: coins) {
                if(i - coin < 0) break;
                dp[i] = (dp[i] + dp[i - coin]) % 1000000007;
            }
        }
        
        return dp[n];
    }
}
```



改正答案：

```java
class Solution {
    public int waysToChange(int n) {
        
        int[] dp = new int[n + 1];
        
        int[] coins = new int[]{1,5,10,25};
       	
        //刚好可以用一个硬币凑成的情况，是一种情况
        // while i == coin :
        //dp[i] = dp[i - coin] => dp[0]
        dp[0] = 1;
        
        /**
        * dp方程：dp[i] += dp[i - coin];
        */
        //先遍历coins，再遍历 n
        for(int coin : coins) {
            for(int i = coin; i <= n; i++) {
                dp[i] = (dp[i] + dp[i - coin]) % 1000000007;
            }
        }
        
        return dp[n];
    }
}
```

















#### 一和零

在计算机界中，我们总是追求用有限的资源获取最大的收益。

现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。

你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。

```
输入: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
输出: 4

解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 "10","0001","1","0" 。

输入: Array = {"10", "0", "1"}, m = 1, n = 1
输出: 2

解释: 你可以拼出 "10"，但之后就没有剩余数字了。更好的选择是拼出 "0" 和 "1" 。
```



解题思路

二维背包



![image-20200608231051418](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200608231051418.png)

dp[i] [j] 定义为i个0，j个1可组成多少个字符串

转移方程：

```
dp(i, j) = max(1 + dp(i - cost_zero[k], j - cost_one[k]))
    if i >= cost_zero[k] and j >= cost_one[k]
```



解题实现

1）新建二维dp数组，尺寸为[m+1] [n+1]，初始化[0] [0]为0

2）遍历字符串，统计当前字符串中0和1的个数

​		3）双层遍历，i从m到count[0]，j从n到count[1] ,注意是自减

​				4）状态转移方程

```
for(String str:strs){
	for(int i=m;i>=count[0];i--){
		for(int j=n;j>=count[1];j--){
			dp[i][j]=Math.max(dp[i][j],dp[i-count[0]][j-count[1]]+1);
		}
	}
}
```

5）返回dp数组[m] [n]位



01计算函数

计算0，1技巧：

```
res[s.charAt(i)-'0']++;
```







### 组合问题

#### 组合总和 Ⅳ

给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

```
nums = [1, 2, 3]
target = 4

所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

请注意，顺序不同的序列被视作不同的组合。

因此输出为 7。
```

解题思路

本题可以用回溯或者动态规划，由于不用得到具体的组合表示，因此考虑使用「动态规划」来解。如果用回溯来写，肯定可以写，但是会超时。

![image-20200608215425203](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200608215425203.png)



![image-20200608215454993](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200608215454993.png)

状态转移矩阵

```
dp[i] = sum{dp[i - num] for num in nums and if i >= num}
```

解题实现

1）新建target+1大小数组，初始化0位为1

2）遍历i从1到target

​		3）遍历数组

​				4）如果num小于等于i，计算状态转移方程

```
for(int i=1;i<=target;i++){
	for(int num:nums){
		if(num<=i){
			dp[i]+=dp[i-num];
		}
	}
}
```

5）返回dp数组target位









#### 目标和

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

```
输入: nums: [1, 1, 1, 1, 1], S: 3
输出: 5
解释: 

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。
```



解题思路

逻辑框架

```
//选择列表
for(int i = index; i<nums.length; i++){
    //选择做出+nums[i]
    ... ...
        
    //选择做出-nums[i]
    ... ...
}
```

![image-20200608222608524](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200608222608524.png)

![image-20200608222627529](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200608222627529.png)

![image-20200608222717839](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200608222717839.png)

故dp表初始化应为：

```
if(nums[0] == 0) dp[0][sum] = 2;
else{
    dp[0][sum+nums[0]] = 1;
    dp[0][sum-nums[0]] = 1;
}
如果nums[0]==0的话，那么+0和-0都应该算作其操作，故if(nums[0] == 0) dp[0][sum] = 2;
```

此外还要注意边界的问题



本题难点在于动态数组定义，初始值判定，转移方程实现

解题实现

1）数组空值判定

2）新建总和值，并计算数组总和

3）若S的绝对值大于sum，直接退出，因为算不出来

4）新建二维dp数组，尺寸为[nums.length] [sum*2+1]

5）初始值：如果初值为0，初始化[0] [sum]为2，否则初始化[0] [sum+nums[0]]和[0] [sum-nums[0]]

均为1

6）双层遍历：i 从 1 到 nums.length，j 从 0 到 sum*2

​		7）分别计算 j - nums[i] 和 j + nums[i] 情况，其中(j - nums[i]) >= 0 ，(j + nums[i]) < (sum*2+1) 

​		8）状态转移方程

9）返回[nums.length-1] [sum+S] 即为计算结果



### True、False问题





#### 单词拆分

给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

- 拆分时可以重复使用字典中的单词。
- 你可以假设字典中没有重复的单词。

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。

输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```





解题思路

![image-20200608225213323](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200608225213323.png)

递推公式表示：

```
dp[i] = ( dp[i-1] && contains(subStr(i-1,i))  )
        || (  dp[i-2] && contains(subStr(i-2,i))  )
        || (  dp[i-3] && contains(subStr(i-3,i))  ) 
        || ...
```



解题实现

1）新建动态数组，长度为len+1，初始化0位为true

2）双层遍历 i 从1到 len，j 从 0 到 i -1

​		3）判断当j位为真时且wordDict中存在j到i的字符串时，可设dp[ i ]为true

```
for(int i=1;i<=len;i++){
	for(int j=0;j<i;j++){
		if(dp[j]&&wordDict.contains(s.substring(j,i)));
	}
}
```

4）返回动态数组len位





















## 树形规划

#### 打家劫舍 III

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

```
输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.

输入: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \ 
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
```





解题思路

![image-20200701202253789](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200701202253789.png)

依旧是打家劫舍的思路，只不过dp结构为树形，可以用递归实现



解题实现

1）空值判断

2）分别获取爷爷+孙子的钱和两儿子的钱

```
int money1=root.val;
if(root.left!=null){
	money+=(rob(root.left.left)+rob(root.left.right));
}
if(root.right!=null){
	money+=(rob(root.right.left)+rob(root.right.right));
}
int money2=rob(root.left)+rob(root.right);
```

3）三者比较返回

```
return Math.max(money1,money2);
```





#### 不同的二叉搜索树

给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```





解题思路

![image-20200701212159557](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200701212159557.png)

![image-20200701212216367](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200701212216367.png)



解题实现

```
public int numTrees(int n) {
        int[] dp=new int[n+1];
        dp[0]=1;
        dp[1]=1;
        for(int i=2;i<=n;i++){
            for(int j=1;j<=i;j++){
                dp[i]+=dp[j-1]*dp[i-j];
            }
        }
        return dp[n];
    }
```











## 状态压缩规划

二进制集合表示法

十进制83可表示为1010011，通过二进制表示就可以表示成[1,2,5,7]

这样一个数就可以表示一个集合了，简洁明了，还可以进行位运算











####  我能赢吗

在 "100 game" 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到 100 的玩家，即为胜者。

如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？

例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 >= 100。

给定一个整数 maxChoosableInteger （整数池中可选择的最大数）和另一个整数 desiredTotal（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？

你可以假设 maxChoosableInteger 不会大于 20， desiredTotal 不会大于 300。

```
输入：
maxChoosableInteger = 10
desiredTotal = 11

输出：
false

解释：
无论第一个玩家选择哪个整数，他都会失败。
第一个玩家可以选择从 1 到 10 的整数。
如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。
第二个玩家可以通过选择整数 10（那么累积和为 11 >= desiredTotal），从而取得胜利.
同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。
```









#### 优美的排列

假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 <= i <= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：

第 i 位的数字能被 i 整除
i 能被第 i 位上的数字整除
现在给定一个整数 N，请问可以构造多少个优美的排列？

```
输入: 2
输出: 2
解释: 

第 1 个优美的排列是 [1, 2]:
  第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除
  第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除

第 2 个优美的排列是 [2, 1]:
  第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除
  第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除
```







#### 骑士拨号器

国际象棋中的骑士可以按下图所示进行移动：

![image-20200701205437878](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200701205437878.png)


这一次，我们将 “骑士” 放在电话拨号盘的任意数字键（如上图所示）上，接下来，骑士将会跳 N-1 步。每一步必须是从一个数字键跳到另一个数字键。

每当它落在一个键上（包括骑士的初始位置），都会拨出键所对应的数字，总共按下 N 位数字。

你能用这种方式拨出多少个不同的号码？

因为答案可能很大，所以输出答案模 10^9 + 7。

```
输入：1
输出：10

输入：2
输出：20

输入：3
输出：46
```







#### 旅行商问题







#### 毕业旅行

小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。由于经费有限，希望能够通过合理的路线安排尽可能的省一些路上的花销。给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。

```
4
0 2 6 5
2 0 4 4
6 4 0 2
5 4 2 0
```

```
13
```



解题思路

![image-20200619224504438](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200619224504438.png)

解题实现







#### 参加考试的最大学生数





## 数位规划

#### 







#### 数字 1 的个数

给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。

```
输入: 13
输出: 6 
解释: 数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。
```





#### 最大为 N 的数字组合





## 计数型 规划





## 递推型 规划

#### 爬楼梯

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

![image-20200508114104774](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200508114104774.png)

解题思路：

![image-20200508114628722](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200508114628722.png)

解题实现

1）当n为1时直接返回1

2）新建动态数组长度为n+1

3）初始化1,2位置值分别为1,2

4）遍历i从3开始到n，转移方程，第i位的值为i-1位和i-2位的值求和

```
for(int i=3;i<=n;i++){
	dp[i]=dp[i-1]+dp[i-2];
}
```

5）返回动态数组第n位



#### 牛妹的蛋糕

第一天牛妹吃掉蛋糕总数三分之一（向下取整）多一个，第二天又将剩下的蛋糕吃掉三分之一（向下取整）多一个，以后每天吃掉前一天剩下的三分之一（向下取整）多一个，到第n天准备吃的时候只剩下一个蛋糕。
牛妹想知道第一天开始吃的时候蛋糕一共有多少呢？

```
输入
4
输出
10
```

解题思路

主要是转移方程的思考，而且计算顺序是反向的

```
dp[i] = 3 * (dp[i + 1] + 1) / 2;
```



解题实现

```
for(int i=n-1;i>0;i++){
	dp[i]=3*(dp[i+1]+1)/2;
}
```



#### 斐波拉契数列

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

解题思路

![image-20200508130656340](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200508130656340.png)

解题实现

1）当n为0时直接返回

2）新建动态数组长度为n+1

3）初始值,1位置赋值为1

4）遍历i从2到n

​		5)转移方程，注意模1000000007

```
for(int i=2;i<=n;i++){
	dp[i]=(dp[i-1]+dp[i-2])%1000000007;
}
```

6）返回第n位





####  第 N 个泰波那契数

泰波那契序列 Tn 定义如下： 

T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2

给你整数 n，请返回第 n 个泰波那契数 Tn 的值。

```
输入：n = 4
输出：4
解释：
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4
```



解题实现

```
public int tribonacci(int n) {
        int[] dp=new int[n+1];
        if(n<2){
            return n;
        }
        if(n==2){
            return 1;
        }
        dp[0]=0;
        dp[1]=1;
        dp[2]=1;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2]+dp[i-3];
        }
        return dp[n];
    }
```





#### 最长的斐波那契子序列的长度

如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的：

n >= 3
对于所有 i + 2 <= n，都有 X_i + X_{i+1} = X_{i+2}
给定一个严格递增的正整数数组形成序列，找到 A 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。

（回想一下，子序列是从原序列 A 中派生出来的，它从 A 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）

![image-20200508131351232](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200508131351232.png)

解题思路

本题的结构是普通的动态规划的结构，状态定义 + 状态转移方程 ，难点在于**状态如何定义**

![image-20200508135239338](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200508135239338.png)



此题用了很多技巧，比如将数组转为Map等

难点在于如何确定状态和转移方程

解题实现

1）获取数组的长度n

2）新建HashMap，find_k，遍历初始化其键为数组值，值为数组索引值

```
for(int i=0;i<n;i++){
	find_k.put(A[i],i);
}
```

3）新建二维动态数组，大小为n*n，双层遍历初始化，i从0到n-1，j从i+1到n-1，动态数组值初始化为2

```
for(int i=0;i<n;i++){
	for(int j=i+1;j<n;j++){
		dp[i][j]=2;
	}
}
```

4）初始化返回值为0

5）双层遍历，i 从 1 到 n-2 , j 从 i+1 到 n-1

​		6）由 j 和 i，从映射find_k中取出索引k值，注意类型为Object型

​		7）判断，k不为null时且 (int) 后小于i时，状态转移方程 i,j 的值为 k,i 的值加1

```
for(int i=1;i<n-1;i++){
	for(int j=i+1;j<n;j++){
		Object k=find_k.get(A[j]-A[i]);
		if(k!=null&&(int)k<i){
			dp[i][j]=dp[(int)k][i]+1;
		}	
	}
}
```

​		8）返回值为返回值、动态数组i,j值的较大值

```
res=Math.max(res,dp[i][j]);
```

9）判断返回值是否大于2，大于则返回返回值，否则返回0

```
return res>2?res:0;
```





#### N 天后的牢房

8 间牢房排成一排，每间牢房不是有人住就是空着。

每天，无论牢房是被占用或空置，都会根据以下规则进行更改：

如果一间牢房的两个相邻的房间都被占用或都是空的，那么该牢房就会被占用。
否则，它就会被空置。
（请注意，由于监狱中的牢房排成一行，所以行中的第一个和最后一个房间无法有两个相邻的房间。）

我们用以下方式描述监狱的当前状态：如果第 i 间牢房被占用，则 cell[i]==1，否则 cell[i]==0。

根据监狱的初始状态，在 N 天后返回监狱的状况（和上述 N 种变化）。

```
输入：cells = [0,1,0,1,1,0,0,1], N = 7
输出：[0,0,1,1,0,0,0,0]
解释：
下表概述了监狱每天的状况：
Day 0: [0, 1, 0, 1, 1, 0, 0, 1]
Day 1: [0, 1, 1, 0, 0, 0, 0, 0]
Day 2: [0, 0, 0, 0, 1, 1, 1, 0]
Day 3: [0, 1, 1, 0, 0, 1, 0, 0]
Day 4: [0, 0, 0, 0, 0, 1, 0, 0]
Day 5: [0, 1, 1, 1, 0, 1, 0, 0]
Day 6: [0, 0, 1, 0, 1, 1, 0, 0]
Day 7: [0, 0, 1, 1, 0, 0, 0, 0]

```



解题思路

没有新建dp数组，而是调用clone()方法，直接复制之前一个状态



规律：每隔十四天，牢房的状态重复出现，因此可以对N进行处理

```
N=(N-1)%14+1
```



转移方程

```
dp[i]=1 if cells[i-1]==cells[i+1];
dp[i]=0 else 
```



解题实现

1）获取监狱长度，克隆监狱给dp数组

2）初始化dp数组的0位和len-1位均为0

3）因为14天重复规律的存在，对N进行处理

4）双层遍历，遍历N，监狱单元遍历，i 从1到len-2

​		5）状态转移方程

​		6）处理完之后还要重新克隆给cells

```
for(int time=0;time<N;time++){
	for(int i=1;i<=len-2;i++){
		if(cells[i-1]==cells[i+1]){
			dp[i]=1;
		}else{
			dp[i]=0;
		}
	}
	cells=dp.clone();
}
```

7）返回





## 概率型 规划

#### 分汤





解题思路

![image-20200701215936285](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200701215936285.png)



计算N对25的倍数

```
N=N/25+(N%25>0?1:0)
```



本题的结果在N大于500之后趋近于1，因此可以直接返回1





解题实现

1）对N进行处理    注意处理N在N值判定之前

2）N大于500返回1

3）新建double 的dp数组

4）双层遍历

​		s 从 0 到 2*N，j从 0 到 N

​		5）计算B的汤量

​		6）当B的汤不符合要求时，跳过

​		7）初始化当前 i,j 位为0，根据A和B的汤量分别讨论，只有A，B的汤均大于0时才会调用状态转移方程

```
if(i==0){
 	dp[i][j]=1.0;
}else if(i==0&&j==0){
	dp[i][j]=0.5;
}else if(i>0&&j>0){
	dp[i][j]=0.25*(dp[max(i-4)][j]+dp[max(i-3)][max(j-1)]
			+dp[max(i-2)][max(j-2)]+dp[max(i-1)][max(j-3)];
}
```





最大值函数

8）返回x与0之间的较大值

```
return Math.max(0,x);
```





#### 新21点





## 博弈型 规划

策梅洛定理，SG 定理，minimax

#### 除数博弈

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：

选出任一 x，满足 0 < x < N 且 N % x == 0 。
用 N - x 替换黑板上的数字 N 。
如果玩家无法执行这些操作，就会输掉游戏。

只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。

![image-20200519150140764](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200519150140764.png)

解题思路

确定状态：获胜的状态是假如dp[i]为true，且dp[i-x]为false，使子问题最优

转移方程：

```
dp[i]=true 当i%x==0&&dp[i-x]为false
```

初始值：dp[1]=false；dp[2]=true；

计算顺序：从前到后

解题实现

1）当N等于1时直接返回false

2）初始化动态数组，长度为N+1，1,2位置分别我false和true

3）遍历 i 从3到N

​		4）预设第i位为false

​		5）遍历 j 从1到 i-1

​			6）当 i 余 j 为0，且dp的 i-j 位为 false 时，令 dp[ i ] 为真，直接返回

```
for(int i=3;i<=N;i++){
	dp[i]=false;
	for(int j=1;j<i;j++){
		if(i%j==0&&!dp[i-j]){
			dp[i]=true;
			break;
		}
	}
}
```



7）返回动态数组第N位。











#### 跳跃游戏

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

![image-20200506144639888](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200506144639888.png)

解题思路

​		建立bool类型的flags数组，表示能否跳到该节点。在求解flags[i]时，向前遍历，如果存在flags[j]为True且能从j跳到i，那么flags[i]就为True。

解题实现

1）获取数组长度，新建Boolean类型的动态数组，初始第一项为true

2）两层遍历，j从1到n-1；   i从0到j-1

​	3）判断是否能到第i位且能从第i位跳到第j位

​		  成立时：第j位赋值位true，执行break

```
if(dp[i]&&(i+nums[i]>=j)){
	dp[j]=true;
	break;
}
```

4）返回动态数组最后一位





#### 跳跃游戏 II

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

![image-20200506150700444](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200506150700444.png)





### Nim游戏

#### Nim 游戏





#### 石子游戏





#### 石子游戏 II





### 井字游戏

#### 判定井字棋胜负







#### 有效的井字游戏







#### 找出井字棋的获胜者







## 困难问题

### 旅行商问题



















#### 正则表达式匹配







#### 鸡蛋掉落

你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

```
输入：K = 1, N = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
如果它没碎，那么我们肯定知道 F = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。
```

```
输入：K = 2, N = 6
输出：3
```

```
输入：K = 3, N = 14
输出：4
```



解题思路

见https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/

![image-20200604043049432](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200604043049432.png)

![image-20200604043100602](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200604043100602.png)

![image-20200604043109551](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200604043109551.png)

![image-20200604043119164](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200604043119164.png)

本题要点

1）一定要绘制鸡蛋楼层关系曲线，T1,T2相交逻辑，先画图再做题

2）记忆化递归，减少复杂度

3）边界情况N等于0和K等于1

4）二分法找到T1,T2的交点

5）状态转移方程的列写与理解

注意

1）摔破鸡蛋，K-1，而定位下区间，因此 (K-1,X-1)

​	  没摔破，K不变，而定位上区间，因此 (K,N-X)

2）记忆化映射的键存储的为K,N的编码值N*100+K







解题实现

1）定义全局记忆映射

2）调用动态规划函数 传入K,N

​		3）判断记忆映射是否包含K,N，编码：N*100+K，如果不存在继续

```
if(!memory.containsKey(N*100+K)){

}
```

​		4）定义结果变量

​		5）判断N等于0时，结果变量直接赋值为0

​		6）判断K等于1时，结果变量直接赋值为N

​		7）否则，初始化lo和hi分别为1和N

​		(二分法，找到T1和T2的交点)

​		8）while循环  当lo+1小于hi时（需要绘出关系图）

​				9）二分mid等于lo+hi取半

​				10）获取t1为 dp(K-1, mid-1);获取t2为dp(K, N-mid);

​				11）判断若t1 < t2，lo = mid;lo右移，t1 > t2， hi = mid;hi左移

​				12）否则，lo = hi = mid;退出循环，找到目标值

```
while(lo+1<hi){
	int mid=(lo+hi)/2;
	int t1=dp(K-1,mid-1);
	int t2=dp(k,N-mid);
	if(t1<t2){
		lo=mid;
	}else if(t1>t2){
		hi=mid;
	}else{
		lo=hi=mid;
	}
}
```

​				13）状态转移方程，min的第一项为X替换为lo，第二项为X替换为hi，返回为ans

![image-20200604044513811](C:\Users\张秦\AppData\Roaming\Typora\typora-user-images\image-20200604044513811.png)

```
int ans=1+Math.min(Math.max(dp(K-1,lo-1),dp(k,N-lo)),Math.max(dp(K-1,hi-1),dp(K,N-hi)));
```

​		14）将N * 100 + K，ans放入记忆映射

```
memory.put(N*100+K,ans);
```

​	15）返回记忆映射的N * 100 + K项

```
return memory.get(N*100+K);
```







#### 奇怪的打印机





#### 戳气球





#### 俄罗斯套娃信封问题



#### 统计不同回文子字符串





#### 二叉树中的最大路径和





#### 腾讯2020校园招聘-后台-视野争夺

小Q在进行一场竞技游戏,这场游戏的胜负关键就在于能否能争夺一条长度为L的河道,即可以看作是[0,L]的一条数轴。

这款竞技游戏当中有n个可以提供视野的道具−真视守卫,第i个真视守卫能够覆盖区间[xi,yi]。现在小Q想知道至少用几个真视守卫就可以覆盖整段河道。 

```
输入包括n+1行。

第一行包括两个正整数n和L(1<=n<=105,1<=L<=109)

接下来的n行,每行两个正整数xi,yi(0<=xi<=yi<=109),表示第i个真视守卫覆盖的区间。 
一个整数，表示最少需要的真视守卫数量, 如果无解, 输出-1。
in
4 6
3 6
2 4
0 2
4 7
out
3
```



### 有限状态机

定义

```
有限状态机又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型，用英文缩写也被简称为 FSM。FSM 会响应“事件”而改变状态，当事件发生时，就会调用一个函数，而且 FSM 会执行动作产生输出，所执行的动作会因为当前系统的状态和输入的事件不同而不同。
```

![img](https://pic1.zhimg.com/80/v2-34e1a6c0a5c84a05df5cd855f60ba2cd_720w.jpg)







#### 剑指 Offer 20. 表示数值的字符串

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100"、"5e2"、"-123"、"3.1416"、"0123"都表示数值，但"12e"、"1a3.14"、"1.2.3"、"+-5"、"-1E-16"及"12e+5.4"都不是。







#### 腾讯2020校园招聘-假期

由于业绩优秀，公司给小Q放了 n 天的假，身为工作狂的小Q打算在在假期中工作、锻炼或者休息。他有个奇怪的习惯：不会连续两天工作或锻炼。只有当公司营业时，小Q才能去工作，只有当健身房营业时，小Q才能去健身，小Q一天只能干一件事。给出假期中公司，健身房的营业情况，求小Q最少需要休息几天。

```
第一行一个整数  表示放假天数
第二行 n 个数 每个数为0或1,第 i 个数表示公司在第 i 天是否营业
第三行 n 个数 每个数为0或1,第 i 个数表示健身房在第 i 天是否营业
（1为营业 0为不营业）

out
一个整数，表示小Q休息的最少天数

in
4
1 1 0 0
0 1 1 0
out
2
小Q可以在第一天工作，第二天或第三天健身，小Q最少休息2天
```



解题思路

可绘制状态机如图

<img src="https://uploadfiles.nowcoder.com/images/20200212/514769_1581437581638_F3CCDD27D2000E3F9255A7E3E2C48800" alt="img" style="zoom: 33%;" />



```
策略：使用dp[i][0] dp[i][1] dp[i][2]分别记录在第i天如果是休息、工作、健身情况下，前i天有事做（也就是没休息）的最大天数
1 如果第i天休息，那么前i天有事做的最大天数，实际就是dp[i-1][0] dp[i-1][1] dp[i-1][2]中的最大值
2 如果第i天工作，那么前i天有事做的最大天数，就是前一天休息、健身中的最大值 + 1（因为第i天工作了，没有休息）
3 如果第i天健身，那么前i天有事做的最大天数，就是前一天休息、工作中的最大值 + 1（因为第i天健身了，没有休息）

最后的结果，就用day减去最大的做事天数，就是最少的休息时间了
```



solve解题实现

1）新建返回值和dp数组，初始化dp数组，初始值均为0

```
int res;
int[][] dp=new int[day+1][3];
dp[0][1]=dp[0][1]=dp[0][2]=0;
```

2）遍历

​		3）状态转移方程

```
if works[i]==1 dp[i][1]=max(dp[i-1][0].dp[i-1][2])+1
if gyms[i]==1 dp[i][1]=max(dp[i-1][0],dp[i-1][1])+1

dp[i][0]=max(dp[i-1][0],dp[i-1][1],dp[i-1][2])
```

4）计算返回结果







































